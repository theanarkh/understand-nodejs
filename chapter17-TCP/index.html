<!doctype html><html lang=zh class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="通过源码分析 Node.js 原理"><meta name=author content=theanarkh><link href=https://github.com/theanarkh/understand-nodejs/chapter17-TCP/ rel=canonical><link href=../chapter16-UDP/ rel=prev><link href=../chapter18-HTTP/ rel=next><link rel=icon href=../assets/images/favicon.png><meta name=generator content="mkdocs-1.6.1, mkdocs-material-9.5.44"><title>17-TCP - Node.js 源码剖析</title><link rel=stylesheet href=../assets/stylesheets/main.0253249f.min.css><link rel=stylesheet href=../assets/stylesheets/palette.06af60db.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=indigo data-md-color-accent=indigo> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#171-tcp class=md-skip> 跳转至 </a> </div> <div data-md-component=announce> </div> <header class="md-header md-header--shadow md-header--lifted" data-md-component=header> <nav class="md-header__inner md-grid" aria-label=页眉> <a href=.. title="Node.js 源码剖析" class="md-header__button md-logo" aria-label="Node.js 源码剖析" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="m19 2-5 4.5v11l5-4.5zM6.5 5C4.55 5 2.45 5.4 1 6.5v14.66c0 .25.25.5.5.5.1 0 .15-.07.25-.07 1.35-.65 3.3-1.09 4.75-1.09 1.95 0 4.05.4 5.5 1.5 1.35-.85 3.8-1.5 5.5-1.5 1.65 0 3.35.31 4.75 1.06.1.05.15.03.25.03.25 0 .5-.25.5-.5V6.5c-.6-.45-1.25-.75-2-1V19c-1.1-.35-2.3-.5-3.5-.5-1.7 0-4.15.65-5.5 1.5V6.5C10.55 5.4 8.45 5 6.5 5"/></svg> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> Node.js 源码剖析 </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> 17-TCP </span> </div> </div> </div> <form class=md-header__option data-md-component=palette> <input class=md-option data-md-color-media data-md-color-scheme=default data-md-color-primary=indigo data-md-color-accent=indigo aria-label="Switch to dark mode" type=radio name=__palette id=__palette_0> <label class="md-header__button md-icon" title="Switch to dark mode" for=__palette_1 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M17 6H7c-3.31 0-6 2.69-6 6s2.69 6 6 6h10c3.31 0 6-2.69 6-6s-2.69-6-6-6m0 10H7c-2.21 0-4-1.79-4-4s1.79-4 4-4h10c2.21 0 4 1.79 4 4s-1.79 4-4 4M7 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3"/></svg> </label> <input class=md-option data-md-color-media data-md-color-scheme=slate data-md-color-primary=blue data-md-color-accent=blue aria-label="Switch to light mode" type=radio name=__palette id=__palette_1> <label class="md-header__button md-icon" title="Switch to light mode" for=__palette_0 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3"/></svg> </label> </form> <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=搜索 placeholder=搜索 autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg> </label> <nav class=md-search__options aria-label=查找> <a href=javascript:void(0) class="md-search__icon md-icon" title=分享 aria-label=分享 data-clipboard data-clipboard-text data-md-component=search-share tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91s2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08"/></svg> </a> <button type=reset class="md-search__icon md-icon" title=清空当前内容 aria-label=清空当前内容 tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg> </button> </nav> <div class=md-search__suggest data-md-component=search-suggest></div> </form> <div class=md-search__output> <div class=md-search__scrollwrap tabindex=0 data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> 正在初始化搜索引擎 </div> <ol class=md-search-result__list role=presentation></ol> </div> </div> </div> </div> </div> <div class=md-header__source> <a href=https://github.com/theanarkh/understand-nodejs title=前往仓库 class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 496 512"><!-- Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg> </div> <div class=md-source__repository> understand-nodejs </div> </a> </div> </nav> <nav class=md-tabs aria-label=标签 data-md-component=tabs> <div class=md-grid> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=.. class=md-tabs__link> Home </a> </li> <li class=md-tabs__item> <a href=../chapter00-%E5%89%8D%E8%A8%80/ class=md-tabs__link> 前言 </a> </li> <li class=md-tabs__item> <a href=../chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/ class=md-tabs__link> Node.js基础和架构 </a> </li> <li class="md-tabs__item md-tabs__item--active"> <a href=../chapter07-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/ class=md-tabs__link> Node.js核心模块的实现 </a> </li> <li class=md-tabs__item> <a href=../chapter20-%E6%8B%93%E5%B1%95Node.js/ class=md-tabs__link> 其他 </a> </li> </ul> </div> </nav> </header> <div class=md-container data-md-component=container> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted" aria-label=导航栏 data-md-level=0> <label class=md-nav__title for=__drawer> <a href=.. title="Node.js 源码剖析" class="md-nav__button md-logo" aria-label="Node.js 源码剖析" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="m19 2-5 4.5v11l5-4.5zM6.5 5C4.55 5 2.45 5.4 1 6.5v14.66c0 .25.25.5.5.5.1 0 .15-.07.25-.07 1.35-.65 3.3-1.09 4.75-1.09 1.95 0 4.05.4 5.5 1.5 1.35-.85 3.8-1.5 5.5-1.5 1.65 0 3.35.31 4.75 1.06.1.05.15.03.25.03.25 0 .5-.25.5-.5V6.5c-.6-.45-1.25-.75-2-1V19c-1.1-.35-2.3-.5-3.5-.5-1.7 0-4.15.65-5.5 1.5V6.5C10.55 5.4 8.45 5 6.5 5"/></svg> </a> Node.js 源码剖析 </label> <div class=md-nav__source> <a href=https://github.com/theanarkh/understand-nodejs title=前往仓库 class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 496 512"><!-- Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg> </div> <div class=md-source__repository> understand-nodejs </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=.. class=md-nav__link> <span class=md-ellipsis> Home </span> </a> </li> <li class=md-nav__item> <a href=../chapter00-%E5%89%8D%E8%A8%80/ class=md-nav__link> <span class=md-ellipsis> 前言 </span> </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_3> <label class=md-nav__link for=__nav_3 id=__nav_3_label tabindex=0> <span class=md-ellipsis> Node.js基础和架构 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_3_label aria-expanded=false> <label class=md-nav__title for=__nav_3> <span class="md-nav__icon md-icon"></span> Node.js基础和架构 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/ class=md-nav__link> <span class=md-ellipsis> 01-Node.js组成和原理 </span> </a> </li> <li class=md-nav__item> <a href=../chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/ class=md-nav__link> <span class=md-ellipsis> 02-Libuv数据结构和通用逻辑 </span> </a> </li> <li class=md-nav__item> <a href=../chapter03-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/ class=md-nav__link> <span class=md-ellipsis> 03-事件循环 </span> </a> </li> <li class=md-nav__item> <a href=../chapter04-%E7%BA%BF%E7%A8%8B%E6%B1%A0/ class=md-nav__link> <span class=md-ellipsis> 04-线程池 </span> </a> </li> <li class=md-nav__item> <a href=../chapter05-Libuv%E6%B5%81/ class=md-nav__link> <span class=md-ellipsis> 05-Libuv流 </span> </a> </li> <li class=md-nav__item> <a href=../chapter06-C%2B%2B%E5%B1%82/ class=md-nav__link> <span class=md-ellipsis> 06-C++层 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4 checked> <label class=md-nav__link for=__nav_4 id=__nav_4_label tabindex> <span class=md-ellipsis> Node.js核心模块的实现 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_4_label aria-expanded=true> <label class=md-nav__title for=__nav_4> <span class="md-nav__icon md-icon"></span> Node.js核心模块的实现 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../chapter07-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/ class=md-nav__link> <span class=md-ellipsis> 07-信号处理 </span> </a> </li> <li class=md-nav__item> <a href=../chapter08-DNS/ class=md-nav__link> <span class=md-ellipsis> 08-DNS </span> </a> </li> <li class=md-nav__item> <a href=../chapter09-Unix%E5%9F%9F/ class=md-nav__link> <span class=md-ellipsis> 09-Unix域 </span> </a> </li> <li class=md-nav__item> <a href=../chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/ class=md-nav__link> <span class=md-ellipsis> 10-定时器 </span> </a> </li> <li class=md-nav__item> <a href=../chapter11-setImmediate%E5%92%8CnextTick/ class=md-nav__link> <span class=md-ellipsis> 11-setImmediate和nextTick </span> </a> </li> <li class=md-nav__item> <a href=../chapter12-%E6%96%87%E4%BB%B6/ class=md-nav__link> <span class=md-ellipsis> 12-文件 </span> </a> </li> <li class=md-nav__item> <a href=../chapter13-%E8%BF%9B%E7%A8%8B/ class=md-nav__link> <span class=md-ellipsis> 13-进程 </span> </a> </li> <li class=md-nav__item> <a href=../chapter14-%E7%BA%BF%E7%A8%8B/ class=md-nav__link> <span class=md-ellipsis> 14-线程 </span> </a> </li> <li class=md-nav__item> <a href=../chapter15-Cluster/ class=md-nav__link> <span class=md-ellipsis> 15-Cluster </span> </a> </li> <li class=md-nav__item> <a href=../chapter16-UDP/ class=md-nav__link> <span class=md-ellipsis> 16-UDP </span> </a> </li> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" type=checkbox id=__toc> <label class="md-nav__link md-nav__link--active" for=__toc> <span class=md-ellipsis> 17-TCP </span> <span class="md-nav__icon md-icon"></span> </label> <a href=./ class="md-nav__link md-nav__link--active"> <span class=md-ellipsis> 17-TCP </span> </a> <nav class="md-nav md-nav--secondary" aria-label=目录> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> 目录 </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#171-tcp class=md-nav__link> <span class=md-ellipsis> 17.1 TCP客户端 </span> </a> <nav class=md-nav aria-label="17.1 TCP客户端"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#1711 class=md-nav__link> <span class=md-ellipsis> 17.1.1 建立连接 </span> </a> </li> <li class=md-nav__item> <a href=#1712 class=md-nav__link> <span class=md-ellipsis> 17.1.2 读操作 </span> </a> </li> <li class=md-nav__item> <a href=#1713 class=md-nav__link> <span class=md-ellipsis> 17.1.3 写操作 </span> </a> </li> <li class=md-nav__item> <a href=#1714 class=md-nav__link> <span class=md-ellipsis> 17.1.4 关闭写操作 </span> </a> </li> <li class=md-nav__item> <a href=#1715 class=md-nav__link> <span class=md-ellipsis> 17.1.5 销毁 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#172-tcp class=md-nav__link> <span class=md-ellipsis> 17.2 TCP 服务器 </span> </a> </li> <li class=md-nav__item> <a href=#173-keepalive class=md-nav__link> <span class=md-ellipsis> 17.3 keepalive </span> </a> </li> <li class=md-nav__item> <a href=#174-allowhalfopen class=md-nav__link> <span class=md-ellipsis> 17.4 allowHalfOpen </span> </a> </li> <li class=md-nav__item> <a href=#175-server-close class=md-nav__link> <span class=md-ellipsis> 17.5 server close </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../chapter18-HTTP/ class=md-nav__link> <span class=md-ellipsis> 18-HTTP </span> </a> </li> <li class=md-nav__item> <a href=../chapter19-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD/ class=md-nav__link> <span class=md-ellipsis> 19-模块加载 </span> </a> </li> <li class=md-nav__item> <a href=../chapter21-JS%20Stream/ class=md-nav__link> <span class=md-ellipsis> 20-JS Stream </span> </a> </li> <li class=md-nav__item> <a href=../chapter22-events%E6%A8%A1%E5%9D%97/ class=md-nav__link> <span class=md-ellipsis> 21-events模块 </span> </a> </li> <li class=md-nav__item> <a href=../chapter23-Async%20hooks/ class=md-nav__link> <span class=md-ellipsis> 22-Async hooks </span> </a> </li> <li class=md-nav__item> <a href=../chapter24-Inspector/ class=md-nav__link> <span class=md-ellipsis> 23-Inspector </span> </a> </li> <li class=md-nav__item> <a href=../chapter27-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Node.js%20%E7%9A%84%20Buffer/ class=md-nav__link> <span class=md-ellipsis> 27-深入理解 Node.js 的 Buffer </span> </a> </li> <li class=md-nav__item> <a href=../chapter30-Node.js%20%E7%9A%84%20trace%20events%20%E6%9E%B6%E6%9E%84/ class=md-nav__link> <span class=md-ellipsis> 30-Node.js 的 trace events 架构 </span> </a> </li> <li class=md-nav__item> <a href=../chapter31-Node.js%20%E7%9A%84%20perf_hooks/ class=md-nav__link> <span class=md-ellipsis> 31-Node.js 的 perf_hooks </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_5> <label class=md-nav__link for=__nav_5 id=__nav_5_label tabindex=0> <span class=md-ellipsis> 其他 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_5_label aria-expanded=false> <label class=md-nav__title for=__nav_5> <span class="md-nav__icon md-icon"></span> 其他 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../chapter20-%E6%8B%93%E5%B1%95Node.js/ class=md-nav__link> <span class=md-ellipsis> 24-拓展Node.js </span> </a> </li> <li class=md-nav__item> <a href=../chapter25-Node.js子线程调试和诊断指南 class=md-nav__link> <span class=md-ellipsis> 25-Node.js子线程调试和诊断指南 </span> </a> </li> <li class=md-nav__item> <a href=../chapter26-vscode%E8%B0%83%E8%AF%95Node.js/ class=md-nav__link> <span class=md-ellipsis> 26-vscode调试Node.js </span> </a> </li> <li class=md-nav__item> <a href=../chapter28-Node.js%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%88%E6%9E%B6%E6%9E%84%E7%AF%87%EF%BC%89/ class=md-nav__link> <span class=md-ellipsis> 28-Node.js底层原理（架构篇） </span> </a> </li> <li class=md-nav__item> <a href=../chapter29-Node.js%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%88%E5%AE%9E%E7%8E%B0%E7%AF%87%EF%BC%89/ class=md-nav__link> <span class=md-ellipsis> 29-Node.js底层原理（实现篇） </span> </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label=目录> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> 目录 </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#171-tcp class=md-nav__link> <span class=md-ellipsis> 17.1 TCP客户端 </span> </a> <nav class=md-nav aria-label="17.1 TCP客户端"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#1711 class=md-nav__link> <span class=md-ellipsis> 17.1.1 建立连接 </span> </a> </li> <li class=md-nav__item> <a href=#1712 class=md-nav__link> <span class=md-ellipsis> 17.1.2 读操作 </span> </a> </li> <li class=md-nav__item> <a href=#1713 class=md-nav__link> <span class=md-ellipsis> 17.1.3 写操作 </span> </a> </li> <li class=md-nav__item> <a href=#1714 class=md-nav__link> <span class=md-ellipsis> 17.1.4 关闭写操作 </span> </a> </li> <li class=md-nav__item> <a href=#1715 class=md-nav__link> <span class=md-ellipsis> 17.1.5 销毁 </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#172-tcp class=md-nav__link> <span class=md-ellipsis> 17.2 TCP 服务器 </span> </a> </li> <li class=md-nav__item> <a href=#173-keepalive class=md-nav__link> <span class=md-ellipsis> 17.3 keepalive </span> </a> </li> <li class=md-nav__item> <a href=#174-allowhalfopen class=md-nav__link> <span class=md-ellipsis> 17.4 allowHalfOpen </span> </a> </li> <li class=md-nav__item> <a href=#175-server-close class=md-nav__link> <span class=md-ellipsis> 17.5 server close </span> </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <h1>17-TCP</h1> <p>本章我们主要看一下Node.js中对TCP的封装，我们首先看一下在网络编程中，是如何编写一个服务器和客户端的（伪代码）。 服务器</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=kd>const</span><span class=w> </span><span class=nx>fd</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>socket</span><span class=p>();</span><span class=w>  </span>
<span class=w>    </span><span class=nx>bind</span><span class=p>(</span><span class=nx>fd</span><span class=p>,</span><span class=w> </span><span class=nx>ip</span><span class=p>,</span><span class=w> </span><span class=nx>port</span><span class=p>);</span><span class=w>  </span>
<span class=w>    </span><span class=nx>listen</span><span class=p>(</span><span class=nx>fd</span><span class=p>);</span><span class=w>  </span>
<span class=w>    </span><span class=kd>const</span><span class=w> </span><span class=nx>acceptedFd</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>accept</span><span class=p>(</span><span class=nx>fd</span><span class=p>);</span><span class=w>  </span>
<span class=w>    </span><span class=nx>handle</span><span class=p>(</span><span class=nx>acceptedFd</span><span class=p>);</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>我们看一下这几个函数的作用 1 socket：socket函数用于从操作系统申请一个socket结构体，Linux中万物皆文件，所以最后操作系统会返回一个fd，fd在操作系统中类似数据库的id，操作系统底层维护了fd对应的资源，比如网络、文件、管道等，后续就可以通过该fd去操作对应的资源。 2 bind：bind函数用于给fd对应的socket设置地址（IP和端口），后续需要用到。 3 listen：listen函数用于修改fd对应的socket的状态和监听状态。只有监听状态的socket可以接受客户端的连接。socket我们可以理解有两种，一种是监听型的，一种是通信型的，监听型的socket只负责处理三次握手，建立连接，通信型的负责和客户端通信。 4 accept：accept函数默认会阻塞进程，直到有有连接到来并完成三次握手。 执行完以上代码，就完成了一个服务器的启动。这时候关系图如图17-1所示。 <br> <img alt src=https://img-blog.csdnimg.cn/e6592d4fb16d460180ec478a9d0def2a.png><br> 图17-1<br> 客户端</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=kd>const</span><span class=w> </span><span class=nx>fd</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>socket</span><span class=p>();</span><span class=w>  </span>
<span class=w>    </span><span class=kd>const</span><span class=w> </span><span class=nx>connectRet</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>connect</span><span class=p>(</span><span class=nx>fd</span><span class=p>,</span><span class=w> </span><span class=nx>ip</span><span class=p>,</span><span class=w> </span><span class=nx>port</span><span class=p>);</span><span class=w>  </span>
<span class=w>    </span><span class=nx>write</span><span class=p>(</span><span class=nx>fd</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;hello&#39;</span><span class=p>);</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>客户端比服务器稍微简单一点，我们看看这几个函数的作用。<br> 1 socket：和服务器一样，客户端也需要申请一个socket用于和服务器通信。<br> 2 connect：connect会开始三次握手过程，默认情况下会阻塞进程，直到连接有结果，连接结果通过返回值告诉调用方，如果三次握手完成，那么我们就可以开始发送数据了。<br> 3 write：write用于给服务器发送数据，不过并不是直接发送，这些数据只是保存到socket的发送缓冲区，底层会根据TCP协议决定什么时候发送数据。</p> <p>我们看一下当客户端发送第一个握手的syn包时，socket处于syn发送状态，我们看看这时候的服务器是怎样的，如图17-2所示。<br> <img alt src="https://img-blog.csdnimg.cn/81aa03be472d4923b127be501c0055c3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RIRUFOQVJLSA==,size_16,color_FFFFFF,t_70"><br> 图17-2<br> 我们看到这时候，服务器对应的socket中，会新建一个socket用于后续通信（socket结构体有一个字段指向该队列）。并且标记该socket的状态为收到syn，然后发送ack，即第二次握手，等到客户端回复第三次握手的数据包时，就完成了连接的建立。不同的操作系统版本实现不一样，有的版本实现中，已完成连接和正在建立连接的socket是在一个队列中的，有的版本实现中，已完成连接和正在建立连接的socket是分为两个队列维护的。 当客户端和服务器完成了TCP连接后，就可以进行数据通信了，这时候服务器的accept就会从阻塞中被唤醒，并从连接队列中摘下一个已完成连接的socket结点，然后生成一个新的fd。后续就可以在该fd上和对端通信。那么当客户端发送一个TCP数据包过来的时候，操作系统是如何处理的呢？<br> 1 操作系统首先根据TCP报文的源IP、源端口、目的IP、目的端口等信息从socket池中找到对应的socket。<br> 2 操作系统判断读缓冲区是否还有足够的空间，如果空间不够，则丢弃TCP报文，否则把报文对应的数据结构挂载到socket的数据队列，等待读取。 </p> <p>了解了TCP通信的大致过程后，我们看一下Node.js中是如何封装底层的能力的。</p> <h2 id=171-tcp>17.1 TCP客户端<a class=headerlink href=#171-tcp title="Permanent link">&para;</a></h2> <h3 id=1711>17.1.1 建立连接<a class=headerlink href=#1711 title="Permanent link">&para;</a></h3> <p>net.connect是Node.js中发起TCP连接的API。本质上是对底层TCP connect函数的封装。connect返回一个表示客户端的Socket对象。我们看一下Node.js中的具体实现。我们首先看一下connect函数的入口定义。</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=kd>function</span><span class=w> </span><span class=nx>connect</span><span class=p>(...</span><span class=nx>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 处理参数  </span>
<span class=w>      </span><span class=kd>var</span><span class=w> </span><span class=nx>normalized</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>normalizeArgs</span><span class=p>(</span><span class=nx>args</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=kd>var</span><span class=w> </span><span class=nx>options</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>normalized</span><span class=p>[</span><span class=mf>0</span><span class=p>];</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 申请一个socket表示一个客户端  </span>
<span class=w>      </span><span class=kd>var</span><span class=w> </span><span class=nx>socket</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=ow>new</span><span class=w> </span><span class=nx>Socket</span><span class=p>(</span><span class=nx>options</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 设置超时，超时后会触发timeout，用户可以自定义处理超时逻辑</span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>options</span><span class=p>.</span><span class=nx>timeout</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=nx>socket</span><span class=p>.</span><span class=nx>setTimeout</span><span class=p>(</span><span class=nx>options</span><span class=p>.</span><span class=nx>timeout</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 调用socket的connect  </span>
<span class=w>      </span><span class=k>return</span><span class=w> </span><span class=nx>Socket</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>connect</span><span class=p>.</span><span class=nx>call</span><span class=p>(</span><span class=nx>socket</span><span class=p>,</span><span class=w> </span><span class=nx>normalized</span><span class=p>);</span><span class=w>  </span>
<span class=w>    </span><span class=p>}</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>从代码中可以看到，connect函数是对Socket对象的封装。Socket表示一个TCP客户端。我们分成三部分分析。</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span></pre></div></td><td class=code><div><pre><span></span><code><span class=mf>1</span><span class=w> </span><span class=ow>new</span><span class=w> </span><span class=nx>Socket</span><span class=w> </span>
<span class=mf>2</span><span class=w> </span><span class=nx>setTimeout</span><span class=w> </span>
<span class=mf>3</span><span class=w> </span><span class=nx>Socket的connect</span>
</code></pre></div></td></tr></table></div> <p>1 new Socket<br> 我们看看新建一个Socket对象，做了什么事情。 </p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=kd>function</span><span class=w> </span><span class=nx>Socket</span><span class=p>(</span><span class=nx>options</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 是否正在建立连接，即三次握手中  </span>
<span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=nx>connecting</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 触发close事件时，该字段标记是否由于错误导致了close  </span>
<span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=nx>_hadError</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 对应的底层handle，比如tcp_wrap  </span>
<span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=nx>_handle</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 定时器id  </span>
<span class=w>      </span><span class=k>this</span><span class=p>[</span><span class=nx>kTimeout</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=nx>options</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>options</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=p>{};</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// socket是双向流  </span>
<span class=w>      </span><span class=nx>stream</span><span class=p>.</span><span class=nx>Duplex</span><span class=p>.</span><span class=nx>call</span><span class=p>(</span><span class=k>this</span><span class=p>,</span><span class=w> </span><span class=nx>options</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 还不能读写，先设置成false，连接成功后再重新设置    </span>
<span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=nx>readable</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=nx>writable</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// 注册写端关闭的回调</span>
<span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=nx>on</span><span class=p>(</span><span class=s1>&#39;finish&#39;</span><span class=p>,</span><span class=w> </span><span class=nx>onSocketFinish</span><span class=p>);</span><span class=w> </span>
<span class=w>        </span><span class=c1>// 注册读端关闭的回调 </span>
<span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=nx>on</span><span class=p>(</span><span class=s1>&#39;_socketEnd&#39;</span><span class=p>,</span><span class=w> </span><span class=nx>onSocketEnd</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 是否允许半开关，默认不允许  </span>
<span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=nx>allowHalfOpen</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>options</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nx>options</span><span class=p>.</span><span class=nx>allowHalfOpen</span><span class=o>||</span><span class=kc>false</span><span class=p>;</span><span class=w> </span>
<span class=w>    </span><span class=p>}</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>Socket是对C++模块tcp_wrap的封装。主要是初始化了一些属性和监听一些事件。 2 setTimeout </p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=nx>Socket</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>setTimeout</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kd>function</span><span class=p>(</span><span class=nx>msecs</span><span class=p>,</span><span class=w> </span><span class=nx>callback</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 清除之前的，如果有的话  </span>
<span class=w>      </span><span class=nx>clearTimeout</span><span class=p>(</span><span class=k>this</span><span class=p>[</span><span class=nx>kTimeout</span><span class=p>]);</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 0代表清除  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>msecs</span><span class=w> </span><span class=o>===</span><span class=w> </span><span class=mf>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>callback</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>          </span><span class=k>this</span><span class=p>.</span><span class=nx>removeListener</span><span class=p>(</span><span class=s1>&#39;timeout&#39;</span><span class=p>,</span><span class=w> </span><span class=nx>callback</span><span class=p>);</span><span class=w>  </span>
<span class=w>        </span><span class=p>}</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// 开启一个定时器，超时时间是msecs，超时回调是_onTimeout  </span>
<span class=w>        </span><span class=k>this</span><span class=p>[</span><span class=nx>kTimeout</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>setUnrefTimeout</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>_onTimeout</span><span class=p>.</span><span class=nx>bind</span><span class=p>(</span><span class=k>this</span><span class=p>),</span><span class=w> </span><span class=nx>msecs</span><span class=p>);</span><span class=w>  </span>
<span class=w>        </span><span class=cm>/*</span>
<span class=cm>              监听timeout事件，定时器超时时，底层会调用Node.js的回调，</span>
<span class=cm>              Node.js会调用用户的回调callback  </span>
<span class=cm>            */</span>
<span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>callback</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>          </span><span class=k>this</span><span class=p>.</span><span class=nx>once</span><span class=p>(</span><span class=s1>&#39;timeout&#39;</span><span class=p>,</span><span class=w> </span><span class=nx>callback</span><span class=p>);</span><span class=w>  </span>
<span class=w>        </span><span class=p>}</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>      </span><span class=k>return</span><span class=w> </span><span class=k>this</span><span class=p>;</span><span class=w>  </span>
<span class=w>    </span><span class=p>};</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>setTimeout做的事情就是设置一个超时时间，这个时间用于检测socket的活跃情况（比如有数据通信），当socket活跃时，Node.js会重置该定时器，如果socket一直不活跃则超时会触发timeout事件，从而执行Node.js的_onTimeout回调，在回调里再触发用户传入的回调。我们看一下超时处理函数_onTimeout。 </p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=nx>Socket</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>_onTimeout</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kd>function</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=nx>emit</span><span class=p>(</span><span class=s1>&#39;timeout&#39;</span><span class=p>);</span><span class=w>  </span>
<span class=w>    </span><span class=p>};</span>
</code></pre></div></td></tr></table></div> <p>直接触发timeout函数，回调用户的函数。我们看到setTimeout只是设置了一个定时器，然后触发timeout事件，Node.js并没有帮我们做额外的操作，所以我们需要自己处理，比如关闭socket。</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=nx>socket</span><span class=p>.</span><span class=nx>setTimeout</span><span class=p>(</span><span class=mf>10000</span><span class=p>);</span><span class=w>  </span>
<span class=w>    </span><span class=nx>socket</span><span class=p>.</span><span class=nx>on</span><span class=p>(</span><span class=s1>&#39;timeout&#39;</span><span class=p>,</span><span class=w> </span><span class=p>()</span><span class=w> </span><span class=p>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=nx>socket</span><span class=p>.</span><span class=nx>close</span><span class=p>();</span><span class=w>  </span>
<span class=w>    </span><span class=p>});</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>另外我们看到这里是使用setUnrefTimeout设置的定时器，因为这一类定时器不应该阻止事件循环的退出。 3 connect函数 在第一步我们已经创建了一个socket，接着我们调用该socket的connect函数开始发起连接。 </p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=c1>// 建立连接，即三次握手  </span>
<span class=w>    </span><span class=nx>Socket</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>connect</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kd>function</span><span class=p>(...</span><span class=nx>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=kd>let</span><span class=w> </span><span class=nx>normalized</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=cm>/* 忽略参数处理 */</span><span class=w>  </span>
<span class=w>      </span><span class=kd>var</span><span class=w> </span><span class=nx>options</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>normalized</span><span class=p>[</span><span class=mf>0</span><span class=p>];</span><span class=w>  </span>
<span class=w>      </span><span class=kd>var</span><span class=w> </span><span class=nx>cb</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>normalized</span><span class=p>[</span><span class=mf>1</span><span class=p>];</span><span class=w> </span>
<span class=w>        </span><span class=c1>// TCP在tcp_wrap.cc中定义   </span>
<span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=nx>_handle</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=ow>new</span><span class=w> </span><span class=nx>TCP</span><span class=p>(</span><span class=nx>TCPConstants</span><span class=p>.</span><span class=nx>SOCKET</span><span class=p>);</span><span class=w> </span>
<span class=w>        </span><span class=c1>// 有数据可读时的回调 </span>
<span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=nx>_handle</span><span class=p>.</span><span class=nx>onread</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>onread</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 连接成功时执行的回调  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>cb</span><span class=w> </span><span class=o>!==</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=nx>once</span><span class=p>(</span><span class=s1>&#39;connect&#39;</span><span class=p>,</span><span class=w> </span><span class=nx>cb</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 正在连接  </span>
<span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=nx>connecting</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=nx>writable</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// 重置定时器</span>
<span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=nx>_unrefTimer</span><span class=p>();</span>
<span class=w>      </span><span class=c1>// 可能需要DNS解析，解析成功再发起连接  </span>
<span class=w>      </span><span class=nx>lookupAndConnect</span><span class=p>(</span><span class=k>this</span><span class=p>,</span><span class=w> </span><span class=nx>options</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=k>return</span><span class=w> </span><span class=k>this</span><span class=p>;</span><span class=w>  </span>
<span class=w>    </span><span class=p>};</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>connect 函数主要是三个逻辑<br> 1 首先通过new TCP()创建一个底层的handle，比如我们这里是TCP（对应tcp_wrap.cc的实现）。 <br> 2 设置一些回调 <br> 3 做DNS解析（如果需要的话），然后发起三次握手。<br> 我们看一下new TCP意味着什么，我们看tcp_wrap.cc的实现<br> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span>
<span class=normal>24</span>
<span class=normal>25</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>TCPWrap::New</span><span class=p>(</span><span class=k>const</span><span class=w> </span><span class=n>FunctionCallbackInfo</span><span class=o>&lt;</span><span class=n>Value</span><span class=o>&gt;&amp;</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 要以new TCP的形式调用  </span>
<span class=w>      </span><span class=n>CHECK</span><span class=p>(</span><span class=n>args</span><span class=p>.</span><span class=n>IsConstructCall</span><span class=p>());</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 第一个入参是数字  </span>
<span class=w>      </span><span class=n>CHECK</span><span class=p>(</span><span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>IsInt32</span><span class=p>());</span><span class=w>  </span>
<span class=w>      </span><span class=n>Environment</span><span class=o>*</span><span class=w> </span><span class=n>env</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Environment</span><span class=o>::</span><span class=n>GetCurrent</span><span class=p>(</span><span class=n>args</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 作为客户端还是服务器  </span>
<span class=w>      </span><span class=kt>int</span><span class=w> </span><span class=n>type_value</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>As</span><span class=o>&lt;</span><span class=n>Int32</span><span class=o>&gt;</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>Value</span><span class=p>();</span><span class=w>  </span>
<span class=w>      </span><span class=n>TCPWrap</span><span class=o>::</span><span class=n>SocketType</span><span class=w> </span><span class=n>type</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>static_cast</span><span class=o>&lt;</span><span class=n>TCPWrap</span><span class=o>::</span><span class=n>SocketType</span><span class=o>&gt;</span><span class=p>(</span><span class=n>type_value</span><span class=p>);</span><span class=w>  </span>

<span class=w>      </span><span class=n>ProviderType</span><span class=w> </span><span class=n>provider</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=k>switch</span><span class=w> </span><span class=p>(</span><span class=n>type</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// 作为客户端，即发起连接方  </span>
<span class=w>        </span><span class=k>case</span><span class=w> </span><span class=no>SOCKET</span><span class=p>:</span><span class=w>  </span>
<span class=w>          </span><span class=n>provider</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>PROVIDER_TCPWRAP</span><span class=p>;</span><span class=w>  </span>
<span class=w>          </span><span class=k>break</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// 作为服务器  </span>
<span class=w>        </span><span class=k>case</span><span class=w> </span><span class=no>SERVER</span><span class=p>:</span><span class=w>  </span>
<span class=w>          </span><span class=n>provider</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>PROVIDER_TCPSERVERWRAP</span><span class=p>;</span><span class=w>  </span>
<span class=w>          </span><span class=k>break</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=k>default</span><span class=o>:</span><span class=w>  </span>
<span class=w>          </span><span class=n>UNREACHABLE</span><span class=p>();</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>      </span><span class=k>new</span><span class=w> </span><span class=n>TCPWrap</span><span class=p>(</span><span class=n>env</span><span class=p>,</span><span class=w> </span><span class=n>args</span><span class=p>.</span><span class=n>This</span><span class=p>(),</span><span class=w> </span><span class=n>provider</span><span class=p>);</span><span class=w>  </span>
<span class=w>    </span><span class=p>}</span><span class=w>  </span>
</code></pre></div></td></tr></table></div></p> <p>new TCP对应到C++层，就是创建一个TCPWrap对象。并初始化对象中的handle_字段</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=n>TCPWrap</span><span class=o>::</span><span class=n>TCPWrap</span><span class=p>(</span><span class=n>Environment</span><span class=o>*</span><span class=w> </span><span class=n>env</span><span class=p>,</span><span class=w> </span>
<span class=w>                     </span><span class=n>Local</span><span class=o>&lt;</span><span class=n>Object</span><span class=o>&gt;</span><span class=w> </span><span class=n>object</span><span class=p>,</span><span class=w> </span>
<span class=w>                     </span><span class=n>ProviderType</span><span class=w> </span><span class=n>provider</span><span class=p>)</span><span class=w>  </span>
<span class=w>        </span><span class=o>:</span><span class=w> </span><span class=n>ConnectionWrap</span><span class=p>(</span><span class=n>env</span><span class=p>,</span><span class=w> </span><span class=n>object</span><span class=p>,</span><span class=w> </span><span class=n>provider</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=kt>int</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>uv_tcp_init</span><span class=p>(</span><span class=n>env</span><span class=o>-&gt;</span><span class=n>event_loop</span><span class=p>(),</span><span class=w> </span><span class=o>&amp;</span><span class=n>handle_</span><span class=p>);</span><span class=w>  </span>
<span class=w>    </span><span class=p>}</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>初始化完底层的数据结构后，我们继续看lookupAndConnect，lookupAndConnect主要是对参数进行校验，然后进行DNS解析（如果传的是域名的话），DNS解析成功后执行internalConnect</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span>
<span class=normal>24</span>
<span class=normal>25</span>
<span class=normal>26</span>
<span class=normal>27</span>
<span class=normal>28</span>
<span class=normal>29</span>
<span class=normal>30</span>
<span class=normal>31</span>
<span class=normal>32</span>
<span class=normal>33</span>
<span class=normal>34</span>
<span class=normal>35</span>
<span class=normal>36</span>
<span class=normal>37</span>
<span class=normal>38</span>
<span class=normal>39</span>
<span class=normal>40</span>
<span class=normal>41</span>
<span class=normal>42</span>
<span class=normal>43</span>
<span class=normal>44</span>
<span class=normal>45</span>
<span class=normal>46</span>
<span class=normal>47</span>
<span class=normal>48</span>
<span class=normal>49</span>
<span class=normal>50</span>
<span class=normal>51</span>
<span class=normal>52</span>
<span class=normal>53</span>
<span class=normal>54</span>
<span class=normal>55</span>
<span class=normal>56</span>
<span class=normal>57</span>
<span class=normal>58</span>
<span class=normal>59</span>
<span class=normal>60</span>
<span class=normal>61</span>
<span class=normal>62</span>
<span class=normal>63</span>
<span class=normal>64</span>
<span class=normal>65</span>
<span class=normal>66</span>
<span class=normal>67</span>
<span class=normal>68</span>
<span class=normal>69</span>
<span class=normal>70</span>
<span class=normal>71</span>
<span class=normal>72</span>
<span class=normal>73</span>
<span class=normal>74</span>
<span class=normal>75</span>
<span class=normal>76</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=kd>function</span><span class=w> </span><span class=nx>internalConnect</span><span class=p>(</span><span class=w>  </span>
<span class=w>      </span><span class=nx>self</span><span class=p>,</span><span class=w>   </span>
<span class=w>      </span><span class=c1>// 需要连接的远端IP、端口  </span>
<span class=w>      </span><span class=nx>address</span><span class=p>,</span><span class=w>   </span>
<span class=w>      </span><span class=nx>port</span><span class=p>,</span><span class=w>   </span>
<span class=w>      </span><span class=nx>addressType</span><span class=p>,</span><span class=w>   </span>
<span class=w>      </span><span class=cm>/*</span>
<span class=cm>          用于和对端连接的本地IP、端口（如果不设置，</span>
<span class=cm>          则操作系统自己决定）  </span>
<span class=cm>        */</span>
<span class=w>      </span><span class=nx>localAddress</span><span class=p>,</span><span class=w>   </span>
<span class=w>      </span><span class=nx>localPort</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=kd>var</span><span class=w> </span><span class=nx>err</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=cm>/*</span>
<span class=cm>          如果传了本地的地址或端口，则TCP连接中的源IP</span>
<span class=cm>          和端口就是传的，否则由操作系统自己选</span>
<span class=cm>        */</span><span class=w>  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>localAddress</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=nx>localPort</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>          </span><span class=c1>// IP v4  </span>
<span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>addressType</span><span class=w> </span><span class=o>===</span><span class=w> </span><span class=mf>4</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>          </span><span class=nx>localAddress</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>localAddress</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=s1>&#39;0.0.0.0&#39;</span><span class=p>;</span><span class=w>  </span>
<span class=w>          </span><span class=c1>// 绑定地址和端口到handle</span>
<span class=w>          </span><span class=nx>err</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>self</span><span class=p>.</span><span class=nx>_handle</span><span class=p>.</span><span class=nx>bind</span><span class=p>(</span><span class=nx>localAddress</span><span class=p>,</span><span class=w> </span><span class=nx>localPort</span><span class=p>);</span><span class=w>  </span>
<span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>addressType</span><span class=w> </span><span class=o>===</span><span class=w> </span><span class=mf>6</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>          </span><span class=nx>localAddress</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>localAddress</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=s1>&#39;::&#39;</span><span class=p>;</span><span class=w>  </span>
<span class=w>          </span><span class=nx>err</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>self</span><span class=p>.</span><span class=nx>_handle</span><span class=p>.</span><span class=nx>bind6</span><span class=p>(</span><span class=nx>localAddress</span><span class=p>,</span><span class=w> </span><span class=nx>localPort</span><span class=p>);</span><span class=w>  </span>
<span class=w>        </span><span class=p>}</span><span class=w>  </span>

<span class=w>        </span><span class=c1>// 绑定是否成功  </span>
<span class=w>        </span><span class=nx>err</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>checkBindError</span><span class=p>(</span><span class=nx>err</span><span class=p>,</span><span class=w> </span><span class=nx>localPort</span><span class=p>,</span><span class=w> </span><span class=nx>self</span><span class=p>.</span><span class=nx>_handle</span><span class=p>);</span><span class=w>  </span>
<span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>err</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>          </span><span class=kd>const</span><span class=w> </span><span class=nx>ex</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>exceptionWithHostPort</span><span class=p>(</span><span class=nx>err</span><span class=p>,</span>
<span class=w>                                                    </span><span class=s1>&#39;bind&#39;</span><span class=p>,</span><span class=w> </span>
<span class=w>                                                    </span><span class=nx>localAddress</span><span class=p>,</span><span class=w> </span>
<span class=w>                                                    </span><span class=nx>localPort</span><span class=p>);</span><span class=w>  </span>
<span class=w>          </span><span class=nx>self</span><span class=p>.</span><span class=nx>destroy</span><span class=p>(</span><span class=nx>ex</span><span class=p>);</span><span class=w>  </span>
<span class=w>          </span><span class=k>return</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=p>}</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// 对端的地址信息</span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>addressType</span><span class=w> </span><span class=o>===</span><span class=w> </span><span class=mf>6</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=nx>addressType</span><span class=w> </span><span class=o>===</span><span class=w> </span><span class=mf>4</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// 新建一个请求对象，C++层定义  </span>
<span class=w>        </span><span class=kd>const</span><span class=w> </span><span class=nx>req</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=ow>new</span><span class=w> </span><span class=nx>TCPConnectWrap</span><span class=p>();</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// 设置一些列属性  </span>
<span class=w>        </span><span class=nx>req</span><span class=p>.</span><span class=nx>oncomplete</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>afterConnect</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=nx>req</span><span class=p>.</span><span class=nx>address</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>address</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=nx>req</span><span class=p>.</span><span class=nx>port</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>port</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=nx>req</span><span class=p>.</span><span class=nx>localAddress</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>localAddress</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=nx>req</span><span class=p>.</span><span class=nx>localPort</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>localPort</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// 调用底层对应的函数  </span>
<span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>addressType</span><span class=w> </span><span class=o>===</span><span class=w> </span><span class=mf>4</span><span class=p>)</span><span class=w>  </span>
<span class=w>          </span><span class=nx>err</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>self</span><span class=p>.</span><span class=nx>_handle</span><span class=p>.</span><span class=nx>connect</span><span class=p>(</span><span class=nx>req</span><span class=p>,</span><span class=w> </span><span class=nx>address</span><span class=p>,</span><span class=w> </span><span class=nx>port</span><span class=p>);</span><span class=w>  </span>
<span class=w>        </span><span class=k>else</span><span class=w>  </span>
<span class=w>          </span><span class=nx>err</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>self</span><span class=p>.</span><span class=nx>_handle</span><span class=p>.</span><span class=nx>connect6</span><span class=p>(</span><span class=nx>req</span><span class=p>,</span><span class=w> </span><span class=nx>address</span><span class=p>,</span><span class=w> </span><span class=nx>port</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>      </span><span class=cm>/*</span>
<span class=cm>         非阻塞调用，可能在还没发起三次握手之前就报错了，</span>
<span class=cm>          而不是三次握手出错，这里进行出错处理  </span>
<span class=cm>        */</span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>err</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// 获取socket对应的底层IP端口信息  </span>
<span class=w>        </span><span class=kd>var</span><span class=w> </span><span class=nx>sockname</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>self</span><span class=p>.</span><span class=nx>_getsockname</span><span class=p>();</span><span class=w>  </span>
<span class=w>        </span><span class=kd>var</span><span class=w> </span><span class=nx>details</span><span class=p>;</span><span class=w>  </span>

<span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>sockname</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>          </span><span class=nx>details</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>sockname</span><span class=p>.</span><span class=nx>address</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s1>&#39;:&#39;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nx>sockname</span><span class=p>.</span><span class=nx>port</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=p>}</span><span class=w>  </span>
<span class=w>          </span><span class=c1>// 构造错误信息，销魂socket并触发error事件</span>
<span class=w>        </span><span class=kd>const</span><span class=w> </span><span class=nx>ex</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>exceptionWithHostPort</span><span class=p>(</span><span class=nx>err</span><span class=p>,</span><span class=w> </span>
<span class=w>                                                </span><span class=s1>&#39;connect&#39;</span><span class=p>,</span><span class=w> </span>
<span class=w>                                                </span><span class=nx>address</span><span class=p>,</span><span class=w> </span>
<span class=w>                                                </span><span class=nx>port</span><span class=p>,</span><span class=w> </span>
<span class=w>                                                </span><span class=nx>details</span><span class=p>);</span><span class=w>  </span>
<span class=w>        </span><span class=nx>self</span><span class=p>.</span><span class=nx>destroy</span><span class=p>(</span><span class=nx>ex</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>    </span><span class=p>}</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>这里的代码比较多，除了错误处理外，主要的逻辑是bind和connect。bind函数的逻辑很简单（即使是底层的bind），它就是在底层的一个结构体上设置了两个字段的值。所以我们主要来分析connect。我们把关于connect的这段逻辑拎出来。 </p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span>
<span class=normal>7</span>
<span class=normal>8</span>
<span class=normal>9</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>        </span><span class=kd>const</span><span class=w> </span><span class=nx>req</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=ow>new</span><span class=w> </span><span class=nx>TCPConnectWrap</span><span class=p>();</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// 设置一些列属性  </span>
<span class=w>        </span><span class=nx>req</span><span class=p>.</span><span class=nx>oncomplete</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>afterConnect</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=nx>req</span><span class=p>.</span><span class=nx>address</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>address</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=nx>req</span><span class=p>.</span><span class=nx>port</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>port</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=nx>req</span><span class=p>.</span><span class=nx>localAddress</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>localAddress</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=nx>req</span><span class=p>.</span><span class=nx>localPort</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>localPort</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// 调用底层对应的函数  </span>
<span class=w>        </span><span class=nx>self</span><span class=p>.</span><span class=nx>_handle</span><span class=p>.</span><span class=nx>connect</span><span class=p>(</span><span class=nx>req</span><span class=p>,</span><span class=w> </span><span class=nx>address</span><span class=p>,</span><span class=w> </span><span class=nx>port</span><span class=p>);</span><span class=w> </span>
</code></pre></div></td></tr></table></div> <p>TCPConnectWrap是C++层提供的类，connect对应C++层的Conenct， 前面的章节我们已经分析过，不再具体分析。连接完成后，回调函数是uv__stream_io。在uv__stream_io里会调用connect_req中的回调。假设连接建立，这时候就会执行C++层的AfterConnect。AfterConnect会执行JS层的afterConnect。 </p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span>
<span class=normal>24</span>
<span class=normal>25</span>
<span class=normal>26</span>
<span class=normal>27</span>
<span class=normal>28</span>
<span class=normal>29</span>
<span class=normal>30</span>
<span class=normal>31</span>
<span class=normal>32</span>
<span class=normal>33</span>
<span class=normal>34</span>
<span class=normal>35</span>
<span class=normal>36</span>
<span class=normal>37</span>
<span class=normal>38</span>
<span class=normal>39</span>
<span class=normal>40</span>
<span class=normal>41</span>
<span class=normal>42</span>
<span class=normal>43</span>
<span class=normal>44</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=c1>// 连接后执行的回调，成功或失败  </span>
<span class=w>    </span><span class=kd>function</span><span class=w> </span><span class=nx>afterConnect</span><span class=p>(</span><span class=nx>status</span><span class=p>,</span><span class=w> </span><span class=nx>handle</span><span class=p>,</span><span class=w> </span><span class=nx>req</span><span class=p>,</span><span class=w> </span><span class=nx>readable</span><span class=p>,</span><span class=w> </span><span class=nx>writable</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>   </span><span class=c1>// handle关联的socket  </span>
<span class=w>      </span><span class=kd>var</span><span class=w> </span><span class=nx>self</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>handle</span><span class=p>.</span><span class=nx>owner</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 连接过程中执行了socket被销毁了，则不需要继续处理  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>self</span><span class=p>.</span><span class=nx>destroyed</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=k>return</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>

<span class=w>      </span><span class=nx>handle</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>self</span><span class=p>.</span><span class=nx>_handle</span><span class=p>;</span>
<span class=w>     </span><span class=nx>self</span><span class=p>.</span><span class=nx>connecting</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>  </span>
<span class=w>     </span><span class=nx>self</span><span class=p>.</span><span class=nx>_sockname</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>  </span>
<span class=w>     </span><span class=c1>// 连接成功  </span>
<span class=w>     </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>status</span><span class=w> </span><span class=o>===</span><span class=w> </span><span class=mf>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// 设置读写属性  </span>
<span class=w>        </span><span class=nx>self</span><span class=p>.</span><span class=nx>readable</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>readable</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=nx>self</span><span class=p>.</span><span class=nx>writable</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>writable</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// socket当前活跃，重置定时器  </span>
<span class=w>        </span><span class=nx>self</span><span class=p>.</span><span class=nx>_unrefTimer</span><span class=p>();</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// 触发连接成功事件  </span>
<span class=w>        </span><span class=nx>self</span><span class=p>.</span><span class=nx>emit</span><span class=p>(</span><span class=s1>&#39;connect&#39;</span><span class=p>);</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// socket可读并且没有设置暂停模式，则开启读  </span>
<span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>readable</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=o>!</span><span class=nx>self</span><span class=p>.</span><span class=nx>isPaused</span><span class=p>())</span><span class=w>  </span>
<span class=w>          </span><span class=nx>self</span><span class=p>.</span><span class=nx>read</span><span class=p>(</span><span class=mf>0</span><span class=p>);</span><span class=w>  </span>
<span class=w>     </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// 连接失败，报错并销毁socket  </span>
<span class=w>        </span><span class=nx>self</span><span class=p>.</span><span class=nx>connecting</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=kd>var</span><span class=w> </span><span class=nx>details</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// 提示出错信息  </span>
<span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>req</span><span class=p>.</span><span class=nx>localAddress</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nx>req</span><span class=p>.</span><span class=nx>localPort</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>          </span><span class=nx>details</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>req</span><span class=p>.</span><span class=nx>localAddress</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=s1>&#39;:&#39;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nx>req</span><span class=p>.</span><span class=nx>localPort</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=p>}</span><span class=w>  </span>
<span class=w>        </span><span class=kd>var</span><span class=w> </span><span class=nx>ex</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>exceptionWithHostPort</span><span class=p>(</span><span class=nx>status</span><span class=p>,</span><span class=w>  </span>
<span class=w>                                       </span><span class=s1>&#39;connect&#39;</span><span class=p>,</span><span class=w>  </span>
<span class=w>                                       </span><span class=nx>req</span><span class=p>.</span><span class=nx>address</span><span class=p>,</span><span class=w>  </span>
<span class=w>                                       </span><span class=nx>req</span><span class=p>.</span><span class=nx>port</span><span class=p>,</span><span class=w>  </span>
<span class=w>                                       </span><span class=nx>details</span><span class=p>);</span><span class=w>  </span>
<span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>details</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>          </span><span class=nx>ex</span><span class=p>.</span><span class=nx>localAddress</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>req</span><span class=p>.</span><span class=nx>localAddress</span><span class=p>;</span><span class=w>  </span>
<span class=w>          </span><span class=nx>ex</span><span class=p>.</span><span class=nx>localPort</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>req</span><span class=p>.</span><span class=nx>localPort</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=p>}</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// 销毁socket  </span>
<span class=w>        </span><span class=nx>self</span><span class=p>.</span><span class=nx>destroy</span><span class=p>(</span><span class=nx>ex</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>    </span><span class=p>}</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>一般情况下，连接成功后，JS层调用self.read(0)注册等待可读事件。</p> <h3 id=1712>17.1.2 读操作<a class=headerlink href=#1712 title="Permanent link">&para;</a></h3> <p>我们看一下socket的读操作逻辑，在连接成功后，socket会通过read函数在底层注册等待可读事件，等待底层事件驱动模块通知有数据可读。</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span>
<span class=normal>7</span>
<span class=normal>8</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=nx>Socket</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>read</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kd>function</span><span class=p>(</span><span class=nx>n</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>n</span><span class=w> </span><span class=o>===</span><span class=w> </span><span class=mf>0</span><span class=p>)</span><span class=w>  </span>
<span class=w>        </span><span class=k>return</span><span class=w> </span><span class=nx>stream</span><span class=p>.</span><span class=nx>Readable</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>read</span><span class=p>.</span><span class=nx>call</span><span class=p>(</span><span class=k>this</span><span class=p>,</span><span class=w> </span><span class=nx>n</span><span class=p>);</span><span class=w>  </span>

<span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=nx>read</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>stream</span><span class=p>.</span><span class=nx>Readable</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>read</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=nx>_consuming</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=k>return</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=nx>read</span><span class=p>(</span><span class=nx>n</span><span class=p>);</span><span class=w>  </span>
<span class=w>    </span><span class=p>};</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>这里会执行Readable模块的read函数，从而执行_read函数，_read函数是由子类实现。所以我们看Socket的_read</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=nx>Socket</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>_read</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kd>function</span><span class=p>(</span><span class=nx>n</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 还没建立连接，则建立后再执行  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>connecting</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=o>!</span><span class=k>this</span><span class=p>.</span><span class=nx>_handle</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=nx>once</span><span class=p>(</span><span class=s1>&#39;connect&#39;</span><span class=p>,</span><span class=w> </span><span class=p>()</span><span class=w> </span><span class=p>=&gt;</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=nx>_read</span><span class=p>(</span><span class=nx>n</span><span class=p>));</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=k>this</span><span class=p>.</span><span class=nx>_handle</span><span class=p>.</span><span class=nx>reading</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=nx>_handle</span><span class=p>.</span><span class=nx>reading</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// 执行底层的readStart注册等待可读事件  </span>
<span class=w>        </span><span class=kd>var</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=nx>_handle</span><span class=p>.</span><span class=nx>readStart</span><span class=p>();</span><span class=w>  </span>
<span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>err</span><span class=p>)</span><span class=w>  </span>
<span class=w>          </span><span class=k>this</span><span class=p>.</span><span class=nx>destroy</span><span class=p>(</span><span class=nx>errnoException</span><span class=p>(</span><span class=nx>err</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;read&#39;</span><span class=p>));</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>    </span><span class=p>};</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>但是我们发现tcp_wrap.cc没有readStart函数。一路往父类找，最终在stream_wrap.cc找到了该函数。</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=c1>// 注册读事件  </span>
<span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=nf>LibuvStreamWrap::ReadStart</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=k>return</span><span class=w> </span><span class=n>uv_read_start</span><span class=p>(</span><span class=n>stream</span><span class=p>(),</span><span class=w> </span>
<span class=w>       </span><span class=p>[](</span><span class=n>uv_handle_t</span><span class=o>*</span><span class=w> </span><span class=n>handle</span><span class=p>,</span><span class=w>  </span>
<span class=w>       </span><span class=kt>size_t</span><span class=w> </span><span class=n>suggested_size</span><span class=p>,</span><span class=w>  </span>
<span class=w>       </span><span class=n>uv_buf_t</span><span class=o>*</span><span class=w> </span><span class=n>buf</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 分配存储数据的内存  </span>
<span class=w>      </span><span class=k>static_cast</span><span class=o>&lt;</span><span class=n>LibuvStreamWrap</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>handle</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>OnUvAlloc</span><span class=p>(</span><span class=n>suggested_size</span><span class=p>,</span><span class=w> </span><span class=n>buf</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=p>},</span>
<span class=w>      </span><span class=p>[](</span><span class=n>uv_stream_t</span><span class=o>*</span><span class=w> </span><span class=n>stream</span><span class=p>,</span><span class=kt>ssize_t</span><span class=w> </span><span class=n>nread</span><span class=p>,</span><span class=k>const</span><span class=w> </span><span class=n>uv_buf_t</span><span class=o>*</span><span class=w> </span><span class=n>buf</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>       </span><span class=c1>// 读取数据成功的回调  </span>
<span class=w>       </span><span class=k>static_cast</span><span class=o>&lt;</span><span class=n>LibuvStreamWrap</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>stream</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>OnUvRead</span><span class=p>(</span><span class=n>nread</span><span class=p>,</span><span class=w> </span><span class=n>buf</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=p>});</span><span class=w>  </span>
<span class=w>    </span><span class=p>}</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>uv_read_start函数在流章节已经分析过，作用就是注册等待可读事件，这里就不再深入。OnUvAlloc是分配存储数据的函数，我们可以不关注，我们看一下OnUvRead，当可读事件触发时会执行OnUvRead</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>LibuvStreamWrap::OnUvRead</span><span class=p>(</span><span class=kt>ssize_t</span><span class=w> </span><span class=n>nread</span><span class=p>,</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=n>uv_buf_t</span><span class=o>*</span><span class=w> </span><span class=n>buf</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=n>HandleScope</span><span class=w> </span><span class=n>scope</span><span class=p>(</span><span class=n>env</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>isolate</span><span class=p>());</span><span class=w>  </span>
<span class=w>      </span><span class=n>Context</span><span class=o>::</span><span class=n>Scope</span><span class=w> </span><span class=n>context_scope</span><span class=p>(</span><span class=n>env</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>context</span><span class=p>());</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 触发onread事件  </span>
<span class=w>      </span><span class=n>EmitRead</span><span class=p>(</span><span class=n>nread</span><span class=p>,</span><span class=w> </span><span class=o>*</span><span class=n>buf</span><span class=p>);</span><span class=w>  </span>
<span class=w>    </span><span class=p>}</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>OnUvRead函数触发onread回调。</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span>
<span class=normal>24</span>
<span class=normal>25</span>
<span class=normal>26</span>
<span class=normal>27</span>
<span class=normal>28</span>
<span class=normal>29</span>
<span class=normal>30</span>
<span class=normal>31</span>
<span class=normal>32</span>
<span class=normal>33</span>
<span class=normal>34</span>
<span class=normal>35</span>
<span class=normal>36</span>
<span class=normal>37</span>
<span class=normal>38</span>
<span class=normal>39</span>
<span class=normal>40</span>
<span class=normal>41</span>
<span class=normal>42</span>
<span class=normal>43</span>
<span class=normal>44</span>
<span class=normal>45</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=kd>function</span><span class=w> </span><span class=nx>onread</span><span class=p>(</span><span class=nx>nread</span><span class=p>,</span><span class=w> </span><span class=nx>buffer</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=kd>var</span><span class=w> </span><span class=nx>handle</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>this</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// handle关联的socket</span>
<span class=w>      </span><span class=kd>var</span><span class=w> </span><span class=nx>self</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>handle</span><span class=p>.</span><span class=nx>owner</span><span class=p>;</span><span class=w> </span>
<span class=w>        </span><span class=c1>// socket有数据到来，处于活跃状态，重置定时器 </span>
<span class=w>        </span><span class=nx>self</span><span class=p>.</span><span class=nx>_unrefTimer</span><span class=p>();</span><span class=w> </span>
<span class=w>      </span><span class=c1>// 成功读取数据  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>nread</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mf>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// push到流中  </span>
<span class=w>        </span><span class=kd>var</span><span class=w> </span><span class=nx>ret</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>self</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=nx>buffer</span><span class=p>);</span><span class=w>  </span>
<span class=w>        </span><span class=cm>/*</span>
<span class=cm>              push返回false，说明缓存的数据已经达到阈值，</span>
<span class=cm>              不能再触发读，需要注销等待可读事件  </span>
<span class=cm>            */</span>
<span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>handle</span><span class=p>.</span><span class=nx>reading</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=o>!</span><span class=nx>ret</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>          </span><span class=nx>handle</span><span class=p>.</span><span class=nx>reading</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>  </span>
<span class=w>          </span><span class=kd>var</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>handle</span><span class=p>.</span><span class=nx>readStop</span><span class=p>();</span><span class=w>  </span>
<span class=w>          </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>err</span><span class=p>)</span><span class=w>  </span>
<span class=w>            </span><span class=nx>self</span><span class=p>.</span><span class=nx>destroy</span><span class=p>(</span><span class=nx>errnoException</span><span class=p>(</span><span class=nx>err</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;read&#39;</span><span class=p>));</span><span class=w>  </span>
<span class=w>        </span><span class=p>}</span><span class=w>  </span>
<span class=w>        </span><span class=k>return</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>

<span class=w>      </span><span class=c1>// 没有数据，忽略 </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>nread</span><span class=w> </span><span class=o>===</span><span class=w> </span><span class=mf>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=nx>debug</span><span class=p>(</span><span class=s1>&#39;not any data, keep waiting&#39;</span><span class=p>);</span><span class=w>  </span>
<span class=w>        </span><span class=k>return</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 不等于结束，则读出错，销毁流  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>nread</span><span class=w> </span><span class=o>!==</span><span class=w> </span><span class=nx>UV_EOF</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=k>return</span><span class=w> </span><span class=nx>self</span><span class=p>.</span><span class=nx>destroy</span><span class=p>(</span><span class=nx>errnoException</span><span class=p>(</span><span class=nx>nread</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;read&#39;</span><span class=p>));</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 流结束了，没有数据读了  </span>
<span class=w>      </span><span class=nx>self</span><span class=p>.</span><span class=nx>push</span><span class=p>(</span><span class=kc>null</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=cm>/*</span>
<span class=cm>          也没有缓存的数据了，可能需要销毁流，比如是只读流，</span>
<span class=cm>          或者可读写流，写端也没有数据了，参考maybeDestroy  </span>
<span class=cm>        */</span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>self</span><span class=p>.</span><span class=nx>readableLength</span><span class=w> </span><span class=o>===</span><span class=w> </span><span class=mf>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=nx>self</span><span class=p>.</span><span class=nx>readable</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=nx>maybeDestroy</span><span class=p>(</span><span class=nx>self</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 触发事件  </span>
<span class=w>      </span><span class=nx>self</span><span class=p>.</span><span class=nx>emit</span><span class=p>(</span><span class=s1>&#39;_socketEnd&#39;</span><span class=p>);</span><span class=w>  </span>
<span class=w>    </span><span class=p>}</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>socket可读事件触发时大概有下面几种情况<br> 1 有有效数据可读，push到流中，触发ondata事件通知用户。<br> 2 没有有效数据可读，忽略。<br> 3 读出错，销毁流<br> 4 读结束。<br> 我们分析一下4。在新建一个socket的时候注册了流结束的处理函数onSocketEnd。</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span>
<span class=normal>24</span>
<span class=normal>25</span>
<span class=normal>26</span>
<span class=normal>27</span>
<span class=normal>28</span>
<span class=normal>29</span>
<span class=normal>30</span>
<span class=normal>31</span>
<span class=normal>32</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=c1>// 读结束后执行的函数  </span>
<span class=w>    </span><span class=kd>function</span><span class=w> </span><span class=nx>onSocketEnd</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 读结束标记  </span>
<span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=nx>_readableState</span><span class=p>.</span><span class=nx>ended</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=cm>/* </span>
<span class=cm>        已经触发过end事件，则判断是否需要销毁，可能还有写端 </span>
<span class=cm>      */</span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>_readableState</span><span class=p>.</span><span class=nx>endEmitted</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=nx>readable</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>  </span>
<span class=w>       </span><span class=nx>maybeDestroy</span><span class=p>(</span><span class=k>this</span><span class=p>);</span><span class=w>  </span>
<span class=w>     </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>       </span><span class=c1>// 还没有触发end则等待触发end事件再执行下一步操作  </span>
<span class=w>       </span><span class=k>this</span><span class=p>.</span><span class=nx>once</span><span class=p>(</span><span class=s1>&#39;end&#39;</span><span class=p>,</span><span class=w> </span><span class=kd>function</span><span class=w> </span><span class=nx>end</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>         </span><span class=k>this</span><span class=p>.</span><span class=nx>readable</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>  </span>
<span class=w>         </span><span class=nx>maybeDestroy</span><span class=p>(</span><span class=k>this</span><span class=p>);</span><span class=w>  </span>
<span class=w>       </span><span class=p>});</span><span class=w>  </span>
<span class=w>       </span><span class=cm>/*</span>
<span class=cm>         执行read，如果流中没有缓存的数据则会触发end事件，</span>
<span class=cm>         否则等待消费完后再触发  </span>
<span class=cm>       */</span>
<span class=w>       </span><span class=k>this</span><span class=p>.</span><span class=nx>read</span><span class=p>(</span><span class=mf>0</span><span class=p>);</span><span class=w>  </span>
<span class=w>     </span><span class=p>}</span><span class=w>  </span>
<span class=w>     </span><span class=cm>/*</span>
<span class=cm>       1 读结束后，如果不允许半开关，则关闭写端，如果还有数据还没有发送</span>
<span class=cm>       完毕，则先发送完再关闭</span>
<span class=cm>       2 重置写函数，后续执行写的时候报错  </span>
<span class=cm>     */</span>
<span class=w>     </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=k>this</span><span class=p>.</span><span class=nx>allowHalfOpen</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>       </span><span class=k>this</span><span class=p>.</span><span class=nx>write</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>writeAfterFIN</span><span class=p>;</span><span class=w>  </span>
<span class=w>       </span><span class=k>this</span><span class=p>.</span><span class=nx>destroySoon</span><span class=p>();</span><span class=w>  </span>
<span class=w>     </span><span class=p>}</span><span class=w>  </span>
<span class=w>    </span><span class=p>}</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>当socket的读端结束时，socket的状态变更分为几种情况<br> 1 如果可读流中还有缓存的数据，则等待读取。<br> 2 如果写端也结束了，则销毁流。<br> 3 如果写端没有结束，则判断allowHalfOpen是否允许半开关，不允许并且写端数据已经发送完毕则关闭写端。 </p> <h3 id=1713>17.1.3 写操作<a class=headerlink href=#1713 title="Permanent link">&para;</a></h3> <p>接着我们看一下在一个流上写的时候，逻辑是怎样的。Socket实现了单个写和批量写接口。</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span>
<span class=normal>7</span>
<span class=normal>8</span>
<span class=normal>9</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=c1>// 批量写  </span>
<span class=w>    </span><span class=nx>Socket</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>_writev</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kd>function</span><span class=p>(</span><span class=nx>chunks</span><span class=p>,</span><span class=w> </span><span class=nx>cb</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=nx>_writeGeneric</span><span class=p>(</span><span class=kc>true</span><span class=p>,</span><span class=w> </span><span class=nx>chunks</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;&#39;</span><span class=p>,</span><span class=w> </span><span class=nx>cb</span><span class=p>);</span><span class=w>  </span>
<span class=w>    </span><span class=p>};</span><span class=w>  </span>

<span class=w>    </span><span class=c1>// 单个写  </span>
<span class=w>    </span><span class=nx>Socket</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>_write</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kd>function</span><span class=p>(</span><span class=nx>data</span><span class=p>,</span><span class=w> </span><span class=nx>encoding</span><span class=p>,</span><span class=w> </span><span class=nx>cb</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=nx>_writeGeneric</span><span class=p>(</span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=nx>data</span><span class=p>,</span><span class=w> </span><span class=nx>encoding</span><span class=p>,</span><span class=w> </span><span class=nx>cb</span><span class=p>);</span><span class=w>  </span>
<span class=w>    </span><span class=p>};</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>_writeGeneric</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span>
<span class=normal>24</span>
<span class=normal>25</span>
<span class=normal>26</span>
<span class=normal>27</span>
<span class=normal>28</span>
<span class=normal>29</span>
<span class=normal>30</span>
<span class=normal>31</span>
<span class=normal>32</span>
<span class=normal>33</span>
<span class=normal>34</span>
<span class=normal>35</span>
<span class=normal>36</span>
<span class=normal>37</span>
<span class=normal>38</span>
<span class=normal>39</span>
<span class=normal>40</span>
<span class=normal>41</span>
<span class=normal>42</span>
<span class=normal>43</span>
<span class=normal>44</span>
<span class=normal>45</span>
<span class=normal>46</span>
<span class=normal>47</span>
<span class=normal>48</span>
<span class=normal>49</span>
<span class=normal>50</span>
<span class=normal>51</span>
<span class=normal>52</span>
<span class=normal>53</span>
<span class=normal>54</span>
<span class=normal>55</span>
<span class=normal>56</span>
<span class=normal>57</span>
<span class=normal>58</span>
<span class=normal>59</span>
<span class=normal>60</span>
<span class=normal>61</span>
<span class=normal>62</span>
<span class=normal>63</span>
<span class=normal>64</span>
<span class=normal>65</span>
<span class=normal>66</span>
<span class=normal>67</span>
<span class=normal>68</span>
<span class=normal>69</span>
<span class=normal>70</span>
<span class=normal>71</span>
<span class=normal>72</span>
<span class=normal>73</span>
<span class=normal>74</span>
<span class=normal>75</span>
<span class=normal>76</span>
<span class=normal>77</span>
<span class=normal>78</span>
<span class=normal>79</span>
<span class=normal>80</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=nx>Socket</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>_writeGeneric</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kd>function</span><span class=p>(</span><span class=nx>writev</span><span class=p>,</span><span class=w> </span><span class=nx>data</span><span class=p>,</span><span class=w> </span><span class=nx>encoding</span><span class=p>,</span><span class=w> </span><span class=nx>cb</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=cm>/*  </span>
<span class=cm>         正在连接，则先保存待写的数据，因为stream模块是串行写的， </span>
<span class=cm>         所以第一次写没完成，不会执行第二次写操作（_write）， </span>
<span class=cm>         所以这里用一个字段而不是一个数组或队列保存数据和编码， </span>
<span class=cm>         因为有pendingData时_writeGeneric 不会被执行第二次，这里缓存 </span>
<span class=cm>         pendingData不是为了后续写入，而是为了统计写入的数据总数 </span>
<span class=cm>      */</span><span class=w>  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>connecting</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=nx>_pendingData</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>data</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=nx>_pendingEncoding</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>encoding</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=nx>once</span><span class=p>(</span><span class=s1>&#39;connect&#39;</span><span class=p>,</span><span class=w> </span><span class=kd>function</span><span class=w> </span><span class=nx>connect</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>          </span><span class=k>this</span><span class=p>.</span><span class=nx>_writeGeneric</span><span class=p>(</span><span class=nx>writev</span><span class=p>,</span><span class=w> </span><span class=nx>data</span><span class=p>,</span><span class=w> </span><span class=nx>encoding</span><span class=p>,</span><span class=w> </span><span class=nx>cb</span><span class=p>);</span><span class=w>  </span>
<span class=w>        </span><span class=p>});</span><span class=w>  </span>
<span class=w>        </span><span class=k>return</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 开始写，则清空之前缓存的数据  </span>
<span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=nx>_pendingData</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=nx>_pendingEncoding</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;&#39;</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 写操作，有数据通信，刷新定时器  </span>
<span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=nx>_unrefTimer</span><span class=p>();</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 已经关闭，则销毁socket  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=k>this</span><span class=p>.</span><span class=nx>_handle</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=nx>destroy</span><span class=p>(</span><span class=ow>new</span><span class=w> </span><span class=nx>errors</span><span class=p>.</span><span class=ne>Error</span><span class=p>(</span><span class=s1>&#39;ERR_SOCKET_CLOSED&#39;</span><span class=p>),</span><span class=w> </span><span class=nx>cb</span><span class=p>);</span><span class=w>  </span>
<span class=w>        </span><span class=k>return</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 新建一个写请求  </span>
<span class=w>      </span><span class=kd>var</span><span class=w> </span><span class=nx>req</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=ow>new</span><span class=w> </span><span class=nx>WriteWrap</span><span class=p>();</span><span class=w>  </span>
<span class=w>      </span><span class=nx>req</span><span class=p>.</span><span class=nx>handle</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=nx>_handle</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=nx>req</span><span class=p>.</span><span class=nx>oncomplete</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>afterWrite</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 是否同步执行写完成回调，取决于底层是同步写入，然后执行回调还是异步写入  </span>
<span class=w>      </span><span class=nx>req</span><span class=p>.</span><span class=k>async</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=kd>var</span><span class=w> </span><span class=nx>err</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 是否批量写  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>writev</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// 所有数据都是buffer类型，则直接堆起来，否则需要保存编码类型  </span>
<span class=w>        </span><span class=kd>var</span><span class=w> </span><span class=nx>allBuffers</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>data</span><span class=p>.</span><span class=nx>allBuffers</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=kd>var</span><span class=w> </span><span class=nx>chunks</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=kd>var</span><span class=w> </span><span class=nx>i</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>allBuffers</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>          </span><span class=nx>chunks</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>data</span><span class=p>;</span><span class=w>  </span>
<span class=w>          </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=nx>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mf>0</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=nx>data</span><span class=p>.</span><span class=nx>length</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=o>++</span><span class=p>)</span><span class=w>  </span>
<span class=w>            </span><span class=nx>data</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>data</span><span class=p>[</span><span class=nx>i</span><span class=p>].</span><span class=nx>chunk</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>          </span><span class=c1>// 申请double个大小的数组  </span>
<span class=w>          </span><span class=nx>chunks</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=ow>new</span><span class=w> </span><span class=nb>Array</span><span class=p>(</span><span class=nx>data</span><span class=p>.</span><span class=nx>length</span><span class=w> </span><span class=o>&lt;&lt;</span><span class=w> </span><span class=mf>1</span><span class=p>);</span><span class=w>  </span>
<span class=w>          </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=nx>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mf>0</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=nx>data</span><span class=p>.</span><span class=nx>length</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>            </span><span class=kd>var</span><span class=w> </span><span class=nx>entry</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>data</span><span class=p>[</span><span class=nx>i</span><span class=p>];</span><span class=w>  </span>
<span class=w>            </span><span class=nx>chunks</span><span class=p>[</span><span class=nx>i</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=mf>2</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>entry</span><span class=p>.</span><span class=nx>chunk</span><span class=p>;</span><span class=w>  </span>
<span class=w>            </span><span class=nx>chunks</span><span class=p>[</span><span class=nx>i</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=mf>2</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mf>1</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>entry</span><span class=p>.</span><span class=nx>encoding</span><span class=p>;</span><span class=w>  </span>
<span class=w>          </span><span class=p>}</span><span class=w>  </span>
<span class=w>        </span><span class=p>}</span><span class=w>  </span>
<span class=w>        </span><span class=nx>err</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=nx>_handle</span><span class=p>.</span><span class=nx>writev</span><span class=p>(</span><span class=nx>req</span><span class=p>,</span><span class=w> </span><span class=nx>chunks</span><span class=p>,</span><span class=w> </span><span class=nx>allBuffers</span><span class=p>);</span><span class=w>  </span>

<span class=w>        </span><span class=c1>// Retain chunks  </span>
<span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>err</span><span class=w> </span><span class=o>===</span><span class=w> </span><span class=mf>0</span><span class=p>)</span><span class=w> </span><span class=nx>req</span><span class=p>.</span><span class=nx>_chunks</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>chunks</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=kd>var</span><span class=w> </span><span class=nx>enc</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>data</span><span class=w> </span><span class=ow>instanceof</span><span class=w> </span><span class=nx>Buffer</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>          </span><span class=nx>enc</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;buffer&#39;</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>          </span><span class=nx>enc</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>encoding</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=p>}</span><span class=w>  </span>
<span class=w>        </span><span class=nx>err</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>createWriteReq</span><span class=p>(</span><span class=nx>req</span><span class=p>,</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=nx>_handle</span><span class=p>,</span><span class=w> </span><span class=nx>data</span><span class=p>,</span><span class=w> </span><span class=nx>enc</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>

<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>err</span><span class=p>)</span><span class=w>  </span>
<span class=w>        </span><span class=k>return</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=nx>destroy</span><span class=p>(</span><span class=nx>errnoException</span><span class=p>(</span><span class=nx>err</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;write&#39;</span><span class=p>,</span><span class=w> </span><span class=nx>req</span><span class=p>.</span><span class=nx>error</span><span class=p>),</span><span class=w> </span><span class=nx>cb</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 请求写入底层的数据字节长度  </span>
<span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=nx>_bytesDispatched</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=nx>req</span><span class=p>.</span><span class=nx>bytes</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 在stream_base.cc中req_wrap_obj-&gt;Set(env-&gt;async(), True(env-&gt;isolate()));设置  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=nx>req</span><span class=p>.</span><span class=k>async</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=nx>cb</span><span class=p>();</span><span class=w>  </span>
<span class=w>        </span><span class=k>return</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>

<span class=w>      </span><span class=nx>req</span><span class=p>.</span><span class=nx>cb</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>cb</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 最后一次请求写数据的字节长度  </span>
<span class=w>      </span><span class=k>this</span><span class=p>[</span><span class=nx>kLastWriteQueueSize</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>req</span><span class=p>.</span><span class=nx>bytes</span><span class=p>;</span><span class=w>  </span>
<span class=w>    </span><span class=p>};</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>上面的代码很多，但是逻辑并不复杂，具体实现在stream_base.cc和stream_wrap.cc，这里不再展开分析，主要是执行writev和createWriteReq函数进行写操作。它们底层调用的都是uv_write2（需要传递文件描述符）或uv_write（不需要传递文件描述符）或者uv_try_write函数进行写操作。这里只分析一下async的意义，async默认是false，它表示的意义是执行底层写入时，底层是否同步执行回调，async为false说明写入完成回调是同步执行的。在stream_base.cc的写函数中有相关的逻辑。</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=n>err</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>DoWrite</span><span class=p>(</span><span class=n>req_wrap</span><span class=p>,</span><span class=w> </span><span class=n>buf_list</span><span class=p>,</span><span class=w> </span><span class=n>count</span><span class=p>,</span><span class=w> </span><span class=k>nullptr</span><span class=p>);</span><span class=w>  </span>
<span class=w>    </span><span class=n>req_wrap_obj</span><span class=o>-&gt;</span><span class=n>Set</span><span class=p>(</span><span class=n>env</span><span class=o>-&gt;</span><span class=n>async</span><span class=p>(),</span><span class=w> </span><span class=n>True</span><span class=p>(</span><span class=n>env</span><span class=o>-&gt;</span><span class=n>isolate</span><span class=p>()));</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>当执行DoWrite的时候，req_wrap中保存的回调可能会被Libuv同步执行，从而执行JS代码，这时候async是false（默认值），说明回调是被同步执行的，如果DoWrite没有同步执行回调。则说明是异步执行回调。设置async为true，再执行JS代码。</p> <h3 id=1714>17.1.4 关闭写操作<a class=headerlink href=#1714 title="Permanent link">&para;</a></h3> <p>当我们发送完数据后，我们可以通过调用socket对象的end函数关闭流的写端。我们看一下end的逻辑。</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span>
<span class=normal>7</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=nx>Socket</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>end</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kd>function</span><span class=p>(</span><span class=nx>data</span><span class=p>,</span><span class=w> </span><span class=nx>encoding</span><span class=p>,</span><span class=w> </span><span class=nx>callback</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=nx>stream</span><span class=p>.</span><span class=nx>Duplex</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>end</span><span class=p>.</span><span class=nx>call</span><span class=p>(</span><span class=k>this</span><span class=p>,</span><span class=w> </span>
<span class=w>                                           </span><span class=nx>data</span><span class=p>,</span><span class=w> </span>
<span class=w>                                           </span><span class=nx>encoding</span><span class=p>,</span><span class=w> </span>
<span class=w>                                           </span><span class=nx>callback</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=k>return</span><span class=w> </span><span class=k>this</span><span class=p>;</span><span class=w>  </span>
<span class=w>    </span><span class=p>};</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>Socket的end是调用的Duplex的end，而Duplex的end是继承于Writable的end。Writable的end最终会触发finish事件，socket在初始化的时候监听了该事件。</p> <p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=k>this</span><span class=p>.</span><span class=nx>on</span><span class=p>(</span><span class=s1>&#39;finish&#39;</span><span class=p>,</span><span class=w> </span><span class=nx>onSocketFinish</span><span class=p>);</span><span class=w> </span>
</code></pre></div></td></tr></table></div> 我们看看onSocketFinish。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span>
<span class=normal>24</span>
<span class=normal>25</span>
<span class=normal>26</span>
<span class=normal>27</span>
<span class=normal>28</span>
<span class=normal>29</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=c1>// 执行了end，并且数据发送完毕，则关闭写端  </span>
<span class=w>    </span><span class=kd>function</span><span class=w> </span><span class=nx>onSocketFinish</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 还没连接成功就执行了end  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>connecting</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=k>return</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=nx>once</span><span class=p>(</span><span class=s1>&#39;connect&#39;</span><span class=p>,</span><span class=w> </span><span class=nx>onSocketFinish</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 写结束了，如果也不能读或者读结束了，则销毁socket  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=k>this</span><span class=p>.</span><span class=nx>readable</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=nx>_readableState</span><span class=p>.</span><span class=nx>ended</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=k>return</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=nx>destroy</span><span class=p>();</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 不支持shutdown则直接销毁  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=k>this</span><span class=p>.</span><span class=nx>_handle</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=o>!</span><span class=k>this</span><span class=p>.</span><span class=nx>_handle</span><span class=p>.</span><span class=nx>shutdown</span><span class=p>)</span><span class=w>  </span>
<span class=w>        </span><span class=k>return</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=nx>destroy</span><span class=p>();</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 支持shutdown则执行关闭，并设置回调  </span>
<span class=w>      </span><span class=kd>var</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>defaultTriggerAsyncIdScope</span><span class=p>(</span><span class=w>  </span>
<span class=w>        </span><span class=k>this</span><span class=p>[</span><span class=nx>async_id_symbol</span><span class=p>],</span><span class=w> </span><span class=nx>shutdownSocket</span><span class=p>,</span><span class=w> </span><span class=k>this</span><span class=p>,</span><span class=w> </span><span class=nx>afterShutdown</span><span class=w>  </span>
<span class=w>      </span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 执行shutdown失败则直接销毁  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>err</span><span class=p>)</span><span class=w>  </span>
<span class=w>        </span><span class=k>return</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=nx>destroy</span><span class=p>(</span><span class=nx>errnoException</span><span class=p>(</span><span class=nx>err</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;shutdown&#39;</span><span class=p>));</span><span class=w>  </span>
<span class=w>    </span><span class=p>}</span><span class=w>  </span>

<span class=w>    </span><span class=c1>// 发送关闭写端的请求  </span>
<span class=w>    </span><span class=kd>function</span><span class=w> </span><span class=nx>shutdownSocket</span><span class=p>(</span><span class=nx>self</span><span class=p>,</span><span class=w> </span><span class=nx>callback</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=kd>var</span><span class=w> </span><span class=nx>req</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=ow>new</span><span class=w> </span><span class=nx>ShutdownWrap</span><span class=p>();</span><span class=w>  </span>
<span class=w>      </span><span class=nx>req</span><span class=p>.</span><span class=nx>oncomplete</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>callback</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=nx>req</span><span class=p>.</span><span class=nx>handle</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>self</span><span class=p>.</span><span class=nx>_handle</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=k>return</span><span class=w> </span><span class=nx>self</span><span class=p>.</span><span class=nx>_handle</span><span class=p>.</span><span class=nx>shutdown</span><span class=p>(</span><span class=nx>req</span><span class=p>);</span><span class=w>  </span>
<span class=w>    </span><span class=p>}</span><span class=w>  </span>
</code></pre></div></td></tr></table></div></p> <p>Shutdown函数在stream_base.cc中定义，最终调用uv_shutdown关闭流的写端，在Libuv流章节我们已经分析过。接着我们看一下关闭写端后，回调函数的逻辑。</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=c1>// 关闭写端成功后的回调  </span>
<span class=w>    </span><span class=kd>function</span><span class=w> </span><span class=nx>afterShutdown</span><span class=p>(</span><span class=nx>status</span><span class=p>,</span><span class=w> </span><span class=nx>handle</span><span class=p>,</span><span class=w> </span><span class=nx>req</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// handle关联的socket  </span>
<span class=w>      </span><span class=kd>var</span><span class=w> </span><span class=nx>self</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>handle</span><span class=p>.</span><span class=nx>owner</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 已经销毁了，则不需要往下走了，否则执行销毁操作  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>self</span><span class=p>.</span><span class=nx>destroyed</span><span class=p>)</span><span class=w>  </span>
<span class=w>        </span><span class=k>return</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 写关闭成功，并且读也结束了，则销毁socket，否则等待读结束再执行销毁  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>self</span><span class=p>.</span><span class=nx>_readableState</span><span class=p>.</span><span class=nx>ended</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=nx>self</span><span class=p>.</span><span class=nx>destroy</span><span class=p>();</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=nx>self</span><span class=p>.</span><span class=nx>once</span><span class=p>(</span><span class=s1>&#39;_socketEnd&#39;</span><span class=p>,</span><span class=w> </span><span class=nx>self</span><span class=p>.</span><span class=nx>destroy</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>    </span><span class=p>}</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <h3 id=1715>17.1.5 销毁<a class=headerlink href=#1715 title="Permanent link">&para;</a></h3> <p>当一个socket不可读也不可写的时候、被关闭、发生错误的时候，就会被销毁。销毁一个流就是销毁流的读端、写端。然后执行流子类的_destory函数。我们看一下socket的_destroy函数</p> <p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span>
<span class=normal>24</span>
<span class=normal>25</span>
<span class=normal>26</span>
<span class=normal>27</span>
<span class=normal>28</span>
<span class=normal>29</span>
<span class=normal>30</span>
<span class=normal>31</span>
<span class=normal>32</span>
<span class=normal>33</span>
<span class=normal>34</span>
<span class=normal>35</span>
<span class=normal>36</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=c1>// 销毁时执行的钩子函数，exception代表是否因为错误导致的销毁  </span>
<span class=w>    </span><span class=nx>Socket</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>_destroy</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kd>function</span><span class=p>(</span><span class=nx>exception</span><span class=p>,</span><span class=w> </span><span class=nx>cb</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=nx>connecting</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=nx>readable</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=nx>writable</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 清除定时器  </span>
<span class=w>      </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kd>var</span><span class=w> </span><span class=nx>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>this</span><span class=p>;</span><span class=w> </span><span class=nx>s</span><span class=w> </span><span class=o>!==</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w> </span><span class=nx>s</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>s</span><span class=p>.</span><span class=nx>_parent</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=nx>clearTimeout</span><span class=p>(</span><span class=nx>s</span><span class=p>[</span><span class=nx>kTimeout</span><span class=p>]);</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>

<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>_handle</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// 是否因为出错导致销毁流  </span>
<span class=w>        </span><span class=kd>var</span><span class=w> </span><span class=nx>isException</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>exception</span><span class=w> </span><span class=o>?</span><span class=w> </span><span class=kc>true</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>    </span>
<span class=w>        </span><span class=c1>// 关闭底层handle  </span>
<span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=nx>_handle</span><span class=p>.</span><span class=nx>close</span><span class=p>(()</span><span class=w> </span><span class=p>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>          </span><span class=c1>// close事件的入参，表示是否因为错误导致的关闭  </span>
<span class=w>          </span><span class=k>this</span><span class=p>.</span><span class=nx>emit</span><span class=p>(</span><span class=s1>&#39;close&#39;</span><span class=p>,</span><span class=w> </span><span class=nx>isException</span><span class=p>);</span><span class=w>  </span>
<span class=w>        </span><span class=p>});</span><span class=w>  </span>
<span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=nx>_handle</span><span class=p>.</span><span class=nx>onread</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>noop</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=nx>_handle</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=nx>_sockname</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 执行回调  </span>
<span class=w>      </span><span class=nx>cb</span><span class=p>(</span><span class=nx>exception</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// socket所属的server，作为客户端时是null  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>_server</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// server下的连接数减一  </span>
<span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=nx>_server</span><span class=p>.</span><span class=nx>_connections</span><span class=o>--</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=cm>/*</span>
<span class=cm>          是否需要触发server的close事件，</span>
<span class=cm>          当所有的连接（socket）都关闭时才触发server的是close事件  </span>
<span class=cm>        */</span>
<span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>_server</span><span class=p>.</span><span class=nx>_emitCloseIfDrained</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>          </span><span class=k>this</span><span class=p>.</span><span class=nx>_server</span><span class=p>.</span><span class=nx>_emitCloseIfDrained</span><span class=p>();</span><span class=w>  </span>
<span class=w>        </span><span class=p>}</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>    </span><span class=p>};</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> _stream_writable.js中的destroy函数只是修改读写流的状态和标记，子类需要定义_destroy函数销毁相关的资源，socket通过调用close关闭底层关联的资源，关闭后触发socket的close事件（回调函数的第一个参数是boolean类型，说明是否因为错误导致socket关闭）。最后判断该socket是否来自服务器创建的，是的话该服务器的连接数减一，如果服务器执行了close并且当前连接数为0，则关闭服务器。</p> <h2 id=172-tcp>17.2 TCP 服务器<a class=headerlink href=#172-tcp title="Permanent link">&para;</a></h2> <p>net模块提供了createServer函数创建一个TCP服务器。</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span>
<span class=normal>24</span>
<span class=normal>25</span>
<span class=normal>26</span>
<span class=normal>27</span>
<span class=normal>28</span>
<span class=normal>29</span>
<span class=normal>30</span>
<span class=normal>31</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=kd>function</span><span class=w> </span><span class=nx>createServer</span><span class=p>(</span><span class=nx>options</span><span class=p>,</span><span class=w> </span><span class=nx>connectionListener</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=k>return</span><span class=w> </span><span class=ow>new</span><span class=w> </span><span class=nx>Server</span><span class=p>(</span><span class=nx>options</span><span class=p>,</span><span class=w> </span><span class=nx>connectionListener</span><span class=p>);</span><span class=w>  </span>
<span class=w>    </span><span class=p>}</span><span class=w>  </span>

<span class=w>    </span><span class=kd>function</span><span class=w> </span><span class=nx>Server</span><span class=p>(</span><span class=nx>options</span><span class=p>,</span><span class=w> </span><span class=nx>connectionListener</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=nx>EventEmitter</span><span class=p>.</span><span class=nx>call</span><span class=p>(</span><span class=k>this</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 注册连接到来时执行的回调  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=ow>typeof</span><span class=w> </span><span class=nx>options</span><span class=w> </span><span class=o>===</span><span class=w> </span><span class=s1>&#39;function&#39;</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=nx>connectionListener</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>options</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=nx>options</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{};</span><span class=w>  </span>
<span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=nx>on</span><span class=p>(</span><span class=s1>&#39;connection&#39;</span><span class=p>,</span><span class=w> </span><span class=nx>connectionListener</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>options</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>null</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=ow>typeof</span><span class=w> </span><span class=nx>options</span><span class=w> </span><span class=o>===</span><span class=w> </span><span class=s1>&#39;object&#39;</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=nx>options</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>options</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=p>{};</span><span class=w>  </span>
<span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=ow>typeof</span><span class=w> </span><span class=nx>connectionListener</span><span class=w> </span><span class=o>===</span><span class=w> </span><span class=s1>&#39;function&#39;</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>          </span><span class=k>this</span><span class=p>.</span><span class=nx>on</span><span class=p>(</span><span class=s1>&#39;connection&#39;</span><span class=p>,</span><span class=w> </span><span class=nx>connectionListener</span><span class=p>);</span><span class=w>  </span>
<span class=w>        </span><span class=p>}</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=k>throw</span><span class=w> </span><span class=ow>new</span><span class=w> </span><span class=nx>errors</span><span class=p>.</span><span class=ne>TypeError</span><span class=p>(</span><span class=s1>&#39;ERR_INVALID_ARG_TYPE&#39;</span><span class=p>,</span><span class=w>  </span>
<span class=w>                                   </span><span class=s1>&#39;options&#39;</span><span class=p>,</span><span class=w>  </span>
<span class=w>                                   </span><span class=s1>&#39;Object&#39;</span><span class=p>,</span><span class=w>  </span>
<span class=w>                                   </span><span class=nx>options</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 服务器建立的连接数  </span>
<span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=nx>_connections</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mf>0</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=nx>_handle</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=nx>_unref</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 服务器下的所有连接是否允许半连接  </span>
<span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=nx>allowHalfOpen</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>options</span><span class=p>.</span><span class=nx>allowHalfOpen</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 有连接时是否注册读事件  </span>
<span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=nx>pauseOnConnect</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>!!</span><span class=nx>options</span><span class=p>.</span><span class=nx>pauseOnConnect</span><span class=p>;</span><span class=w>  </span>
<span class=w>    </span><span class=p>}</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>createServer返回的就是一个一般的JS对象，接着调用listen函数监听端口。看一下listen函数的逻辑</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span>
<span class=normal>24</span>
<span class=normal>25</span>
<span class=normal>26</span>
<span class=normal>27</span>
<span class=normal>28</span>
<span class=normal>29</span>
<span class=normal>30</span>
<span class=normal>31</span>
<span class=normal>32</span>
<span class=normal>33</span>
<span class=normal>34</span>
<span class=normal>35</span>
<span class=normal>36</span>
<span class=normal>37</span>
<span class=normal>38</span>
<span class=normal>39</span>
<span class=normal>40</span>
<span class=normal>41</span>
<span class=normal>42</span>
<span class=normal>43</span>
<span class=normal>44</span>
<span class=normal>45</span>
<span class=normal>46</span>
<span class=normal>47</span>
<span class=normal>48</span>
<span class=normal>49</span>
<span class=normal>50</span>
<span class=normal>51</span>
<span class=normal>52</span>
<span class=normal>53</span>
<span class=normal>54</span>
<span class=normal>55</span>
<span class=normal>56</span>
<span class=normal>57</span>
<span class=normal>58</span>
<span class=normal>59</span>
<span class=normal>60</span>
<span class=normal>61</span>
<span class=normal>62</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=nx>Server</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>listen</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kd>function</span><span class=p>(...</span><span class=nx>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=cm>/*</span>
<span class=cm>         处理入参，根据文档我们知道listen可以接收好几个参数，</span>
<span class=cm>          假设我们这里是只传了端口号9297  </span>
<span class=cm>        */</span>
<span class=w>      </span><span class=kd>var</span><span class=w> </span><span class=nx>normalized</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>normalizeArgs</span><span class=p>(</span><span class=nx>args</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=c1>//  normalized = [{port: 9297}, null];  </span>
<span class=w>      </span><span class=kd>var</span><span class=w> </span><span class=nx>options</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>normalized</span><span class=p>[</span><span class=mf>0</span><span class=p>];</span><span class=w>  </span>
<span class=w>      </span><span class=kd>var</span><span class=w> </span><span class=nx>cb</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>normalized</span><span class=p>[</span><span class=mf>1</span><span class=p>];</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 第一次listen的时候会创建，如果非空说明已经listen过  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>_handle</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=k>throw</span><span class=w> </span><span class=ow>new</span><span class=w> </span><span class=nx>errors</span><span class=p>.</span><span class=ne>Error</span><span class=p>(</span><span class=s1>&#39;ERR_SERVER_ALREADY_LISTEN&#39;</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// listen成功后执行的回调  </span>
<span class=w>      </span><span class=kd>var</span><span class=w> </span><span class=nx>hasCallback</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=nx>cb</span><span class=w> </span><span class=o>!==</span><span class=w> </span><span class=kc>null</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>hasCallback</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// listen成功的回调  </span>
<span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=nx>once</span><span class=p>(</span><span class=s1>&#39;listening&#39;</span><span class=p>,</span><span class=w> </span><span class=nx>cb</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>

<span class=w>      </span><span class=nx>options</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>options</span><span class=p>.</span><span class=nx>_handle</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=nx>options</span><span class=p>.</span><span class=nx>handle</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=nx>options</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 第一种情况，传进来的是一个TCP服务器，而不是需要创建一个服务器  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>options</span><span class=w> </span><span class=ow>instanceof</span><span class=w> </span><span class=nx>TCP</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=nx>_handle</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>options</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=k>this</span><span class=p>[</span><span class=nx>async_id_symbol</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=nx>_handle</span><span class=p>.</span><span class=nx>getAsyncId</span><span class=p>();</span><span class=w>  </span>
<span class=w>        </span><span class=nx>listenIncluster</span><span class=p>(</span><span class=k>this</span><span class=p>,</span><span class=w> </span><span class=kc>null</span><span class=p>,</span><span class=w> </span><span class=o>-</span><span class=mf>1</span><span class=p>,</span><span class=w> </span><span class=o>-</span><span class=mf>1</span><span class=p>,</span><span class=w> </span><span class=nx>backlogFromArgs</span><span class=p>);</span><span class=w>  </span>
<span class=w>        </span><span class=k>return</span><span class=w> </span><span class=k>this</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 第二种，传进来一个对象，并且带了fd  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=ow>typeof</span><span class=w> </span><span class=nx>options</span><span class=p>.</span><span class=nx>fd</span><span class=w> </span><span class=o>===</span><span class=w> </span><span class=s1>&#39;number&#39;</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nx>options</span><span class=p>.</span><span class=nx>fd</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=mf>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=nx>listenIncluster</span><span class=p>(</span><span class=k>this</span><span class=p>,</span><span class=w> </span>
<span class=w>                            </span><span class=kc>null</span><span class=p>,</span><span class=w> </span>
<span class=w>                            </span><span class=kc>null</span><span class=p>,</span><span class=w> </span>
<span class=w>                            </span><span class=kc>null</span><span class=p>,</span><span class=w> </span>
<span class=w>                            </span><span class=nx>backlogFromArgs</span><span class=p>,</span><span class=w> </span>
<span class=w>                            </span><span class=nx>options</span><span class=p>.</span><span class=nx>fd</span><span class=p>);</span><span class=w>  </span>
<span class=w>        </span><span class=k>return</span><span class=w> </span><span class=k>this</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 创建一个tcp服务器  </span>
<span class=w>      </span><span class=kd>var</span><span class=w> </span><span class=nx>backlog</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=ow>typeof</span><span class=w> </span><span class=nx>options</span><span class=p>.</span><span class=nx>port</span><span class=w> </span><span class=o>===</span><span class=w> </span><span class=s1>&#39;number&#39;</span><span class=w> </span><span class=o>||</span><span class=w> </span>
<span class=w>             </span><span class=ow>typeof</span><span class=w> </span><span class=nx>options</span><span class=p>.</span><span class=nx>port</span><span class=w> </span><span class=o>===</span><span class=w> </span><span class=s1>&#39;string&#39;</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=nx>backlog</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>options</span><span class=p>.</span><span class=nx>backlog</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=nx>backlogFromArgs</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// 第三种 启动一个TCP服务器，传了host则先进行DNS解析</span>
<span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>options</span><span class=p>.</span><span class=nx>host</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>              </span><span class=nx>lookupAndListen</span><span class=p>(</span><span class=k>this</span><span class=p>,</span>
<span class=w>                              </span><span class=nx>options</span><span class=p>.</span><span class=nx>port</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=mf>0</span><span class=p>,</span><span class=w> </span>
<span class=w>                              </span><span class=nx>options</span><span class=p>.</span><span class=nx>host</span><span class=p>,</span><span class=w> </span>
<span class=w>                              </span><span class=nx>backlog</span><span class=p>,</span>
<span class=w>                              </span><span class=nx>options</span><span class=p>.</span><span class=nx>exclusive</span><span class=p>);</span><span class=w>  </span>
<span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span>
<span class=w>          </span><span class=nx>listenIncluster</span><span class=p>(</span><span class=k>this</span><span class=p>,</span><span class=w> </span>
<span class=w>                                </span><span class=kc>null</span><span class=p>,</span><span class=w> </span>
<span class=w>                                </span><span class=nx>options</span><span class=p>.</span><span class=nx>port</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=mf>0</span><span class=p>,</span><span class=w> </span>
<span class=w>                                </span><span class=mf>4</span><span class=p>,</span><span class=w>      </span>
<span class=w>                                </span><span class=nx>backlog</span><span class=p>,</span><span class=w> </span>
<span class=w>                                </span><span class=kc>undefined</span><span class=p>,</span><span class=w> </span>
<span class=w>                                </span><span class=nx>options</span><span class=p>.</span><span class=nx>exclusive</span><span class=p>);</span><span class=w>  </span>
<span class=w>        </span><span class=p>}</span><span class=w>  </span>
<span class=w>        </span><span class=k>return</span><span class=w> </span><span class=k>this</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>    </span><span class=p>};</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>我们看到有三种情况，分别是传了一个服务器、传了一个fd、传了端口（或者host），但是我们发现，这几种情况最后都是调用了listenIncluster（lookupAndListen是先DNS解析后再执行listenIncluster），只是入参不一样，所以我们直接看listenIncluster。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=kd>function</span><span class=w> </span><span class=nx>listenIncluster</span><span class=p>(</span><span class=nx>server</span><span class=p>,</span><span class=w> </span>
<span class=w>                              </span><span class=nx>address</span><span class=p>,</span><span class=w> </span>
<span class=w>                              </span><span class=nx>port</span><span class=p>,</span><span class=w> </span>
<span class=w>                              </span><span class=nx>addressType</span><span class=p>,</span><span class=w>      </span>
<span class=w>                              </span><span class=nx>backlog</span><span class=p>,</span><span class=w> </span>
<span class=w>                              </span><span class=nx>fd</span><span class=p>,</span><span class=w> </span>
<span class=w>                              </span><span class=nx>exclusive</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=nx>exclusive</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>!!</span><span class=nx>exclusive</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>cluster</span><span class=w> </span><span class=o>===</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w> </span><span class=nx>cluster</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>require</span><span class=p>(</span><span class=s1>&#39;cluster&#39;</span><span class=p>);</span><span class=w> </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>cluster</span><span class=p>.</span><span class=nx>isMaster</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=nx>exclusive</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=nx>server</span><span class=p>.</span><span class=nx>_listen2</span><span class=p>(</span><span class=nx>address</span><span class=p>,</span><span class=w> </span><span class=nx>port</span><span class=p>,</span><span class=w> </span><span class=nx>addressType</span><span class=p>,</span><span class=w> </span><span class=nx>backlog</span><span class=p>,</span><span class=w> </span><span class=nx>fd</span><span class=p>);</span>
<span class=w>        </span><span class=k>return</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>    </span><span class=p>}</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> 因为我们是在主进程，所以直接执行_listen2，子进程的在cluster模块分析。_listen对应的函数是setupListenHandle</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span>
<span class=normal>24</span>
<span class=normal>25</span>
<span class=normal>26</span>
<span class=normal>27</span>
<span class=normal>28</span>
<span class=normal>29</span>
<span class=normal>30</span>
<span class=normal>31</span>
<span class=normal>32</span>
<span class=normal>33</span>
<span class=normal>34</span>
<span class=normal>35</span>
<span class=normal>36</span>
<span class=normal>37</span>
<span class=normal>38</span>
<span class=normal>39</span>
<span class=normal>40</span>
<span class=normal>41</span>
<span class=normal>42</span>
<span class=normal>43</span>
<span class=normal>44</span>
<span class=normal>45</span>
<span class=normal>46</span>
<span class=normal>47</span>
<span class=normal>48</span>
<span class=normal>49</span>
<span class=normal>50</span>
<span class=normal>51</span>
<span class=normal>52</span>
<span class=normal>53</span>
<span class=normal>54</span>
<span class=normal>55</span>
<span class=normal>56</span>
<span class=normal>57</span>
<span class=normal>58</span>
<span class=normal>59</span>
<span class=normal>60</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=kd>function</span><span class=w> </span><span class=nx>setupListenHandle</span><span class=p>(</span><span class=nx>address</span><span class=p>,</span><span class=w> </span><span class=nx>port</span><span class=p>,</span><span class=w> </span><span class=nx>addressType</span><span class=p>,</span><span class=w> </span><span class=nx>backlog</span><span class=p>,</span><span class=w> </span><span class=nx>fd</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 有handle则不需要创建了，否则创建一个底层的handle  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>_handle</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>

<span class=w>      </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=kd>var</span><span class=w> </span><span class=nx>rval</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// 没有传fd，则说明是监听端口和IP  </span>
<span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=nx>address</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=ow>typeof</span><span class=w> </span><span class=nx>fd</span><span class=w> </span><span class=o>!==</span><span class=w> </span><span class=s1>&#39;number&#39;</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>          </span><span class=nx>rval</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>createServerHandle</span><span class=p>(</span><span class=s1>&#39;::&#39;</span><span class=p>,</span><span class=w> </span><span class=nx>port</span><span class=p>,</span><span class=w> </span><span class=mf>6</span><span class=p>,</span><span class=w> </span><span class=nx>fd</span><span class=p>);</span><span class=w>  </span>
<span class=w>          </span><span class=cm>/*</span>
<span class=cm>                   返回number说明bind IPv6版本的handle失败，</span>
<span class=cm>                   回退到v4，否则说明支持IPv6  </span>
<span class=cm>                */</span>
<span class=w>          </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=ow>typeof</span><span class=w> </span><span class=nx>rval</span><span class=w> </span><span class=o>===</span><span class=w> </span><span class=s1>&#39;number&#39;</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>            </span><span class=c1>// 赋值为null，才能走下面的createServerHandle  </span>
<span class=w>            </span><span class=nx>rval</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>  </span>
<span class=w>            </span><span class=nx>address</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;0.0.0.0&#39;</span><span class=p>;</span><span class=w>  </span>
<span class=w>            </span><span class=nx>addressType</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mf>4</span><span class=p>;</span><span class=w>  </span>
<span class=w>          </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>            </span><span class=nx>address</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;::&#39;</span><span class=p>;</span><span class=w>  </span>
<span class=w>            </span><span class=nx>addressType</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mf>6</span><span class=p>;</span><span class=w>  </span>
<span class=w>          </span><span class=p>}</span><span class=w>  </span>
<span class=w>        </span><span class=p>}</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// 创建失败则继续创建  </span>
<span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>rval</span><span class=w> </span><span class=o>===</span><span class=w> </span><span class=kc>null</span><span class=p>)</span><span class=w>  </span>
<span class=w>          </span><span class=nx>rval</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>createServerHandle</span><span class=p>(</span><span class=nx>address</span><span class=p>,</span><span class=w> </span>
<span class=w>                                            </span><span class=nx>port</span><span class=p>,</span><span class=w> </span>
<span class=w>                                            </span><span class=nx>addressType</span><span class=p>,</span><span class=w> </span>
<span class=w>                                            </span><span class=nx>fd</span><span class=p>);</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// 还报错则说明创建服务器失败，报错  </span>
<span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=ow>typeof</span><span class=w> </span><span class=nx>rval</span><span class=w> </span><span class=o>===</span><span class=w> </span><span class=s1>&#39;number&#39;</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>          </span><span class=kd>var</span><span class=w> </span><span class=nx>error</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>exceptionWithHostPort</span><span class=p>(</span><span class=nx>rval</span><span class=p>,</span><span class=w> </span>
<span class=w>                                                     </span><span class=s1>&#39;listen&#39;</span><span class=p>,</span><span class=w> </span>
<span class=w>                                                     </span><span class=nx>address</span><span class=p>,</span><span class=w> </span>
<span class=w>                                                     </span><span class=nx>port</span><span class=p>);</span><span class=w>  </span>
<span class=w>          </span><span class=nx>process</span><span class=p>.</span><span class=nx>nextTick</span><span class=p>(</span><span class=nx>emitErrorNT</span><span class=p>,</span><span class=w> </span><span class=k>this</span><span class=p>,</span><span class=w> </span><span class=nx>error</span><span class=p>);</span><span class=w>  </span>
<span class=w>          </span><span class=k>return</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=p>}</span><span class=w>  </span>
<span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=nx>_handle</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>rval</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>

<span class=w>      </span><span class=c1>// 有完成三次握手的连接时执行的回调  </span>
<span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=nx>_handle</span><span class=p>.</span><span class=nx>onconnection</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>onconnection</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=nx>_handle</span><span class=p>.</span><span class=nx>owner</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>this</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 执行C++层listen  </span>
<span class=w>      </span><span class=kd>var</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=nx>_handle</span><span class=p>.</span><span class=nx>listen</span><span class=p>(</span><span class=nx>backlog</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=mf>511</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 出错则报错  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>err</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=kd>var</span><span class=w> </span><span class=nx>ex</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>exceptionWithHostPort</span><span class=p>(</span><span class=nx>err</span><span class=p>,</span><span class=w> </span>
<span class=w>                                              </span><span class=s1>&#39;listen&#39;</span><span class=p>,</span><span class=w> </span>
<span class=w>                                              </span><span class=nx>address</span><span class=p>,</span><span class=w> </span>
<span class=w>                                              </span><span class=nx>port</span><span class=p>);</span><span class=w>  </span>
<span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=nx>_handle</span><span class=p>.</span><span class=nx>close</span><span class=p>();</span><span class=w>  </span>
<span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=nx>_handle</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=nx>nextTick</span><span class=p>(</span><span class=k>this</span><span class=p>[</span><span class=nx>async_id_symbol</span><span class=p>],</span><span class=w> </span><span class=nx>emitErrorNT</span><span class=p>,</span><span class=w> </span><span class=k>this</span><span class=p>,</span><span class=w> </span><span class=nx>ex</span><span class=p>);</span><span class=w>  </span>
<span class=w>        </span><span class=k>return</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w> </span>
<span class=w>      </span><span class=c1>// 触发listen回调  </span>
<span class=w>      </span><span class=nx>nextTick</span><span class=p>(</span><span class=k>this</span><span class=p>[</span><span class=nx>async_id_symbol</span><span class=p>],</span><span class=w> </span><span class=nx>emitListeningNT</span><span class=p>,</span><span class=w> </span><span class=k>this</span><span class=p>);</span><span class=w>  </span>
<span class=w>    </span><span class=p>}</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>主要是调用createServerHandle创建一个handle，然后调用listen函数监听。我们先看createServerHandle</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span>
<span class=normal>24</span>
<span class=normal>25</span>
<span class=normal>26</span>
<span class=normal>27</span>
<span class=normal>28</span>
<span class=normal>29</span>
<span class=normal>30</span>
<span class=normal>31</span>
<span class=normal>32</span>
<span class=normal>33</span>
<span class=normal>34</span>
<span class=normal>35</span>
<span class=normal>36</span>
<span class=normal>37</span>
<span class=normal>38</span>
<span class=normal>39</span>
<span class=normal>40</span>
<span class=normal>41</span>
<span class=normal>42</span>
<span class=normal>43</span>
<span class=normal>44</span>
<span class=normal>45</span>
<span class=normal>46</span>
<span class=normal>47</span>
<span class=normal>48</span>
<span class=normal>49</span>
<span class=normal>50</span>
<span class=normal>51</span>
<span class=normal>52</span>
<span class=normal>53</span>
<span class=normal>54</span>
<span class=normal>55</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=kd>function</span><span class=w> </span><span class=nx>createServerHandle</span><span class=p>(</span><span class=nx>address</span><span class=p>,</span><span class=w> </span><span class=nx>port</span><span class=p>,</span><span class=w> </span><span class=nx>addressType</span><span class=p>,</span><span class=w> </span><span class=nx>fd</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=kd>var</span><span class=w> </span><span class=nx>err</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mf>0</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=kd>var</span><span class=w> </span><span class=nx>handle</span><span class=p>;</span><span class=w>  </span>

<span class=w>      </span><span class=kd>var</span><span class=w> </span><span class=nx>isTCP</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>false</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 传了fd则根据fd创建一个handle  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=ow>typeof</span><span class=w> </span><span class=nx>fd</span><span class=w> </span><span class=o>===</span><span class=w> </span><span class=s1>&#39;number&#39;</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nx>fd</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=mf>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=k>try</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>          </span><span class=nx>handle</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>createHandle</span><span class=p>(</span><span class=nx>fd</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>);</span><span class=w>  </span>
<span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>catch</span><span class=w> </span><span class=p>(</span><span class=nx>e</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>          </span><span class=k>return</span><span class=w> </span><span class=nx>UV_EINVAL</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=p>}</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// 把fd存到handle中  </span>
<span class=w>        </span><span class=nx>handle</span><span class=p>.</span><span class=nx>open</span><span class=p>(</span><span class=nx>fd</span><span class=p>);</span><span class=w>  </span>
<span class=w>        </span><span class=nx>handle</span><span class=p>.</span><span class=nx>readable</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=nx>handle</span><span class=p>.</span><span class=nx>writable</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=nx>assert</span><span class=p>(</span><span class=o>!</span><span class=nx>address</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=o>!</span><span class=nx>port</span><span class=p>);</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// 管道  </span>
<span class=w>      </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>port</span><span class=w> </span><span class=o>===</span><span class=w> </span><span class=o>-</span><span class=mf>1</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nx>addressType</span><span class=w> </span><span class=o>===</span><span class=w> </span><span class=o>-</span><span class=mf>1</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// 创建一个Unix域服务器  </span>
<span class=w>        </span><span class=nx>handle</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=ow>new</span><span class=w> </span><span class=nx>Pipe</span><span class=p>(</span><span class=nx>PipeConstants</span><span class=p>.</span><span class=nx>SERVER</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// 创建一个TCP服务器  </span>
<span class=w>        </span><span class=nx>handle</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=ow>new</span><span class=w> </span><span class=nx>TCP</span><span class=p>(</span><span class=nx>TCPConstants</span><span class=p>.</span><span class=nx>SERVER</span><span class=p>);</span><span class=w>  </span>
<span class=w>        </span><span class=nx>isTCP</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>      </span><span class=cm>/*</span>
<span class=cm>          有地址或者IP说明是通过IP端口创建的TCP服务器，</span>
<span class=cm>           需要调bind绑定地址 </span>
<span class=cm>        */</span><span class=w> </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>address</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=nx>port</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=nx>isTCP</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// 没有地址，则优先绑定IPv6版本的本地地址  </span>
<span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=nx>address</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>          </span><span class=c1>// Try binding to IPv6 first  </span>
<span class=w>          </span><span class=nx>err</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>handle</span><span class=p>.</span><span class=nx>bind6</span><span class=p>(</span><span class=s1>&#39;::&#39;</span><span class=p>,</span><span class=w> </span><span class=nx>port</span><span class=p>);</span><span class=w>  </span>
<span class=w>          </span><span class=c1>// 失败则绑定v4的  </span>
<span class=w>          </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>err</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>            </span><span class=nx>handle</span><span class=p>.</span><span class=nx>close</span><span class=p>();</span><span class=w>  </span>
<span class=w>            </span><span class=c1>// Fallback to IPv4  </span>
<span class=w>            </span><span class=k>return</span><span class=w> </span><span class=nx>createServerHandle</span><span class=p>(</span><span class=s1>&#39;0.0.0.0&#39;</span><span class=p>,</span><span class=w> </span><span class=nx>port</span><span class=p>);</span><span class=w>  </span>
<span class=w>          </span><span class=p>}</span><span class=w>  </span>
<span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>addressType</span><span class=w> </span><span class=o>===</span><span class=w> </span><span class=mf>6</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=c1>// IPv6或v4  </span>
<span class=w>          </span><span class=nx>err</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>handle</span><span class=p>.</span><span class=nx>bind6</span><span class=p>(</span><span class=nx>address</span><span class=p>,</span><span class=w> </span><span class=nx>port</span><span class=p>);</span><span class=w>  </span>
<span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>          </span><span class=nx>err</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>handle</span><span class=p>.</span><span class=nx>bind</span><span class=p>(</span><span class=nx>address</span><span class=p>,</span><span class=w> </span><span class=nx>port</span><span class=p>);</span><span class=w>  </span>
<span class=w>        </span><span class=p>}</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>

<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>err</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=nx>handle</span><span class=p>.</span><span class=nx>close</span><span class=p>();</span><span class=w>  </span>
<span class=w>        </span><span class=k>return</span><span class=w> </span><span class=nx>err</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>

<span class=w>      </span><span class=k>return</span><span class=w> </span><span class=nx>handle</span><span class=p>;</span><span class=w>  </span>
<span class=w>    </span><span class=p>}</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>createServerHandle主要是调用createHandle创建一个handle然后执行bind函数。创建handle的方式有几种，直接调用C++层的函数或者通过fd创建。调用createHandle可以通过fd创建一个handle</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=c1>// 通过fd创建一个handle，作为客户端或者服务器  </span>
<span class=w>    </span><span class=kd>function</span><span class=w> </span><span class=nx>createHandle</span><span class=p>(</span><span class=nx>fd</span><span class=p>,</span><span class=w> </span><span class=nx>is_server</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 判断fd对应的类型  </span>
<span class=w>      </span><span class=kd>const</span><span class=w> </span><span class=nx>type</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>TTYWrap</span><span class=p>.</span><span class=nx>guessHandleType</span><span class=p>(</span><span class=nx>fd</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// Unix域  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>type</span><span class=w> </span><span class=o>===</span><span class=w> </span><span class=s1>&#39;PIPE&#39;</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=k>return</span><span class=w> </span><span class=ow>new</span><span class=w> </span><span class=nx>Pipe</span><span class=p>(</span><span class=w>  </span>
<span class=w>          </span><span class=nx>is_server</span><span class=w> </span><span class=o>?</span><span class=w> </span><span class=nx>PipeConstants</span><span class=p>.</span><span class=nx>SERVER</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=nx>PipeConstants</span><span class=p>.</span><span class=nx>SOCKET</span><span class=w>      </span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// tcp  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>type</span><span class=w> </span><span class=o>===</span><span class=w> </span><span class=s1>&#39;TCP&#39;</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=k>return</span><span class=w> </span><span class=ow>new</span><span class=w> </span><span class=nx>TCP</span><span class=p>(</span><span class=w>  </span>
<span class=w>          </span><span class=nx>is_server</span><span class=w> </span><span class=o>?</span><span class=w> </span><span class=nx>TCPConstants</span><span class=p>.</span><span class=nx>SERVER</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=nx>TCPConstants</span><span class=p>.</span><span class=nx>SOCKET</span><span class=w>  </span>
<span class=w>        </span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>

<span class=w>      </span><span class=k>throw</span><span class=w> </span><span class=ow>new</span><span class=w> </span><span class=nx>errors</span><span class=p>.</span><span class=ne>TypeError</span><span class=p>(</span><span class=s1>&#39;ERR_INVALID_FD_TYPE&#39;</span><span class=p>,</span><span class=w> </span><span class=nx>type</span><span class=p>);</span><span class=w>  </span>
<span class=w>    </span><span class=p>}</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>接着我们看一下bind函数的逻辑，</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span>
<span class=normal>24</span>
<span class=normal>25</span>
<span class=normal>26</span>
<span class=normal>27</span>
<span class=normal>28</span>
<span class=normal>29</span>
<span class=normal>30</span>
<span class=normal>31</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=nf>uv__tcp_bind</span><span class=p>(</span><span class=n>uv_tcp_t</span><span class=o>*</span><span class=w> </span><span class=n>tcp</span><span class=p>,</span><span class=w>  </span>
<span class=w>                     </span><span class=k>const</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=nc>sockaddr</span><span class=o>*</span><span class=w> </span><span class=n>addr</span><span class=p>,</span><span class=w>  </span>
<span class=w>                     </span><span class=kt>unsigned</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>addrlen</span><span class=p>,</span><span class=w>  </span>
<span class=w>                     </span><span class=kt>unsigned</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>flags</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=kt>int</span><span class=w> </span><span class=n>err</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=kt>int</span><span class=w> </span><span class=n>on</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 如果没有socket则创建一个，有判断是否设置了UV_HANDLE_BOUND，是则执行bind，否则不执行bind  </span>
<span class=w>      </span><span class=n>err</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>maybe_new_socket</span><span class=p>(</span><span class=n>tcp</span><span class=p>,</span><span class=w> </span><span class=n>addr</span><span class=o>-&gt;</span><span class=n>sa_family</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>err</span><span class=p>)</span><span class=w>  </span>
<span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>err</span><span class=p>;</span><span class=w>  </span>

<span class=w>      </span><span class=n>on</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 设置在断开连接的2 msl内可以重用端口，所以Node.js服务器可以快速重启  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>setsockopt</span><span class=p>(</span><span class=n>tcp</span><span class=o>-&gt;</span><span class=n>io_watcher</span><span class=p>.</span><span class=n>fd</span><span class=p>,</span><span class=w> </span><span class=n>SOL_SOCKET</span><span class=p>,</span><span class=w> </span><span class=n>SO_REUSEADDR</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>on</span><span class=p>,</span><span class=w> </span><span class=k>sizeof</span><span class=p>(</span><span class=n>on</span><span class=p>)))</span><span class=w>  </span>
<span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>UV__ERR</span><span class=p>(</span><span class=n>errno</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=n>errno</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 执行bind  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>bind</span><span class=p>(</span><span class=n>tcp</span><span class=o>-&gt;</span><span class=n>io_watcher</span><span class=p>.</span><span class=n>fd</span><span class=p>,</span><span class=w> </span><span class=n>addr</span><span class=p>,</span><span class=w> </span><span class=n>addrlen</span><span class=p>)</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>errno</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>EADDRINUSE</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>errno</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>EAFNOSUPPORT</span><span class=p>)</span><span class=w>  </span>
<span class=w>          </span><span class=k>return</span><span class=w> </span><span class=n>UV_EINVAL</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>UV__ERR</span><span class=p>(</span><span class=n>errno</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// bind是否出错  </span>
<span class=w>      </span><span class=n>tcp</span><span class=o>-&gt;</span><span class=n>delayed_error</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>UV__ERR</span><span class=p>(</span><span class=n>errno</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 打上已经执行了bind的标记  </span>
<span class=w>      </span><span class=n>tcp</span><span class=o>-&gt;</span><span class=n>flags</span><span class=w> </span><span class=o>|=</span><span class=w> </span><span class=n>UV_HANDLE_BOUND</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>addr</span><span class=o>-&gt;</span><span class=n>sa_family</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>AF_INET6</span><span class=p>)</span><span class=w>  </span>
<span class=w>        </span><span class=n>tcp</span><span class=o>-&gt;</span><span class=n>flags</span><span class=w> </span><span class=o>|=</span><span class=w> </span><span class=n>UV_HANDLE_IPV6</span><span class=p>;</span><span class=w>  </span>

<span class=w>      </span><span class=k>return</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>  </span>
<span class=w>    </span><span class=p>}</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>执行完bind后，会继续执行listen，我们接着看listen函数做了什么。我们直接看tcp_wrap.cc的Listen。</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>TCPWrap::Listen</span><span class=p>(</span><span class=k>const</span><span class=w> </span><span class=n>FunctionCallbackInfo</span><span class=o>&lt;</span><span class=n>Value</span><span class=o>&gt;&amp;</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=n>TCPWrap</span><span class=o>*</span><span class=w> </span><span class=n>wrap</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=n>ASSIGN_OR_RETURN_UNWRAP</span><span class=p>(</span><span class=o>&amp;</span><span class=n>wrap</span><span class=p>,</span><span class=w>  </span>
<span class=w>                  </span><span class=n>args</span><span class=p>.</span><span class=n>Holder</span><span class=p>(),</span><span class=w>  </span>
<span class=w>                  </span><span class=n>args</span><span class=p>.</span><span class=n>GetReturnValue</span><span class=p>().</span><span class=n>Set</span><span class=p>(</span><span class=n>UV_EBADF</span><span class=p>));</span><span class=w>  </span>
<span class=w>      </span><span class=kt>int</span><span class=w> </span><span class=n>backlog</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>Int32Value</span><span class=p>();</span><span class=w>  </span>
<span class=w>      </span><span class=kt>int</span><span class=w> </span><span class=n>err</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>uv_listen</span><span class=p>(</span><span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=n>uv_stream_t</span><span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>wrap</span><span class=o>-&gt;</span><span class=n>handle_</span><span class=p>),</span><span class=w>  </span>
<span class=w>                  </span><span class=n>backlog</span><span class=p>,</span><span class=w>  </span>
<span class=w>                  </span><span class=n>OnConnection</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=n>args</span><span class=p>.</span><span class=n>GetReturnValue</span><span class=p>().</span><span class=n>Set</span><span class=p>(</span><span class=n>err</span><span class=p>);</span><span class=w>  </span>
<span class=w>    </span><span class=p>}</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>C++层几乎是透传到Libuv，Libuv的内容我们不再具体展开，当有三次握手的连接完成时，会执行OnConnection</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span>
<span class=normal>24</span>
<span class=normal>25</span>
<span class=normal>26</span>
<span class=normal>27</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=k>template</span><span class=w> </span><span class=o>&lt;</span><span class=k>typename</span><span class=w> </span><span class=nc>WrapType</span><span class=p>,</span><span class=w> </span><span class=k>typename</span><span class=w> </span><span class=nc>UVType</span><span class=o>&gt;</span><span class=w>  </span>
<span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=n>ConnectionWrap</span><span class=o>&lt;</span><span class=n>WrapType</span><span class=p>,</span><span class=w> </span><span class=n>UVType</span><span class=o>&gt;::</span><span class=n>OnConnection</span><span class=p>(</span><span class=n>uv_stream_t</span><span class=o>*</span><span class=w> </span><span class=n>handle</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>status</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// TCPWrap                   </span>
<span class=w>      </span><span class=n>WrapType</span><span class=o>*</span><span class=w> </span><span class=n>wrap_data</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>static_cast</span><span class=o>&lt;</span><span class=n>WrapType</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>handle</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=n>Environment</span><span class=o>*</span><span class=w> </span><span class=n>env</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>wrap_data</span><span class=o>-&gt;</span><span class=n>env</span><span class=p>();</span><span class=w>  </span>
<span class=w>      </span><span class=n>HandleScope</span><span class=w> </span><span class=nf>handle_scope</span><span class=p>(</span><span class=n>env</span><span class=o>-&gt;</span><span class=n>isolate</span><span class=p>());</span><span class=w>  </span>
<span class=w>      </span><span class=n>Context</span><span class=o>::</span><span class=n>Scope</span><span class=w> </span><span class=nf>context_scope</span><span class=p>(</span><span class=n>env</span><span class=o>-&gt;</span><span class=n>context</span><span class=p>());</span><span class=w>  </span>
<span class=w>      </span><span class=n>Local</span><span class=o>&lt;</span><span class=n>Value</span><span class=o>&gt;</span><span class=w> </span><span class=n>argv</span><span class=p>[]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=n>Integer</span><span class=o>::</span><span class=n>New</span><span class=p>(</span><span class=n>env</span><span class=o>-&gt;</span><span class=n>isolate</span><span class=p>(),</span><span class=w> </span><span class=n>status</span><span class=p>),</span><span class=w>  </span>
<span class=w>        </span><span class=n>Undefined</span><span class=p>(</span><span class=n>env</span><span class=o>-&gt;</span><span class=n>isolate</span><span class=p>())</span><span class=w>  </span>
<span class=w>      </span><span class=p>};</span><span class=w>  </span>

<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>status</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span>
<span class=w>        </span><span class=c1>// 新建一个表示和客户端通信的对象,必填TCPWrap对象  </span>
<span class=w>        </span><span class=n>Local</span><span class=o>&lt;</span><span class=n>Object</span><span class=o>&gt;</span><span class=w> </span><span class=n>client_obj</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>WrapType</span><span class=o>::</span><span class=n>Instantiate</span><span class=p>(</span><span class=n>env</span><span class=p>,</span><span class=n>wrap_data</span><span class=p>,</span><span class=n>WrapType</span><span class=o>::</span><span class=n>SOCKET</span><span class=p>);</span><span class=w>  </span>
<span class=w>        </span><span class=n>WrapType</span><span class=o>*</span><span class=w> </span><span class=n>wrap</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// 解包出一个TCPWrap对象存到wrap  </span>
<span class=w>        </span><span class=n>ASSIGN_OR_RETURN_UNWRAP</span><span class=p>(</span><span class=o>&amp;</span><span class=n>wrap</span><span class=p>,</span><span class=w> </span><span class=n>client_obj</span><span class=p>);</span><span class=w>  </span>
<span class=w>        </span><span class=n>uv_stream_t</span><span class=o>*</span><span class=w> </span><span class=n>client_handle</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>reinterpret_cast</span><span class=o>&lt;</span><span class=n>uv_stream_t</span><span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>wrap</span><span class=o>-&gt;</span><span class=n>handle_</span><span class=p>);</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// 把通信fd存储到client_handle中  </span>
<span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>uv_accept</span><span class=p>(</span><span class=n>handle</span><span class=p>,</span><span class=w> </span><span class=n>client_handle</span><span class=p>))</span><span class=w>  </span>
<span class=w>          </span><span class=k>return</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=n>argv</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>client_obj</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 回调上层的onconnection函数  </span>
<span class=w>      </span><span class=n>wrap_data</span><span class=o>-&gt;</span><span class=n>MakeCallback</span><span class=p>(</span><span class=n>env</span><span class=o>-&gt;</span><span class=n>onconnection_string</span><span class=p>(),</span><span class=w> </span><span class=n>arraysize</span><span class=p>(</span><span class=n>argv</span><span class=p>),</span><span class=w> </span><span class=n>argv</span><span class=p>);</span><span class=w>  </span>
<span class=w>    </span><span class=p>}</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>当建立了新连接时，操作系统会新建一个socket表示，同样，在Node.js层，也会新建一个对应的对象表示和客户端的通信，接着我们看JS层回调。</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span>
<span class=normal>24</span>
<span class=normal>25</span>
<span class=normal>26</span>
<span class=normal>27</span>
<span class=normal>28</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=c1>// clientHandle代表一个和客户端建立TCP连接的实体  </span>
<span class=w>    </span><span class=kd>function</span><span class=w> </span><span class=nx>onconnection</span><span class=p>(</span><span class=nx>err</span><span class=p>,</span><span class=w> </span><span class=nx>clientHandle</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=kd>var</span><span class=w> </span><span class=nx>handle</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>this</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=kd>var</span><span class=w> </span><span class=nx>self</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>handle</span><span class=p>.</span><span class=nx>owner</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 错误则触发错误事件  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>err</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=nx>self</span><span class=p>.</span><span class=nx>emit</span><span class=p>(</span><span class=s1>&#39;error&#39;</span><span class=p>,</span><span class=w> </span><span class=nx>errnoException</span><span class=p>(</span><span class=nx>err</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;accept&#39;</span><span class=p>));</span><span class=w>  </span>
<span class=w>        </span><span class=k>return</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 建立过多，关掉  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=nx>self</span><span class=p>.</span><span class=nx>maxConnections</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nx>self</span><span class=p>.</span><span class=nx>_connections</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=nx>self</span><span class=p>.</span><span class=nx>maxConnections</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=nx>clientHandle</span><span class=p>.</span><span class=nx>close</span><span class=p>();</span><span class=w>  </span>
<span class=w>        </span><span class=k>return</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>      </span><span class=c1>//新建一个socket用于通信  </span>
<span class=w>      </span><span class=kd>var</span><span class=w> </span><span class=nx>socket</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=ow>new</span><span class=w> </span><span class=nx>Socket</span><span class=p>({</span><span class=w>  </span>
<span class=w>        </span><span class=nx>handle</span><span class=o>:</span><span class=w> </span><span class=nx>clientHandle</span><span class=p>,</span><span class=w>  </span>
<span class=w>        </span><span class=nx>allowHalfOpen</span><span class=o>:</span><span class=w> </span><span class=nx>self</span><span class=p>.</span><span class=nx>allowHalfOpen</span><span class=p>,</span><span class=w>  </span>
<span class=w>        </span><span class=nx>pauseOnCreate</span><span class=o>:</span><span class=w> </span><span class=nx>self</span><span class=p>.</span><span class=nx>pauseOnConnect</span><span class=w>  </span>
<span class=w>      </span><span class=p>});</span><span class=w>  </span>
<span class=w>      </span><span class=nx>socket</span><span class=p>.</span><span class=nx>readable</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>socket</span><span class=p>.</span><span class=nx>writable</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 服务器的连接数加一  </span>
<span class=w>      </span><span class=nx>self</span><span class=p>.</span><span class=nx>_connections</span><span class=o>++</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=nx>socket</span><span class=p>.</span><span class=nx>server</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>self</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=nx>socket</span><span class=p>.</span><span class=nx>_server</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>self</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 触发用户层连接事件  </span>
<span class=w>      </span><span class=nx>self</span><span class=p>.</span><span class=nx>emit</span><span class=p>(</span><span class=s1>&#39;connection&#39;</span><span class=p>,</span><span class=w> </span><span class=nx>socket</span><span class=p>);</span><span class=w> </span>
<span class=w>    </span><span class=p>}</span><span class=w> </span>
</code></pre></div></td></tr></table></div> <p>在JS层也会封装一个Socket对象用于管理和客户端的通信，接着触发connection事件。剩下的事情就是应用层处理了。</p> <h2 id=173-keepalive>17.3 keepalive<a class=headerlink href=#173-keepalive title="Permanent link">&para;</a></h2> <p>本节分析基于TCP层的长连接问题，相比应用层HTTP协议的长连接，TCP层提供的功能更多。TCP层定义了三个配置。<br> 1 多久没有收到数据包，则开始发送探测包。<br> 2 每隔多久，再次发送探测包。<br> 3 发送多少个探测包后，就断开连接。<br> 我们看Linux内核代码里提供的配置。</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=c1>// 多久没有收到数据就发起探测包  </span>
<span class=w>    </span><span class=cp>#define TCP_KEEPALIVE_TIME  (120*60*HZ) </span><span class=cm>/* two hours */</span><span class=cp>  </span>
<span class=w>    </span><span class=c1>// 探测次数  </span>
<span class=w>    </span><span class=cp>#define TCP_KEEPALIVE_PROBES  9   </span><span class=cm>/* Max of 9 keepalive probes*/</span><span class=cp>  </span>
<span class=w>    </span><span class=c1>// 每隔多久探测一次  </span>
<span class=w>    </span><span class=cp>#define TCP_KEEPALIVE_INTVL (75*HZ)  </span>
</code></pre></div></td></tr></table></div> <p>这是Linux提供的默认值。下面再看看阈值</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=cp>#define MAX_TCP_KEEPIDLE    32767  </span>
<span class=w>    </span><span class=cp>#define MAX_TCP_KEEPINTVL   32767  </span>
<span class=w>    </span><span class=cp>#define MAX_TCP_KEEPCNT     127  </span>
</code></pre></div></td></tr></table></div> <p>这三个配置和上面三个一一对应。是上面三个配置的阈值。我们看一下Node.js中keep-alive的使用。 socket.setKeepAlive([enable][, initialDelay])<br> enable：是否开启keep-alive，Linux下默认是不开启的。 initialDelay：多久没有收到数据包就开始发送探测包。 接着我们看看这个API在Libuv中的实现。</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=nf>uv__tcp_keepalive</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>fd</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>on</span><span class=p>,</span><span class=w> </span><span class=kt>unsigned</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>delay</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>    </span>
<span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>setsockopt</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span><span class=w> </span><span class=n>SOL_SOCKET</span><span class=p>,</span><span class=w> </span><span class=n>SO_KEEPALIVE</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>on</span><span class=p>,</span><span class=w> </span><span class=k>sizeof</span><span class=p>(</span><span class=n>on</span><span class=p>)))</span><span class=w>   </span>
<span class=w>          </span><span class=k>return</span><span class=w> </span><span class=n>UV__ERR</span><span class=p>(</span><span class=n>errno</span><span class=p>);</span><span class=w>    </span>
<span class=w>        </span><span class=c1>// Linux定义了这个宏    </span>
<span class=w>        </span><span class=cp>#ifdef TCP_KEEPIDLE    </span>
<span class=w>          </span><span class=cm>/*  </span>
<span class=cm>              on是1才会设置，所以如果我们先开启keep-alive，并且设置delay，  </span>
<span class=cm>              然后关闭keep-alive的时候，是不会修改之前修改过的配置的。  </span>
<span class=cm>              因为这个配置在keep-alive关闭的时候是没用的  </span>
<span class=cm>          */</span><span class=w>    </span>
<span class=w>          </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>on</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>setsockopt</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span><span class=w> </span><span class=n>IPPROTO_TCP</span><span class=p>,</span><span class=w> </span><span class=n>TCP_KEEPIDLE</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>delay</span><span class=p>,</span><span class=w> </span><span class=k>sizeof</span><span class=p>(</span><span class=n>delay</span><span class=p>)))</span><span class=w>    </span>
<span class=w>            </span><span class=k>return</span><span class=w> </span><span class=n>UV__ERR</span><span class=p>(</span><span class=n>errno</span><span class=p>);</span><span class=w>    </span>
<span class=w>        </span><span class=cp>#endif    </span>

<span class=w>        </span><span class=k>return</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>    </span>
<span class=w>    </span><span class=p>}</span><span class=w>    </span>
</code></pre></div></td></tr></table></div> <p>我们看到Libuv调用了同一个系统函数两次。我们分别看一下这个函数的意义。参考Linux2.6.13.1的代码。</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=c1>// net\socket.c    </span>
<span class=w>    </span><span class=n>asmlinkage</span><span class=w> </span><span class=kt>long</span><span class=w> </span><span class=n>sys_setsockopt</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>fd</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>level</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>optname</span><span class=p>,</span><span class=w> </span><span class=kt>char</span><span class=w> </span><span class=n>__user</span><span class=w> </span><span class=o>*</span><span class=n>optval</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>optlen</span><span class=p>)</span><span class=w>    </span>
<span class=w>    </span><span class=p>{</span><span class=w>    </span>
<span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>err</span><span class=p>;</span><span class=w>    </span>
<span class=w>        </span><span class=k>struct</span><span class=w> </span><span class=nc>socket</span><span class=w> </span><span class=o>*</span><span class=n>sock</span><span class=p>;</span><span class=w>    </span>

<span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>((</span><span class=n>sock</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>sockfd_lookup</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>err</span><span class=p>))</span><span class=o>!=</span><span class=nb>NULL</span><span class=p>)</span><span class=w>    </span>
<span class=w>        </span><span class=p>{</span><span class=w>    </span>
<span class=w>            </span><span class=p>...</span><span class=w>    </span>
<span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>level</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>SOL_SOCKET</span><span class=p>)</span><span class=w>    </span>
<span class=w>                </span><span class=n>err</span><span class=o>=</span><span class=n>sock_setsockopt</span><span class=p>(</span><span class=n>sock</span><span class=p>,</span><span class=n>level</span><span class=p>,</span><span class=n>optname</span><span class=p>,</span><span class=n>optval</span><span class=p>,</span><span class=n>optlen</span><span class=p>);</span><span class=w>    </span>
<span class=w>            </span><span class=k>else</span><span class=w>    </span>
<span class=w>              </span><span class=n>err</span><span class=o>=</span><span class=n>sock</span><span class=o>-&gt;</span><span class=n>ops</span><span class=o>-&gt;</span><span class=n>setsockopt</span><span class=p>(</span><span class=n>sock</span><span class=p>,</span><span class=w> </span><span class=n>level</span><span class=p>,</span><span class=w> </span><span class=n>optname</span><span class=p>,</span><span class=w> </span><span class=n>optval</span><span class=p>,</span><span class=w> </span><span class=n>optlen</span><span class=p>);</span><span class=w>    </span>
<span class=w>            </span><span class=n>sockfd_put</span><span class=p>(</span><span class=n>sock</span><span class=p>);</span><span class=w>    </span>
<span class=w>        </span><span class=p>}</span><span class=w>    </span>
<span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>err</span><span class=p>;</span><span class=w>    </span>
<span class=w>    </span><span class=p>}</span><span class=w>    </span>
</code></pre></div></td></tr></table></div> <p>当level是SOL_SOCKET代表修改的socket层面的配置。IPPROTO_TCP是修改TCP层的配置（该版本代码里是SOL_TCP）。我们先看SOL_SOCKET层面的。</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=c1>// net\socket.c -&gt; net\core\sock.c -&gt; net\ipv4\tcp_timer.c    </span>
<span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=nf>sock_setsockopt</span><span class=p>(</span><span class=k>struct</span><span class=w> </span><span class=nc>socket</span><span class=w> </span><span class=o>*</span><span class=n>sock</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>level</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>optname</span><span class=p>,</span><span class=w>    </span>
<span class=w>                </span><span class=kt>char</span><span class=w> </span><span class=n>__user</span><span class=w> </span><span class=o>*</span><span class=n>optval</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>optlen</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>    </span>
<span class=w>        </span><span class=p>...</span><span class=w>    </span>
<span class=w>        </span><span class=k>case</span><span class=w> </span><span class=no>SO_KEEPALIVE</span><span class=p>:</span><span class=w>    </span>

<span class=w>                </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>sk</span><span class=o>-&gt;</span><span class=n>sk_protocol</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>IPPROTO_TCP</span><span class=p>)</span><span class=w>    </span>
<span class=w>                    </span><span class=n>tcp_set_keepalive</span><span class=p>(</span><span class=n>sk</span><span class=p>,</span><span class=w> </span><span class=n>valbool</span><span class=p>);</span><span class=w>    </span>
<span class=w>                </span><span class=c1>// 设置SOCK_KEEPOPEN标记位1    </span>
<span class=w>                </span><span class=n>sock_valbool_flag</span><span class=p>(</span><span class=n>sk</span><span class=p>,</span><span class=w> </span><span class=n>SOCK_KEEPOPEN</span><span class=p>,</span><span class=w> </span><span class=n>valbool</span><span class=p>);</span><span class=w>    </span>
<span class=w>                </span><span class=k>break</span><span class=p>;</span><span class=w>    </span>
<span class=w>        </span><span class=p>...</span><span class=w>    </span>
<span class=w>    </span><span class=p>}</span><span class=w>   </span>
</code></pre></div></td></tr></table></div> <p>sock_setcsockopt首先调用了tcp_set_keepalive函数，然后给对应socket的SOCK_KEEPOPEN字段打上标记（0或者1表示开启还是关闭）。接下来我们看tcp_set_keepalive </p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>tcp_set_keepalive</span><span class=p>(</span><span class=k>struct</span><span class=w> </span><span class=nc>sock</span><span class=w> </span><span class=o>*</span><span class=n>sk</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>val</span><span class=p>)</span><span class=w>    </span>
<span class=w>    </span><span class=p>{</span><span class=w>    </span>
<span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>((</span><span class=mi>1</span><span class=w> </span><span class=o>&lt;&lt;</span><span class=w> </span><span class=n>sk</span><span class=o>-&gt;</span><span class=n>sk_state</span><span class=p>)</span><span class=w> </span><span class=o>&amp;</span><span class=w> </span><span class=p>(</span><span class=n>TCPF_CLOSE</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>TCPF_LISTEN</span><span class=p>))</span><span class=w>    </span>
<span class=w>            </span><span class=k>return</span><span class=p>;</span><span class=w>    </span>
<span class=w>        </span><span class=cm>/*  </span>
<span class=cm>            如果val是1并且之前是0（没开启）那么就开启计时，超时后发送探测包，  </span>
<span class=cm>            如果之前是1，val又是1，则忽略，所以重复设置是无害的  </span>
<span class=cm>        */</span><span class=w>    </span>
<span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>val</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=o>!</span><span class=n>sock_flag</span><span class=p>(</span><span class=n>sk</span><span class=p>,</span><span class=w> </span><span class=n>SOCK_KEEPOPEN</span><span class=p>))</span><span class=w>    </span>
<span class=w>            </span><span class=n>tcp_reset_keepalive_timer</span><span class=p>(</span><span class=n>sk</span><span class=p>,</span><span class=w> </span><span class=n>keepalive_time_when</span><span class=p>(</span><span class=n>tcp_sk</span><span class=p>(</span><span class=n>sk</span><span class=p>)));</span><span class=w>    </span>
<span class=w>        </span><span class=k>else</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>val</span><span class=p>)</span><span class=w>    </span>
<span class=w>            </span><span class=c1>// val是0表示关闭，则清除定时器，就不发送探测包了    </span>
<span class=w>            </span><span class=n>tcp_delete_keepalive_timer</span><span class=p>(</span><span class=n>sk</span><span class=p>);</span><span class=w>    </span>
<span class=w>    </span><span class=p>}</span><span class=w>   </span>
</code></pre></div></td></tr></table></div> <p>我们看看超时后的逻辑。 </p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span>
<span class=normal>24</span>
<span class=normal>25</span>
<span class=normal>26</span>
<span class=normal>27</span>
<span class=normal>28</span>
<span class=normal>29</span>
<span class=normal>30</span>
<span class=normal>31</span>
<span class=normal>32</span>
<span class=normal>33</span>
<span class=normal>34</span>
<span class=normal>35</span>
<span class=normal>36</span>
<span class=normal>37</span>
<span class=normal>38</span>
<span class=normal>39</span>
<span class=normal>40</span>
<span class=normal>41</span>
<span class=normal>42</span>
<span class=normal>43</span>
<span class=normal>44</span>
<span class=normal>45</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=c1>// 多久没有收到数据包则发送第一个探测包      </span>
<span class=w>    </span><span class=k>static</span><span class=w> </span><span class=kr>inline</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>keepalive_time_when</span><span class=p>(</span><span class=k>const</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=nc>tcp_sock</span><span class=w> </span><span class=o>*</span><span class=n>tp</span><span class=p>)</span><span class=w>      </span>
<span class=w>    </span><span class=p>{</span><span class=w>      </span>
<span class=w>        </span><span class=c1>// 用户设置的（TCP_KEEPIDLE）和系统默认的      </span>
<span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>tp</span><span class=o>-&gt;</span><span class=n>keepalive_time</span><span class=w> </span><span class=o>?</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>sysctl_tcp_keepalive_time</span><span class=p>;</span><span class=w>      </span>
<span class=w>    </span><span class=p>}</span><span class=w>      </span>
<span class=w>    </span><span class=c1>// 隔多久发送一个探测包      </span>
<span class=w>    </span><span class=k>static</span><span class=w> </span><span class=kr>inline</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=nf>keepalive_intvl_when</span><span class=p>(</span><span class=k>const</span><span class=w> </span><span class=k>struct</span><span class=w> </span><span class=nc>tcp_sock</span><span class=w> </span><span class=o>*</span><span class=n>tp</span><span class=p>)</span><span class=w>      </span>
<span class=w>    </span><span class=p>{</span><span class=w>      </span>
<span class=w>        </span><span class=k>return</span><span class=w> </span><span class=n>tp</span><span class=o>-&gt;</span><span class=n>keepalive_intvl</span><span class=w> </span><span class=o>?</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>sysctl_tcp_keepalive_intvl</span><span class=p>;</span><span class=w>      </span>
<span class=w>    </span><span class=p>}</span><span class=w>      </span>

<span class=w>    </span><span class=k>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>tcp_keepalive_timer</span><span class=w> </span><span class=p>(</span><span class=kt>unsigned</span><span class=w> </span><span class=kt>long</span><span class=w> </span><span class=n>data</span><span class=p>)</span><span class=w>      </span>
<span class=w>    </span><span class=p>{</span><span class=w>      </span>
<span class=w>    </span><span class=p>...</span><span class=w>      </span>
<span class=w>    </span><span class=c1>// 多久没有收到数据包了      </span>
<span class=w>    </span><span class=n>elapsed</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>tcp_time_stamp</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>tp</span><span class=o>-&gt;</span><span class=n>rcv_tstamp</span><span class=p>;</span><span class=w>      </span>
<span class=w>        </span><span class=c1>// 是否超过了阈值      </span>
<span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>elapsed</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=n>keepalive_time_when</span><span class=p>(</span><span class=n>tp</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>      </span>
<span class=w>            </span><span class=c1>// 发送的探测包个数达到阈值，发送重置包      </span>
<span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>((</span><span class=o>!</span><span class=n>tp</span><span class=o>-&gt;</span><span class=n>keepalive_probes</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>tp</span><span class=o>-&gt;</span><span class=n>probes_out</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=n>sysctl_tcp_keepalive_probes</span><span class=p>)</span><span class=w> </span><span class=o>||</span><span class=w>      </span>
<span class=w>                 </span><span class=p>(</span><span class=n>tp</span><span class=o>-&gt;</span><span class=n>keepalive_probes</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>tp</span><span class=o>-&gt;</span><span class=n>probes_out</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=n>tp</span><span class=o>-&gt;</span><span class=n>keepalive_probes</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>      </span>
<span class=w>                </span><span class=n>tcp_send_active_reset</span><span class=p>(</span><span class=n>sk</span><span class=p>,</span><span class=w> </span><span class=n>GFP_ATOMIC</span><span class=p>);</span><span class=w>      </span>
<span class=w>                </span><span class=n>tcp_write_err</span><span class=p>(</span><span class=n>sk</span><span class=p>);</span><span class=w>      </span>
<span class=w>                </span><span class=k>goto</span><span class=w> </span><span class=n>out</span><span class=p>;</span><span class=w>      </span>
<span class=w>            </span><span class=p>}</span><span class=w>      </span>
<span class=w>            </span><span class=c1>// 发送探测包，并计算下一个探测包的发送时间（超时时间）      </span>
<span class=w>            </span><span class=n>tcp_write_wakeup</span><span class=p>(</span><span class=n>sk</span><span class=p>)</span><span class=w>      </span>
<span class=w>                </span><span class=n>tp</span><span class=o>-&gt;</span><span class=n>probes_out</span><span class=o>++</span><span class=p>;</span><span class=w>      </span>
<span class=w>                </span><span class=n>elapsed</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>keepalive_intvl_when</span><span class=p>(</span><span class=n>tp</span><span class=p>);</span><span class=w>      </span>
<span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>      </span>
<span class=w>            </span><span class=cm>/*   </span>
<span class=cm>                还没到期则重新计算到期时间，收到数据包的时候应该会重置定时器，   </span>
<span class=cm>                所以执行该函数说明的确是超时了，按理说不会进入这里。   </span>
<span class=cm>            */</span><span class=w>      </span>
<span class=w>            </span><span class=n>elapsed</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>keepalive_time_when</span><span class=p>(</span><span class=n>tp</span><span class=p>)</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>elapsed</span><span class=p>;</span><span class=w>      </span>
<span class=w>        </span><span class=p>}</span><span class=w>      </span>

<span class=w>        </span><span class=n>TCP_CHECK_TIMER</span><span class=p>(</span><span class=n>sk</span><span class=p>);</span><span class=w>      </span>
<span class=w>        </span><span class=n>sk_stream_mem_reclaim</span><span class=p>(</span><span class=n>sk</span><span class=p>);</span><span class=w>      </span>

<span class=w>    </span><span class=nl>resched</span><span class=p>:</span><span class=w>      </span>
<span class=w>        </span><span class=c1>// 重新设置定时器      </span>
<span class=w>        </span><span class=n>tcp_reset_keepalive_timer</span><span class=w> </span><span class=p>(</span><span class=n>sk</span><span class=p>,</span><span class=w> </span><span class=n>elapsed</span><span class=p>);</span><span class=w>      </span>
<span class=w>    </span><span class=p>...</span><span class=w>     </span>
</code></pre></div></td></tr></table></div> <p>所以在SOL_SOCKET层面是设置是否开启keep-alive机制。如果开启了，就会设置定时器，超时的时候就会发送探测包。但是我们发现，SOL_SOCKET只是设置了是否开启探测机制，并没有定义上面三个配置的值，所以系统会使用默认值进行心跳机制（如果我们设置了开启keep-alive的话）。这就是为什么Libuv调了两次setsockopt函数。第二次的调用设置了就是上面三个配置中的第一个（后面两个也可以设置，不过Libuv没有提供接口，可以自己调用setsockopt设置）。那么我们来看一下Libuv的第二次调用setsockopt是做了什么。我们直接看TCP层的实现。</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=c1>// net\ipv4\tcp.c    </span>
<span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=nf>tcp_setsockopt</span><span class=p>(</span><span class=k>struct</span><span class=w> </span><span class=nc>sock</span><span class=w> </span><span class=o>*</span><span class=n>sk</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>level</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>optname</span><span class=p>,</span><span class=w> </span><span class=kt>char</span><span class=w> </span><span class=n>__user</span><span class=w> </span><span class=o>*</span><span class=n>optval</span><span class=p>,</span><span class=kt>int</span><span class=w> </span><span class=n>optlen</span><span class=p>)</span><span class=w>    </span>
<span class=w>    </span><span class=p>{</span><span class=w>    </span>
<span class=w>        </span><span class=p>...</span><span class=w>    </span>
<span class=w>        </span><span class=k>case</span><span class=w> </span><span class=no>TCP_KEEPIDLE</span><span class=p>:</span><span class=w>    </span>
<span class=w>            </span><span class=c1>// 修改多久没有收到数据包则发送探测包的配置    </span>
<span class=w>            </span><span class=n>tp</span><span class=o>-&gt;</span><span class=n>keepalive_time</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>val</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=n>HZ</span><span class=p>;</span><span class=w>    </span>
<span class=w>                </span><span class=c1>// 是否开启了keep-alive机制    </span>
<span class=w>                </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>sock_flag</span><span class=p>(</span><span class=n>sk</span><span class=p>,</span><span class=w> </span><span class=n>SOCK_KEEPOPEN</span><span class=p>)</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w>    </span>
<span class=w>                    </span><span class=o>!</span><span class=p>((</span><span class=mi>1</span><span class=w> </span><span class=o>&lt;&lt;</span><span class=w> </span><span class=n>sk</span><span class=o>-&gt;</span><span class=n>sk_state</span><span class=p>)</span><span class=w> </span><span class=o>&amp;</span><span class=w>    </span>
<span class=w>                      </span><span class=p>(</span><span class=n>TCPF_CLOSE</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=n>TCPF_LISTEN</span><span class=p>)))</span><span class=w> </span><span class=p>{</span><span class=w>    </span>
<span class=w>                    </span><span class=c1>// 当前时间减去上次收到数据包的时候，即多久没有收到数据包了    </span>
<span class=w>                    </span><span class=n>__u32</span><span class=w> </span><span class=n>elapsed</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>tcp_time_stamp</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>tp</span><span class=o>-&gt;</span><span class=n>rcv_tstamp</span><span class=p>;</span><span class=w>    </span>
<span class=w>                    </span><span class=c1>// 算出还要多久可以发送探测包，还是可以直接发（已经触发了）    </span>
<span class=w>                    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>tp</span><span class=o>-&gt;</span><span class=n>keepalive_time</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>elapsed</span><span class=p>)</span><span class=w>    </span>
<span class=w>                        </span><span class=n>elapsed</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>tp</span><span class=o>-&gt;</span><span class=n>keepalive_time</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>elapsed</span><span class=p>;</span><span class=w>    </span>
<span class=w>                    </span><span class=k>else</span><span class=w>    </span>
<span class=w>                        </span><span class=n>elapsed</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>    </span>
<span class=w>                    </span><span class=c1>// 设置定时器    </span>
<span class=w>                    </span><span class=n>tcp_reset_keepalive_timer</span><span class=p>(</span><span class=n>sk</span><span class=p>,</span><span class=w> </span><span class=n>elapsed</span><span class=p>);</span><span class=w>    </span>
<span class=w>                </span><span class=p>}</span><span class=w>       </span>
<span class=w>            </span><span class=p>...</span><span class=w>    </span>
<span class=w>    </span><span class=p>}</span><span class=w>    </span>
</code></pre></div></td></tr></table></div> <p>该函数首先修改配置，然后判断是否开启了keep-alive的机制，如果开启了，则重新设置定时器，超时的时候就会发送探测包。但是有一个问题是，心跳机制并不是什么时候都好使，如果两端都没有数据来往时，心跳机制能很好地工作，但是一旦本端有数据发送的时候，它就会抑制心跳机制。我们看一下Linux内核5.7.7的一段相关代码，如图17-3所示。<br> <img alt src="https://img-blog.csdnimg.cn/3a9bf6abbf7c4035b774ee2e1396a254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RIRUFOQVJLSA==,size_16,color_FFFFFF,t_70"><br> 图17-3<br> 上面这一段是心跳机制中，定时器超时时，执行的一段逻辑，我们只需要关注红色框里的代码。一般来说，心跳定时器超时，操作系统会发送一个新的心跳包，但是如果发送队列里还有数据没有发送，那么操作系统会优先发送。或者发送出去的没有ack，也会优先触发重传。这时候心跳机制就失效了。对于这个问题，Linux提供了另一个属性TCP_USER_TIMEOUT。这个属性的功能是，发送了数据，多久没有收到ack后，操作系统就认为这个连接断开了。看一下相关代码，如图17-4所示。<br> <img alt src="https://img-blog.csdnimg.cn/39db257731f74caaad5da6449fc46f8e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RIRUFOQVJLSA==,size_16,color_FFFFFF,t_70"><br> 图17-4<br> 下面是设置阈值的代码，如图17-5所示。<br> <img alt src="https://img-blog.csdnimg.cn/1930c077bc48463f9539d353c7c3bbc6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RIRUFOQVJLSA==,size_16,color_FFFFFF,t_70"><br> 图17-5<br> 这是超时时判断是否断开连接的代码。我们看到有两个情况下操作系统会认为连接断开了。<br> 1 设置了TCP_USER_TIMEOUT时，如果发送包数量大于1并且当前时间距离上次收到包的时间间隔已经达到阈值。<br> 2 没有设置TCP_USER_TIMEOUT，但是心跳包发送数量达到阈值。<br> 所以我们可以同时设置这两个属性。保证心跳机制可以正常运行， Node.js的keep-alive有两个层面的内容，第一个是是否开启，第二个是开启后，使用的配置。Node.js的setKeepAlive就是做了这两件事情。只不过它只支持修改一个配置。Node.js只支持TCP_KEEPALIVE_TIME。另外我们可以通过一下代码判断配置的值。</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span>
<span class=normal>24</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=n>include</span><span class=w> </span><span class=o>&lt;</span><span class=n>stdio</span><span class=p>.</span><span class=n>h</span><span class=o>&gt;</span><span class=w>    </span>
<span class=w>    </span><span class=cp>#include</span><span class=w> </span><span class=cpf>&lt;netinet/tcp.h&gt;</span><span class=c1>         </span>

<span class=w>    </span><span class=kt>int</span><span class=w> </span><span class=n>main</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>argc</span><span class=p>,</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=kt>char</span><span class=w> </span><span class=o>*</span><span class=n>argv</span><span class=p>[])</span><span class=w>    </span>
<span class=w>    </span><span class=p>{</span><span class=w>    </span>
<span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>sockfd</span><span class=p>;</span><span class=w>    </span>
<span class=w>        </span><span class=kt>int</span><span class=w> </span><span class=n>optval</span><span class=p>;</span><span class=w>    </span>
<span class=w>        </span><span class=kt>socklen_t</span><span class=w> </span><span class=n>optlen</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>sizeof</span><span class=p>(</span><span class=n>optval</span><span class=p>);</span><span class=w>    </span>

<span class=w>        </span><span class=n>sockfd</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>socket</span><span class=p>(</span><span class=n>AF_INET</span><span class=p>,</span><span class=w> </span><span class=n>SOCK_STREAM</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>);</span><span class=w>    </span>
<span class=w>        </span><span class=n>getsockopt</span><span class=p>(</span><span class=n>sockfd</span><span class=p>,</span><span class=w> </span><span class=n>SOL_SOCKET</span><span class=p>,</span><span class=w> </span><span class=n>SO_KEEPALIVE</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>optval</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>optlen</span><span class=p>);</span><span class=w>    </span>
<span class=w>        </span><span class=n>printf</span><span class=p>(</span><span class=s>&quot;默认是否开启keep-alive：%d </span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span><span class=w> </span><span class=n>optval</span><span class=p>);</span><span class=w>    </span>

<span class=w>        </span><span class=n>getsockopt</span><span class=p>(</span><span class=n>sockfd</span><span class=p>,</span><span class=w> </span><span class=n>SOL_TCP</span><span class=p>,</span><span class=w> </span><span class=n>TCP_KEEPIDLE</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>optval</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>optlen</span><span class=p>);</span><span class=w>    </span>
<span class=w>        </span><span class=n>printf</span><span class=p>(</span><span class=s>&quot;多久没有收到数据包则发送探测包：%d seconds </span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span><span class=w> </span><span class=n>optval</span><span class=p>);</span><span class=w>    </span>

<span class=w>        </span><span class=n>getsockopt</span><span class=p>(</span><span class=n>sockfd</span><span class=p>,</span><span class=w> </span><span class=n>SOL_TCP</span><span class=p>,</span><span class=w> </span><span class=n>TCP_KEEPINTVL</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>optval</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>optlen</span><span class=p>);</span><span class=w>    </span>
<span class=w>        </span><span class=n>printf</span><span class=p>(</span><span class=s>&quot;多久发送一次探测包：%d seconds </span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span><span class=w> </span><span class=n>optval</span><span class=p>);</span><span class=w>    </span>

<span class=w>        </span><span class=n>getsockopt</span><span class=p>(</span><span class=n>sockfd</span><span class=p>,</span><span class=w> </span><span class=n>SOL_TCP</span><span class=p>,</span><span class=w> </span><span class=n>TCP_KEEPCNT</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>optval</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>optlen</span><span class=p>);</span><span class=w>    </span>
<span class=w>        </span><span class=n>printf</span><span class=p>(</span><span class=s>&quot;最多发送几个探测包就断开连接：%d </span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span><span class=w> </span><span class=n>optval</span><span class=p>);</span><span class=w>    </span>

<span class=w>        </span><span class=k>return</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>    </span>
<span class=w>    </span><span class=p>}</span>
</code></pre></div></td></tr></table></div> <p>输出如图17-6所示。<br> <img alt src=https://img-blog.csdnimg.cn/f77f51efb0614a4ab743a97f6a4f92d9.png><br> 图17-6 再看一下wireshark下的keepalive包，如图17-7所示。<br> <img alt src=https://img-blog.csdnimg.cn/1bcd7cfe674642ec97dd6625a7d74612.png><br> 图17-7 </p> <h2 id=174-allowhalfopen>17.4 allowHalfOpen<a class=headerlink href=#174-allowhalfopen title="Permanent link">&para;</a></h2> <p>我们知道TCP连接在正常断开的时候，会走四次挥手的流程，在Node.js中，当收到对端发送过来的fin包时，回复ack后，默认会发送fin包给对端，以完成四次挥手。但是我们可能会有这样的场景，客户端发送完数据后，发送fin包表示自己没有数据可写了，只需要等待服务器返回。这时候如果服务器在收到fin包后，也回复fin，那就会有问题。在Node.js中提供了allowHalfOpen选项支持半关闭，我们知道TCP是全双工的，两端可以同时互相发送数据，allowHalfOpen相当于把一端关闭了，允许数据单向传输。我们看一下allowHalfOpen的实现。allowHalfOpen是属于Socket的选项。我们从Node.js收到一个fin包开始分析整个流程。首先在新建Socket对象的时候，注册对应事件。 socket.on('_socketEnd', onSocketEnd);<br> 当操作系统收到fin包的时候，会触发socket的可读事件，执行Node.js的读回调。Node.js执行读取的时候发现，读取已结束，因为对端发送了fin包。这时候会触发_socketEnd事件。我们看一下相关代码。</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span>
<span class=normal>7</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=kd>function</span><span class=w> </span><span class=nx>onSocketEnd</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// ...  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=k>this</span><span class=p>.</span><span class=nx>allowHalfOpen</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=nx>write</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>writeAfterFIN</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=nx>destroySoon</span><span class=p>();</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>    </span><span class=p>}</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>allowHalfOpen默认是false。onSocketEnd首先设置write函数为writeAfterFIN，我们看看这时候如果我们写会怎样。我们会收到一个错误。</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span>
<span class=normal>7</span>
<span class=normal>8</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=kd>function</span><span class=w> </span><span class=nx>writeAfterFIN</span><span class=p>(</span><span class=nx>chunk</span><span class=p>,</span><span class=w> </span><span class=nx>encoding</span><span class=p>,</span><span class=w> </span><span class=nx>cb</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=kd>var</span><span class=w> </span><span class=nx>er</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=ow>new</span><span class=w> </span><span class=ne>Error</span><span class=p>(</span><span class=s1>&#39;This socket has been ended by the other party&#39;</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=nx>er</span><span class=p>.</span><span class=nx>code</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;EPIPE&#39;</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=nx>emit</span><span class=p>(</span><span class=s1>&#39;error&#39;</span><span class=p>,</span><span class=w> </span><span class=nx>er</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=ow>typeof</span><span class=w> </span><span class=nx>cb</span><span class=w> </span><span class=o>===</span><span class=w> </span><span class=s1>&#39;function&#39;</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=nx>nextTick</span><span class=p>(</span><span class=k>this</span><span class=p>[</span><span class=nx>async_id_symbol</span><span class=p>],</span><span class=w> </span><span class=nx>cb</span><span class=p>,</span><span class=w> </span><span class=nx>er</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>    </span><span class=p>}</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>设置完write后，接着Node.js会发送fin包。</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=nx>Socket</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>destroySoon</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kd>function</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 关闭写流  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>writable</span><span class=p>)</span><span class=w>  </span>
<span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=nx>end</span><span class=p>();</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 关闭成功后销毁流  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>_writableState</span><span class=p>.</span><span class=nx>finished</span><span class=p>)</span><span class=w>  </span>
<span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=nx>destroy</span><span class=p>();</span><span class=w>  </span>
<span class=w>      </span><span class=k>else</span><span class=w>  </span>
<span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=nx>once</span><span class=p>(</span><span class=s1>&#39;finish&#39;</span><span class=p>,</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=nx>destroy</span><span class=p>);</span><span class=w>  </span>
<span class=w>    </span><span class=p>};</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>首先关闭写流，然后执行destroy函数销毁流。在destroy中会执行_destroy。_destroy会执行具体的关闭操作，即发送fin包。</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span></pre></div></td><td class=code><div><pre><span></span><code>    this._handle.close(() =&gt; {   
      this.emit(&#39;close&#39;, isException);  
    });  
</code></pre></div></td></tr></table></div> <p>我们看到C++层的close。</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>HandleWrap::Close</span><span class=p>(</span><span class=k>const</span><span class=w> </span><span class=n>FunctionCallbackInfo</span><span class=o>&lt;</span><span class=n>Value</span><span class=o>&gt;&amp;</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=n>Environment</span><span class=o>*</span><span class=w> </span><span class=n>env</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Environment</span><span class=o>::</span><span class=n>GetCurrent</span><span class=p>(</span><span class=n>args</span><span class=p>);</span><span class=w>  </span>

<span class=w>      </span><span class=n>HandleWrap</span><span class=o>*</span><span class=w> </span><span class=n>wrap</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=n>ASSIGN_OR_RETURN_UNWRAP</span><span class=p>(</span><span class=o>&amp;</span><span class=n>wrap</span><span class=p>,</span><span class=w> </span><span class=n>args</span><span class=p>.</span><span class=n>Holder</span><span class=p>());</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 关闭handle  </span>
<span class=w>      </span><span class=n>uv_close</span><span class=p>(</span><span class=n>wrap</span><span class=o>-&gt;</span><span class=n>handle_</span><span class=p>,</span><span class=w> </span><span class=n>OnClose</span><span class=p>);</span><span class=w>  </span>
<span class=w>      </span><span class=n>wrap</span><span class=o>-&gt;</span><span class=n>state_</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>kClosing</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 执行回调，触发close事件  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>IsFunction</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=n>wrap</span><span class=o>-&gt;</span><span class=n>object</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>Set</span><span class=p>(</span><span class=n>env</span><span class=o>-&gt;</span><span class=n>onclose_string</span><span class=p>(),</span><span class=w> </span><span class=n>args</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span><span class=w>  </span>
<span class=w>        </span><span class=n>wrap</span><span class=o>-&gt;</span><span class=n>state_</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>kClosingWithCallback</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>    </span><span class=p>}</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>我们继续往Libuv看。</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=kt>void</span><span class=w> </span><span class=nf>uv_close</span><span class=p>(</span><span class=n>uv_handle_t</span><span class=o>*</span><span class=w> </span><span class=n>handle</span><span class=p>,</span><span class=w> </span><span class=n>uv_close_cb</span><span class=w> </span><span class=n>cb</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=n>uv_loop_t</span><span class=o>*</span><span class=w> </span><span class=n>loop</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>handle</span><span class=o>-&gt;</span><span class=n>loop</span><span class=p>;</span><span class=w>  </span>

<span class=w>      </span><span class=n>handle</span><span class=o>-&gt;</span><span class=n>close_cb</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>cb</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=k>switch</span><span class=w> </span><span class=p>(</span><span class=n>handle</span><span class=o>-&gt;</span><span class=n>type</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=k>case</span><span class=w> </span><span class=no>UV_TCP</span><span class=p>:</span><span class=w>  </span>
<span class=w>          </span><span class=n>uv_tcp_close</span><span class=p>(</span><span class=n>loop</span><span class=p>,</span><span class=w> </span><span class=p>(</span><span class=n>uv_tcp_t</span><span class=o>*</span><span class=p>)</span><span class=n>handle</span><span class=p>);</span><span class=w>  </span>
<span class=w>          </span><span class=k>return</span><span class=p>;</span><span class=w>  </span>

<span class=w>         </span><span class=c1>// ...  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>    </span><span class=p>}</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>uv_tcp_close会对close的封装，我们看tcp close的大致实现。</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=k>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>tcp_close</span><span class=p>(</span><span class=k>struct</span><span class=w> </span><span class=nc>sock</span><span class=w> </span><span class=o>*</span><span class=n>sk</span><span class=p>,</span><span class=w> </span><span class=kt>int</span><span class=w> </span><span class=n>timeout</span><span class=p>)</span><span class=w>  </span>
<span class=w>    </span><span class=p>{</span><span class=w>  </span>

<span class=w>        </span><span class=c1>// 监听型的socket要关闭建立的连接  </span>
<span class=w>        </span><span class=k>if</span><span class=p>(</span><span class=n>sk</span><span class=o>-&gt;</span><span class=n>state</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>TCP_LISTEN</span><span class=p>)</span><span class=w>  </span>
<span class=w>        </span><span class=p>{</span><span class=w>  </span>
<span class=w>            </span><span class=cm>/* Special case */</span><span class=w>  </span>
<span class=w>            </span><span class=n>tcp_set_state</span><span class=p>(</span><span class=n>sk</span><span class=p>,</span><span class=w> </span><span class=n>TCP_CLOSE</span><span class=p>);</span><span class=w>  </span>
<span class=w>            </span><span class=c1>// 关闭已经建立的连接  </span>
<span class=w>            </span><span class=n>tcp_close_pending</span><span class=p>(</span><span class=n>sk</span><span class=p>);</span><span class=w>  </span>
<span class=w>            </span><span class=n>release_sock</span><span class=p>(</span><span class=n>sk</span><span class=p>);</span><span class=w>  </span>
<span class=w>            </span><span class=k>return</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=p>}</span><span class=w>  </span>

<span class=w>        </span><span class=k>struct</span><span class=w> </span><span class=nc>sk_buff</span><span class=w> </span><span class=o>*</span><span class=n>skb</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// 销毁接收队列中未处理的数据   </span>
<span class=w>        </span><span class=k>while</span><span class=p>((</span><span class=n>skb</span><span class=o>=</span><span class=n>skb_dequeue</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sk</span><span class=o>-&gt;</span><span class=n>receive_queue</span><span class=p>))</span><span class=o>!=</span><span class=nb>NULL</span><span class=p>)</span><span class=w>  </span>
<span class=w>            </span><span class=n>kfree_skb</span><span class=p>(</span><span class=n>skb</span><span class=p>,</span><span class=w> </span><span class=n>FREE_READ</span><span class=p>);</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// 发送fin包</span>
<span class=w>        </span><span class=n>tcp_send_fin</span><span class=p>(</span><span class=n>sk</span><span class=p>);</span><span class=w>  </span>
<span class=w>        </span><span class=n>release_sock</span><span class=p>(</span><span class=n>sk</span><span class=p>);</span><span class=w>  </span>
<span class=w>    </span><span class=p>}</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>以上是Node.js中socket收到fin包时的默认处理流程，当我们设置allowHalfOpen为true的时候，就可以修改这个默认的行为，允许半关闭状态的连接。</p> <h2 id=175-server-close>17.5 server close<a class=headerlink href=#175-server-close title="Permanent link">&para;</a></h2> <p>调用close可以关闭一个服务器，首先我们看一下Node.js文档关于close函数的解释</p> <blockquote> <p>Stops the server from accepting new connections and keeps existing connections. This function is asynchronous, the server is finally closed when all connections are ended and the server emits a 'close' event. The optional callback will be called once the 'close' event occurs. Unlike that event, it will be called with an Error as its only argument if the server was not open when it was closed. </p> </blockquote> <p>在Node.js中 ，当我们使用close关闭一个server时，server会等所有的连接关闭后才会触发close事件。我们看close的实现，一探究竟。</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=nx>Server</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>close</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kd>function</span><span class=p>(</span><span class=nx>cb</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 触发回调  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=ow>typeof</span><span class=w> </span><span class=nx>cb</span><span class=w> </span><span class=o>===</span><span class=w> </span><span class=s1>&#39;function&#39;</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=k>this</span><span class=p>.</span><span class=nx>_handle</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>          </span><span class=k>this</span><span class=p>.</span><span class=nx>once</span><span class=p>(</span><span class=s1>&#39;close&#39;</span><span class=p>,</span><span class=w> </span><span class=kd>function</span><span class=w> </span><span class=nx>close</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>            </span><span class=nx>cb</span><span class=p>(</span><span class=ow>new</span><span class=w> </span><span class=nx>errors</span><span class=p>.</span><span class=ne>Error</span><span class=p>(</span><span class=s1>&#39;ERR_SERVER_NOT_RUNNING&#39;</span><span class=p>));</span><span class=w>  </span>
<span class=w>          </span><span class=p>});</span><span class=w>  </span>
<span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>          </span><span class=k>this</span><span class=p>.</span><span class=nx>once</span><span class=p>(</span><span class=s1>&#39;close&#39;</span><span class=p>,</span><span class=w> </span><span class=nx>cb</span><span class=p>);</span><span class=w>  </span>
<span class=w>        </span><span class=p>}</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 关闭底层资源  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>_handle</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=nx>_handle</span><span class=p>.</span><span class=nx>close</span><span class=p>();</span><span class=w>  </span>
<span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=nx>_handle</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 判断是否需要立刻触发close事件  </span>
<span class=w>      </span><span class=k>this</span><span class=p>.</span><span class=nx>_emitCloseIfDrained</span><span class=p>();</span><span class=w>  </span>
<span class=w>      </span><span class=k>return</span><span class=w> </span><span class=k>this</span><span class=p>;</span><span class=w>  </span>
<span class=w>    </span><span class=p>};</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>close的代码比较简单，首先监听close事件，然后关闭server对应的handle，所以server不会再接收新的请求了。最后调用_emitCloseIfDrained，我们看一下这个函数是干嘛的。</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=nx>Server</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>_emitCloseIfDrained</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kd>function</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 还有连接或者handle非空说明handle还没有关闭，则先不触发close事件  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>_handle</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=nx>_connections</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=k>return</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// 触发close事件  </span>
<span class=w>      </span><span class=kd>const</span><span class=w> </span><span class=nx>asyncId</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=nx>_handle</span><span class=w> </span><span class=o>?</span><span class=w> </span><span class=k>this</span><span class=p>[</span><span class=nx>async_id_symbol</span><span class=p>]</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=kc>null</span><span class=p>;</span><span class=w>  </span>
<span class=w>      </span><span class=nx>nextTick</span><span class=p>(</span><span class=nx>asyncId</span><span class=p>,</span><span class=w> </span><span class=nx>emitCloseNT</span><span class=p>,</span><span class=w> </span><span class=k>this</span><span class=p>);</span><span class=w>  </span>
<span class=w>    </span><span class=p>};</span><span class=w>  </span>


<span class=w>    </span><span class=kd>function</span><span class=w> </span><span class=nx>emitCloseNT</span><span class=p>(</span><span class=nx>self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=nx>self</span><span class=p>.</span><span class=nx>emit</span><span class=p>(</span><span class=s1>&#39;close&#39;</span><span class=p>);</span><span class=w>  </span>
<span class=w>    </span><span class=p>}</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>_emitCloseIfDrained中有一个拦截的判断，handle非空或者连接数非0。由之前的代码我们已经知道handle是null，但是如果这时候连接数非0，也不会触发close事件。那什么时候才会触发close事件呢？在socket的_destroy函数中我们找到修改连接数的逻辑。</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=nx>Socket</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>_destroy</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kd>function</span><span class=p>(</span><span class=nx>exception</span><span class=p>,</span><span class=w> </span><span class=nx>cb</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=p>...</span><span class=w>  </span>
<span class=w>      </span><span class=c1>// socket所属的server  </span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>_server</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// server下的连接数减一  </span>
<span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=nx>_server</span><span class=p>.</span><span class=nx>_connections</span><span class=o>--</span><span class=p>;</span><span class=w>  </span>
<span class=w>        </span><span class=c1>// 是否需要触发server的close事件，当所有的连接（socket）都关闭时才触发server的是close事件  </span>
<span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>_server</span><span class=p>.</span><span class=nx>_emitCloseIfDrained</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>          </span><span class=k>this</span><span class=p>.</span><span class=nx>_server</span><span class=p>.</span><span class=nx>_emitCloseIfDrained</span><span class=p>();</span><span class=w>  </span>
<span class=w>        </span><span class=p>}</span><span class=w>  </span>
<span class=w>      </span><span class=p>}</span><span class=w>  </span>
<span class=w>    </span><span class=p>};</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>我们看到每一个连接关闭的时候，都会导致连接数减一，直到为0的时候才会触发close事件。假设我们启动了一个服务器，接收到了一些客户端的请求，这时候，如果我们想修改一个代码发布，需要重启服务器，怎么办？假设我们有以下代码。 server.js</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=kd>const</span><span class=w> </span><span class=nx>net</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>require</span><span class=p>(</span><span class=s1>&#39;net&#39;</span><span class=p>);</span><span class=w>  </span>
<span class=w>    </span><span class=kd>const</span><span class=w> </span><span class=nx>server</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>net</span><span class=p>.</span><span class=nx>createServer</span><span class=p>().</span><span class=nx>listen</span><span class=p>(</span><span class=mf>80</span><span class=p>);</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>client.js</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span></pre></div></td><td class=code><div><pre><span></span><code>    const net = require(&#39;net&#39;);  
    net.connect({port:80})  
</code></pre></div></td></tr></table></div> <p>如果我们直接杀死进程，那么存量的请求就会无法正常被处理。这会影响我们的服务质量。我们看一下Node.js如何在重启时优雅地退出，所谓优雅，即让Node.js进程处理完存量请求后再退出。Server的close的实现给了我们一些思路。我们可以监听server的close事件，等到触发close事件后才退出进程。</p> <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w>    </span><span class=kd>const</span><span class=w> </span><span class=nx>net</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>require</span><span class=p>(</span><span class=s1>&#39;net&#39;</span><span class=p>);</span><span class=w>  </span>
<span class=w>    </span><span class=kd>const</span><span class=w> </span><span class=nx>server</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>net</span><span class=p>.</span><span class=nx>createServer</span><span class=p>().</span><span class=nx>listen</span><span class=p>(</span><span class=mf>80</span><span class=p>);</span><span class=w>  </span>
<span class=w>    </span><span class=nx>server</span><span class=p>.</span><span class=nx>on</span><span class=p>(</span><span class=s1>&#39;close&#39;</span><span class=p>,</span><span class=w> </span><span class=p>()</span><span class=w> </span><span class=p>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=nx>process</span><span class=p>.</span><span class=nx>exit</span><span class=p>();</span><span class=w>  </span>
<span class=w>    </span><span class=p>});</span><span class=w>  </span>
<span class=w>    </span><span class=c1>// 防止进程提前挂掉  </span>
<span class=w>    </span><span class=nx>process</span><span class=p>.</span><span class=nx>on</span><span class=p>(</span><span class=s1>&#39;uncaughtException&#39;</span><span class=p>,</span><span class=w> </span><span class=p>()</span><span class=w> </span><span class=p>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>  </span>

<span class=w>    </span><span class=p>});</span><span class=w>  </span>
<span class=w>    </span><span class=nx>process</span><span class=p>.</span><span class=nx>on</span><span class=p>(</span><span class=s1>&#39;SIGINT&#39;</span><span class=p>,</span><span class=w> </span><span class=kd>function</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>  </span>
<span class=w>      </span><span class=nx>server</span><span class=p>.</span><span class=nx>close</span><span class=p>();</span><span class=w>  </span>
<span class=w>    </span><span class=p>})</span><span class=w>  </span>
</code></pre></div></td></tr></table></div> <p>我们首先监听SIGINT信号，当我们使用SIGINT信号杀死进程时，首先调用server.close，等到所有的连接断开，触发close时候时，再退出进程。我们首先开启服务器，然后开启两个客户端。接着按下ctrl+c，我们发现这时候服务器不会退出，然后我们关闭两个客户端，这时候server就会优雅地退出。</p> </article> </div> <script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script> </div> <button type=button class="md-top md-icon" data-md-component=top hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg> 回到页面顶部 </button> </main> <footer class=md-footer> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> <div class=md-copyright__highlight> Copyright &copy; 2021 theanarkh </div> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> <div class=md-social> <a href=https://github.com/theanarkh target=_blank rel=noopener title=github.com class=md-social__link> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 496 512"><!-- Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg> </a> <a href=https://www.zhihu.com/people/theanarkh target=_blank rel=noopener title=www.zhihu.com class=md-social__link> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 640 512"><!-- Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M170.54 148.13v217.54l23.43.01 7.71 26.37 42.01-26.37h49.53V148.13zm97.75 193.93h-27.94l-27.9 17.51-5.08-17.47-11.9-.04V171.75h72.82zm-118.46-94.39H97.5c1.74-27.1 2.2-51.59 2.2-73.46h51.16s1.97-22.56-8.58-22.31h-88.5c3.49-13.12 7.87-26.66 13.12-40.67 0 0-24.07 0-32.27 21.57-3.39 8.9-13.21 43.14-30.7 78.12 5.89-.64 25.37-1.18 36.84-22.21 2.11-5.89 2.51-6.66 5.14-14.53h28.87c0 10.5-1.2 66.88-1.68 73.44H20.83c-11.74 0-15.56 23.62-15.56 23.62h65.58C66.45 321.1 42.83 363.12 0 396.34c20.49 5.85 40.91-.93 51-9.9 0 0 22.98-20.9 35.59-69.25l53.96 64.94s7.91-26.89-1.24-39.99c-7.58-8.92-28.06-33.06-36.79-41.81L87.9 311.95c4.36-13.98 6.99-27.55 7.87-40.67h61.65s-.09-23.62-7.59-23.62zm412.02-1.6c20.83-25.64 44.98-58.57 44.98-58.57s-18.65-14.8-27.38-4.06c-6 8.15-36.83 48.2-36.83 48.2zm-150.09-59.09c-9.01-8.25-25.91 2.13-25.91 2.13s39.52 55.04 41.12 57.45l19.46-13.73s-25.67-37.61-34.66-45.86h-.01zM640 258.35c-19.78 0-130.91.93-131.06.93v-101c4.81 0 12.42-.4 22.85-1.2 40.88-2.41 70.13-4 87.77-4.81 0 0 12.22-27.19-.59-33.44-3.07-1.18-23.17 4.58-23.17 4.58s-165.22 16.49-232.36 18.05c1.6 8.82 7.62 17.08 15.78 19.55 13.31 3.48 22.69 1.7 49.15.89 24.83-1.6 43.68-2.43 56.51-2.43v99.81H351.41s2.82 22.31 25.51 22.85h107.94v70.92c0 13.97-11.19 21.99-24.48 21.12-14.08.11-26.08-1.15-41.69-1.81 1.99 3.97 6.33 14.39 19.31 21.84 9.88 4.81 16.17 6.57 26.02 6.57 29.56 0 45.67-17.28 44.89-45.31v-73.32h122.36c9.68 0 8.7-23.78 8.7-23.78z"/></svg> </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "..", "features": ["content.code.annotate", "navigation.indexes", "navigation.instant", "navigation.tabs", "navigation.tabs.sticky", "navigation.sections", "navigation.top", "navigation.tracking", "search.highlight", "search.share", "search.suggest"], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script> <script src=../assets/javascripts/bundle.83f73b43.min.js></script> <script src=../extra/image.js defer></script> </body> </html>