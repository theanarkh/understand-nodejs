<!doctype html><html lang=zh class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="通过源码分析 Node.js 原理"><meta name=author content=theanarkh><link href=https://github.com/theanarkh/understand-nodejs/chapter30-Node.js%20%E7%9A%84%20trace%20events%20%E6%9E%B6%E6%9E%84/ rel=canonical><link href=../chapter27-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Node.js%20%E7%9A%84%20Buffer/ rel=prev><link href=../chapter31-Node.js%20%E7%9A%84%20perf_hooks/ rel=next><link rel=icon href=../assets/images/favicon.png><meta name=generator content="mkdocs-1.6.1, mkdocs-material-9.5.44"><title>30-Node.js 的 trace events 架构 - Node.js 源码剖析</title><link rel=stylesheet href=../assets/stylesheets/main.0253249f.min.css><link rel=stylesheet href=../assets/stylesheets/palette.06af60db.min.css><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback"><style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style><script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script></head> <body dir=ltr data-md-color-scheme=default data-md-color-primary=indigo data-md-color-accent=indigo> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#1-v8 class=md-skip> 跳转至 </a> </div> <div data-md-component=announce> </div> <header class="md-header md-header--shadow md-header--lifted" data-md-component=header> <nav class="md-header__inner md-grid" aria-label=页眉> <a href=.. title="Node.js 源码剖析" class="md-header__button md-logo" aria-label="Node.js 源码剖析" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="m19 2-5 4.5v11l5-4.5zM6.5 5C4.55 5 2.45 5.4 1 6.5v14.66c0 .25.25.5.5.5.1 0 .15-.07.25-.07 1.35-.65 3.3-1.09 4.75-1.09 1.95 0 4.05.4 5.5 1.5 1.35-.85 3.8-1.5 5.5-1.5 1.65 0 3.35.31 4.75 1.06.1.05.15.03.25.03.25 0 .5-.25.5-.5V6.5c-.6-.45-1.25-.75-2-1V19c-1.1-.35-2.3-.5-3.5-.5-1.7 0-4.15.65-5.5 1.5V6.5C10.55 5.4 8.45 5 6.5 5"/></svg> </a> <label class="md-header__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg> </label> <div class=md-header__title data-md-component=header-title> <div class=md-header__ellipsis> <div class=md-header__topic> <span class=md-ellipsis> Node.js 源码剖析 </span> </div> <div class=md-header__topic data-md-component=header-topic> <span class=md-ellipsis> 30-Node.js 的 trace events 架构 </span> </div> </div> </div> <form class=md-header__option data-md-component=palette> <input class=md-option data-md-color-media data-md-color-scheme=default data-md-color-primary=indigo data-md-color-accent=indigo aria-label="Switch to dark mode" type=radio name=__palette id=__palette_0> <label class="md-header__button md-icon" title="Switch to dark mode" for=__palette_1 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M17 6H7c-3.31 0-6 2.69-6 6s2.69 6 6 6h10c3.31 0 6-2.69 6-6s-2.69-6-6-6m0 10H7c-2.21 0-4-1.79-4-4s1.79-4 4-4h10c2.21 0 4 1.79 4 4s-1.79 4-4 4M7 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3"/></svg> </label> <input class=md-option data-md-color-media data-md-color-scheme=slate data-md-color-primary=blue data-md-color-accent=blue aria-label="Switch to light mode" type=radio name=__palette id=__palette_1> <label class="md-header__button md-icon" title="Switch to light mode" for=__palette_0 hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3"/></svg> </label> </form> <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script> <label class="md-header__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=搜索 placeholder=搜索 autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query required> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg> </label> <nav class=md-search__options aria-label=查找> <a href=javascript:void(0) class="md-search__icon md-icon" title=分享 aria-label=分享 data-clipboard data-clipboard-text data-md-component=search-share tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91s2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08"/></svg> </a> <button type=reset class="md-search__icon md-icon" title=清空当前内容 aria-label=清空当前内容 tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg> </button> </nav> <div class=md-search__suggest data-md-component=search-suggest></div> </form> <div class=md-search__output> <div class=md-search__scrollwrap tabindex=0 data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> 正在初始化搜索引擎 </div> <ol class=md-search-result__list role=presentation></ol> </div> </div> </div> </div> </div> <div class=md-header__source> <a href=https://github.com/theanarkh/understand-nodejs title=前往仓库 class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 496 512"><!-- Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg> </div> <div class=md-source__repository> understand-nodejs </div> </a> </div> </nav> <nav class=md-tabs aria-label=标签 data-md-component=tabs> <div class=md-grid> <ul class=md-tabs__list> <li class=md-tabs__item> <a href=.. class=md-tabs__link> Home </a> </li> <li class=md-tabs__item> <a href=../chapter00-%E5%89%8D%E8%A8%80/ class=md-tabs__link> 前言 </a> </li> <li class=md-tabs__item> <a href=../chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/ class=md-tabs__link> Node.js基础和架构 </a> </li> <li class="md-tabs__item md-tabs__item--active"> <a href=../chapter07-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/ class=md-tabs__link> Node.js核心模块的实现 </a> </li> <li class=md-tabs__item> <a href=../chapter20-%E6%8B%93%E5%B1%95Node.js/ class=md-tabs__link> 其他 </a> </li> </ul> </div> </nav> </header> <div class=md-container data-md-component=container> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=sidebar data-md-type=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary md-nav--lifted" aria-label=导航栏 data-md-level=0> <label class=md-nav__title for=__drawer> <a href=.. title="Node.js 源码剖析" class="md-nav__button md-logo" aria-label="Node.js 源码剖析" data-md-component=logo> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="m19 2-5 4.5v11l5-4.5zM6.5 5C4.55 5 2.45 5.4 1 6.5v14.66c0 .25.25.5.5.5.1 0 .15-.07.25-.07 1.35-.65 3.3-1.09 4.75-1.09 1.95 0 4.05.4 5.5 1.5 1.35-.85 3.8-1.5 5.5-1.5 1.65 0 3.35.31 4.75 1.06.1.05.15.03.25.03.25 0 .5-.25.5-.5V6.5c-.6-.45-1.25-.75-2-1V19c-1.1-.35-2.3-.5-3.5-.5-1.7 0-4.15.65-5.5 1.5V6.5C10.55 5.4 8.45 5 6.5 5"/></svg> </a> Node.js 源码剖析 </label> <div class=md-nav__source> <a href=https://github.com/theanarkh/understand-nodejs title=前往仓库 class=md-source data-md-component=source> <div class="md-source__icon md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 496 512"><!-- Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg> </div> <div class=md-source__repository> understand-nodejs </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=.. class=md-nav__link> <span class=md-ellipsis> Home </span> </a> </li> <li class=md-nav__item> <a href=../chapter00-%E5%89%8D%E8%A8%80/ class=md-nav__link> <span class=md-ellipsis> 前言 </span> </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_3> <label class=md-nav__link for=__nav_3 id=__nav_3_label tabindex=0> <span class=md-ellipsis> Node.js基础和架构 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_3_label aria-expanded=false> <label class=md-nav__title for=__nav_3> <span class="md-nav__icon md-icon"></span> Node.js基础和架构 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/ class=md-nav__link> <span class=md-ellipsis> 01-Node.js组成和原理 </span> </a> </li> <li class=md-nav__item> <a href=../chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/ class=md-nav__link> <span class=md-ellipsis> 02-Libuv数据结构和通用逻辑 </span> </a> </li> <li class=md-nav__item> <a href=../chapter03-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/ class=md-nav__link> <span class=md-ellipsis> 03-事件循环 </span> </a> </li> <li class=md-nav__item> <a href=../chapter04-%E7%BA%BF%E7%A8%8B%E6%B1%A0/ class=md-nav__link> <span class=md-ellipsis> 04-线程池 </span> </a> </li> <li class=md-nav__item> <a href=../chapter05-Libuv%E6%B5%81/ class=md-nav__link> <span class=md-ellipsis> 05-Libuv流 </span> </a> </li> <li class=md-nav__item> <a href=../chapter06-C%2B%2B%E5%B1%82/ class=md-nav__link> <span class=md-ellipsis> 06-C++层 </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_4 checked> <label class=md-nav__link for=__nav_4 id=__nav_4_label tabindex> <span class=md-ellipsis> Node.js核心模块的实现 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_4_label aria-expanded=true> <label class=md-nav__title for=__nav_4> <span class="md-nav__icon md-icon"></span> Node.js核心模块的实现 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../chapter07-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/ class=md-nav__link> <span class=md-ellipsis> 07-信号处理 </span> </a> </li> <li class=md-nav__item> <a href=../chapter08-DNS/ class=md-nav__link> <span class=md-ellipsis> 08-DNS </span> </a> </li> <li class=md-nav__item> <a href=../chapter09-Unix%E5%9F%9F/ class=md-nav__link> <span class=md-ellipsis> 09-Unix域 </span> </a> </li> <li class=md-nav__item> <a href=../chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/ class=md-nav__link> <span class=md-ellipsis> 10-定时器 </span> </a> </li> <li class=md-nav__item> <a href=../chapter11-setImmediate%E5%92%8CnextTick/ class=md-nav__link> <span class=md-ellipsis> 11-setImmediate和nextTick </span> </a> </li> <li class=md-nav__item> <a href=../chapter12-%E6%96%87%E4%BB%B6/ class=md-nav__link> <span class=md-ellipsis> 12-文件 </span> </a> </li> <li class=md-nav__item> <a href=../chapter13-%E8%BF%9B%E7%A8%8B/ class=md-nav__link> <span class=md-ellipsis> 13-进程 </span> </a> </li> <li class=md-nav__item> <a href=../chapter14-%E7%BA%BF%E7%A8%8B/ class=md-nav__link> <span class=md-ellipsis> 14-线程 </span> </a> </li> <li class=md-nav__item> <a href=../chapter15-Cluster/ class=md-nav__link> <span class=md-ellipsis> 15-Cluster </span> </a> </li> <li class=md-nav__item> <a href=../chapter16-UDP/ class=md-nav__link> <span class=md-ellipsis> 16-UDP </span> </a> </li> <li class=md-nav__item> <a href=../chapter17-TCP/ class=md-nav__link> <span class=md-ellipsis> 17-TCP </span> </a> </li> <li class=md-nav__item> <a href=../chapter18-HTTP/ class=md-nav__link> <span class=md-ellipsis> 18-HTTP </span> </a> </li> <li class=md-nav__item> <a href=../chapter19-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD/ class=md-nav__link> <span class=md-ellipsis> 19-模块加载 </span> </a> </li> <li class=md-nav__item> <a href=../chapter21-JS%20Stream/ class=md-nav__link> <span class=md-ellipsis> 20-JS Stream </span> </a> </li> <li class=md-nav__item> <a href=../chapter22-events%E6%A8%A1%E5%9D%97/ class=md-nav__link> <span class=md-ellipsis> 21-events模块 </span> </a> </li> <li class=md-nav__item> <a href=../chapter23-Async%20hooks/ class=md-nav__link> <span class=md-ellipsis> 22-Async hooks </span> </a> </li> <li class=md-nav__item> <a href=../chapter24-Inspector/ class=md-nav__link> <span class=md-ellipsis> 23-Inspector </span> </a> </li> <li class=md-nav__item> <a href=../chapter27-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Node.js%20%E7%9A%84%20Buffer/ class=md-nav__link> <span class=md-ellipsis> 27-深入理解 Node.js 的 Buffer </span> </a> </li> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" type=checkbox id=__toc> <label class="md-nav__link md-nav__link--active" for=__toc> <span class=md-ellipsis> 30-Node.js 的 trace events 架构 </span> <span class="md-nav__icon md-icon"></span> </label> <a href=./ class="md-nav__link md-nav__link--active"> <span class=md-ellipsis> 30-Node.js 的 trace events 架构 </span> </a> <nav class="md-nav md-nav--secondary" aria-label=目录> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> 目录 </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#11-traceobject class=md-nav__link> <span class=md-ellipsis> 1.1. TraceObject </span> </a> </li> <li class=md-nav__item> <a href=#12-tracewriter class=md-nav__link> <span class=md-ellipsis> 1.2 TraceWriter </span> </a> </li> <li class=md-nav__item> <a href=#13-tracebufferchunk class=md-nav__link> <span class=md-ellipsis> 1.3 TraceBufferChunk </span> </a> </li> <li class=md-nav__item> <a href=#14-tracebuffer class=md-nav__link> <span class=md-ellipsis> 1.4 TraceBuffer </span> </a> </li> <li class=md-nav__item> <a href=#15-traceconfig class=md-nav__link> <span class=md-ellipsis> 1.5 TraceConfig </span> </a> </li> <li class=md-nav__item> <a href=#16-tracingcontroller class=md-nav__link> <span class=md-ellipsis> 1.6 TracingController </span> </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../chapter31-Node.js%20%E7%9A%84%20perf_hooks/ class=md-nav__link> <span class=md-ellipsis> 31-Node.js 的 perf_hooks </span> </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle " type=checkbox id=__nav_5> <label class=md-nav__link for=__nav_5 id=__nav_5_label tabindex=0> <span class=md-ellipsis> 其他 </span> <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav data-md-level=1 aria-labelledby=__nav_5_label aria-expanded=false> <label class=md-nav__title for=__nav_5> <span class="md-nav__icon md-icon"></span> 其他 </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../chapter20-%E6%8B%93%E5%B1%95Node.js/ class=md-nav__link> <span class=md-ellipsis> 24-拓展Node.js </span> </a> </li> <li class=md-nav__item> <a href=../chapter25-Node.js子线程调试和诊断指南 class=md-nav__link> <span class=md-ellipsis> 25-Node.js子线程调试和诊断指南 </span> </a> </li> <li class=md-nav__item> <a href=../chapter26-vscode%E8%B0%83%E8%AF%95Node.js/ class=md-nav__link> <span class=md-ellipsis> 26-vscode调试Node.js </span> </a> </li> <li class=md-nav__item> <a href=../chapter28-Node.js%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%88%E6%9E%B6%E6%9E%84%E7%AF%87%EF%BC%89/ class=md-nav__link> <span class=md-ellipsis> 28-Node.js底层原理（架构篇） </span> </a> </li> <li class=md-nav__item> <a href=../chapter29-Node.js%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%EF%BC%88%E5%AE%9E%E7%8E%B0%E7%AF%87%EF%BC%89/ class=md-nav__link> <span class=md-ellipsis> 29-Node.js底层原理（实现篇） </span> </a> </li> </ul> </nav> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=sidebar data-md-type=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label=目录> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> 目录 </label> <ul class=md-nav__list data-md-component=toc data-md-scrollfix> <li class=md-nav__item> <a href=#11-traceobject class=md-nav__link> <span class=md-ellipsis> 1.1. TraceObject </span> </a> </li> <li class=md-nav__item> <a href=#12-tracewriter class=md-nav__link> <span class=md-ellipsis> 1.2 TraceWriter </span> </a> </li> <li class=md-nav__item> <a href=#13-tracebufferchunk class=md-nav__link> <span class=md-ellipsis> 1.3 TraceBufferChunk </span> </a> </li> <li class=md-nav__item> <a href=#14-tracebuffer class=md-nav__link> <span class=md-ellipsis> 1.4 TraceBuffer </span> </a> </li> <li class=md-nav__item> <a href=#15-traceconfig class=md-nav__link> <span class=md-ellipsis> 1.5 TraceConfig </span> </a> </li> <li class=md-nav__item> <a href=#16-tracingcontroller class=md-nav__link> <span class=md-ellipsis> 1.6 TracingController </span> </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content data-md-component=content> <article class="md-content__inner md-typeset"> <p>前言： trace 系统用于收集内核的数据，本文介绍在 Node.js 中 trace 的架构和实现，因为 Node.js 的 trace 系统是基于 V8 的，所以也会介绍 V8 部分。因为实现细节比较多，逻辑也比较复杂，有兴趣的同学可以配合源码一起阅读或者看一下前面的相关文章。</p> <p>因为 Node.js 的 trace 体系是基于 V8 的，所以先来看 V8 的实现。</p> <h1 id=1-v8>1 V8 的实现<a class=headerlink href=#1-v8 title="Permanent link">&para;</a></h1> <h2 id=11-traceobject>1.1. TraceObject<a class=headerlink href=#11-traceobject title="Permanent link">&para;</a></h2> <p>TraceObject 对应用于表示一个 trace 事件的信息。下面是一次 trace 事件需要保存的核心字段。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span></pre></div></td><td class=code><div><pre><span></span><code><span class=n>class</span><span class=w> </span><span class=n>V8_PLATFORM_EXPORT</span><span class=w> </span><span class=n>TraceObject</span><span class=w> </span><span class=p>{</span>
<span class=w> </span><span class=n>private</span><span class=o>:</span>
<span class=w>  </span><span class=kt>int</span><span class=w> </span><span class=n>pid_</span><span class=p>;</span>
<span class=w>  </span><span class=kt>int</span><span class=w> </span><span class=n>tid_</span><span class=p>;</span>
<span class=w>  </span><span class=kt>char</span><span class=w> </span><span class=n>phase_</span><span class=p>;</span>
<span class=w>  </span><span class=k>const</span><span class=w> </span><span class=kt>char</span><span class=o>*</span><span class=w> </span><span class=n>name_</span><span class=p>;</span>
<span class=w>  </span><span class=k>const</span><span class=w> </span><span class=kt>char</span><span class=o>*</span><span class=w> </span><span class=n>scope_</span><span class=p>;</span>
<span class=w>  </span><span class=kt>int64_t</span><span class=w> </span><span class=n>ts_</span><span class=p>;</span>
<span class=w>  </span><span class=kt>int64_t</span><span class=w> </span><span class=n>tts_</span><span class=p>;</span>
<span class=w>  </span><span class=kt>uint64_t</span><span class=w> </span><span class=n>duration_</span><span class=p>;</span>
<span class=w>  </span><span class=kt>uint64_t</span><span class=w> </span><span class=n>cpu_duration_</span><span class=p>;</span>
<span class=w>  </span><span class=c1>// 忽略其他字段</span>
<span class=p>};</span>
</code></pre></div></td></tr></table></div></p> <h2 id=12-tracewriter>1.2 TraceWriter<a class=headerlink href=#12-tracewriter title="Permanent link">&para;</a></h2> <p>TraceWriter 用于表示消费者，整个 trace 系统中可以有多个消费者。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span>
<span class=normal>7</span>
<span class=normal>8</span>
<span class=normal>9</span></pre></div></td><td class=code><div><pre><span></span><code><span class=n>class</span><span class=w> </span><span class=n>V8_PLATFORM_EXPORT</span><span class=w> </span><span class=n>TraceWriter</span><span class=w> </span><span class=p>{</span>
<span class=w> </span><span class=n>public</span><span class=o>:</span>
<span class=w>  </span><span class=c1>// 消费数据，只会保存在内存里，必要的时候再进行真正的处理</span>
<span class=w>  </span><span class=n>virtual</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=n>AppendTraceEvent</span><span class=p>(</span><span class=n>TraceObject</span><span class=o>*</span><span class=w> </span><span class=n>trace_event</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span>
<span class=w>  </span><span class=c1>// 真正处理数据的函数</span>
<span class=w>  </span><span class=n>virtual</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=n>Flush</span><span class=p>()</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span>
<span class=w>  </span><span class=c1>// 获取一个 json writer，即把 trace 数据进行 json 格式化</span>
<span class=w>  </span><span class=k>static</span><span class=w> </span><span class=n>TraceWriter</span><span class=o>*</span><span class=w> </span><span class=nf>CreateJSONTraceWriter</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>ostream</span><span class=o>&amp;</span><span class=w> </span><span class=n>stream</span><span class=p>)</span>
<span class=p>};</span>
</code></pre></div></td></tr></table></div></p> <h2 id=13-tracebufferchunk>1.3 TraceBufferChunk<a class=headerlink href=#13-tracebufferchunk title="Permanent link">&para;</a></h2> <p>TraceBufferChunk 用于临时保存 trace 数据，因为数据会现在内存中缓存，具体由 TraceBufferChunk 进行组织和保存。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span></pre></div></td><td class=code><div><pre><span></span><code><span class=n>class</span><span class=w> </span><span class=n>V8_PLATFORM_EXPORT</span><span class=w> </span><span class=n>TraceBufferChunk</span><span class=w> </span><span class=p>{</span>
<span class=w> </span><span class=n>public</span><span class=o>:</span>
<span class=w>  </span><span class=n>explicit</span><span class=w> </span><span class=n>TraceBufferChunk</span><span class=p>(</span><span class=kt>uint32_t</span><span class=w> </span><span class=n>seq</span><span class=p>);</span>

<span class=w>  </span><span class=kt>void</span><span class=w> </span><span class=nf>Reset</span><span class=p>(</span><span class=kt>uint32_t</span><span class=w> </span><span class=n>new_seq</span><span class=p>);</span>
<span class=w>  </span><span class=c1>// 数组是否满了</span>
<span class=w>  </span><span class=kt>bool</span><span class=w> </span><span class=nf>IsFull</span><span class=p>()</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>next_free_</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>kChunkSize</span><span class=p>;</span><span class=w> </span><span class=p>}</span>
<span class=w>  </span><span class=c1>// 获取一个空闲的元素地址</span>
<span class=w>  </span><span class=n>TraceObject</span><span class=o>*</span><span class=w> </span><span class=nf>AddTraceEvent</span><span class=p>(</span><span class=kt>size_t</span><span class=o>*</span><span class=w> </span><span class=n>event_index</span><span class=p>);</span>
<span class=w>  </span><span class=n>TraceObject</span><span class=o>*</span><span class=w> </span><span class=nf>GetEventAt</span><span class=p>(</span><span class=kt>size_t</span><span class=w> </span><span class=n>index</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=o>&amp;</span><span class=n>chunk_</span><span class=p>[</span><span class=n>index</span><span class=p>];</span><span class=w> </span><span class=p>}</span>

<span class=w>  </span><span class=kt>uint32_t</span><span class=w> </span><span class=nf>seq</span><span class=p>()</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>seq_</span><span class=p>;</span><span class=w> </span><span class=p>}</span>
<span class=w>  </span><span class=kt>size_t</span><span class=w> </span><span class=nf>size</span><span class=p>()</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>next_free_</span><span class=p>;</span><span class=w> </span><span class=p>}</span>

<span class=w>  </span><span class=k>static</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=kt>size_t</span><span class=w> </span><span class=n>kChunkSize</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>64</span><span class=p>;</span>

<span class=w> </span><span class=n>private</span><span class=o>:</span>
<span class=w>  </span><span class=kt>size_t</span><span class=w> </span><span class=n>next_free_</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span>
<span class=w>  </span><span class=n>TraceObject</span><span class=w> </span><span class=n>chunk_</span><span class=p>[</span><span class=n>kChunkSize</span><span class=p>];</span>
<span class=w>  </span><span class=kt>uint32_t</span><span class=w> </span><span class=n>seq_</span><span class=p>;</span>
<span class=p>};</span>
</code></pre></div></td></tr></table></div> 可以看到 TraceBufferChunk 内部持有一个 TraceObject 对象数组。</p> <h2 id=14-tracebuffer>1.4 TraceBuffer<a class=headerlink href=#14-tracebuffer title="Permanent link">&para;</a></h2> <p>TraceBuffer 是对 TraceBufferChunk 的封装，本身不存储数据。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span></pre></div></td><td class=code><div><pre><span></span><code><span class=n>class</span><span class=w> </span><span class=n>V8_PLATFORM_EXPORT</span><span class=w> </span><span class=n>TraceBuffer</span><span class=w> </span><span class=p>{</span>
<span class=w> </span><span class=n>public</span><span class=o>:</span>
<span class=w>  </span><span class=n>virtual</span><span class=w> </span><span class=n>TraceObject</span><span class=o>*</span><span class=w> </span><span class=n>AddTraceEvent</span><span class=p>(</span><span class=kt>uint64_t</span><span class=o>*</span><span class=w> </span><span class=n>handle</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span>
<span class=w>  </span><span class=n>virtual</span><span class=w> </span><span class=n>TraceObject</span><span class=o>*</span><span class=w> </span><span class=n>GetEventByHandle</span><span class=p>(</span><span class=kt>uint64_t</span><span class=w> </span><span class=n>handle</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span>
<span class=w>  </span><span class=n>virtual</span><span class=w> </span><span class=kt>bool</span><span class=w> </span><span class=n>Flush</span><span class=p>()</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span>

<span class=w>  </span><span class=k>static</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=kt>size_t</span><span class=w> </span><span class=n>kRingBufferChunks</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1024</span><span class=p>;</span>

<span class=w>  </span><span class=k>static</span><span class=w> </span><span class=n>TraceBuffer</span><span class=o>*</span><span class=w> </span><span class=nf>CreateTraceBufferRingBuffer</span><span class=p>(</span><span class=kt>size_t</span><span class=w> </span><span class=n>max_chunks</span><span class=p>,</span><span class=w> </span><span class=n>TraceWriter</span><span class=o>*</span><span class=w> </span><span class=n>trace_writer</span><span class=p>);</span>
<span class=p>};</span>
</code></pre></div></td></tr></table></div> TraceBuffer 具体的逻辑由子类实现，比如 Node.js 里实现了 NodeTraceBuffer。</p> <h2 id=15-traceconfig>1.5 TraceConfig<a class=headerlink href=#15-traceconfig title="Permanent link">&para;</a></h2> <p>TraceConfig 是用于管理 category，记录需要收集哪类 category 数据。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span></pre></div></td><td class=code><div><pre><span></span><code><span class=n>class</span><span class=w> </span><span class=n>V8_PLATFORM_EXPORT</span><span class=w> </span><span class=n>TraceConfig</span><span class=w> </span><span class=p>{</span>
<span class=w> </span><span class=n>public</span><span class=o>:</span>
<span class=w>  </span><span class=c1>// 获取默认 category =&gt; v8</span>
<span class=w>  </span><span class=k>static</span><span class=w> </span><span class=n>TraceConfig</span><span class=o>*</span><span class=w> </span><span class=n>CreateDefaultTraceConfig</span><span class=p>();</span>
<span class=w>  </span><span class=c1>// 获取订阅的 category</span>
<span class=w>  </span><span class=k>const</span><span class=w> </span><span class=n>StringList</span><span class=o>&amp;</span><span class=w> </span><span class=nf>GetEnabledCategories</span><span class=p>()</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>included_categories_</span><span class=p>;</span>
<span class=w>  </span><span class=p>}</span>
<span class=w>  </span><span class=c1>// 新增 category</span>
<span class=w>  </span><span class=kt>void</span><span class=w> </span><span class=nf>AddIncludedCategory</span><span class=p>(</span><span class=k>const</span><span class=w> </span><span class=kt>char</span><span class=o>*</span><span class=w> </span><span class=n>included_category</span><span class=p>);</span>
<span class=w>  </span><span class=c1>// 是否开启了收集该 cateogry 数据</span>
<span class=w>  </span><span class=kt>bool</span><span class=w> </span><span class=nf>IsCategoryGroupEnabled</span><span class=p>(</span><span class=k>const</span><span class=w> </span><span class=kt>char</span><span class=o>*</span><span class=w> </span><span class=n>category_group</span><span class=p>)</span><span class=w> </span><span class=k>const</span><span class=p>;</span>

<span class=w> </span><span class=n>private</span><span class=o>:</span>
<span class=w>  </span><span class=n>StringList</span><span class=w> </span><span class=n>included_categories_</span><span class=p>;</span>
<span class=p>};</span>
</code></pre></div></td></tr></table></div></p> <h2 id=16-tracingcontroller>1.6 TracingController<a class=headerlink href=#16-tracingcontroller title="Permanent link">&para;</a></h2> <p>TracingController 是非常核心的类，用于管理整个 trace 系统。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span>
<span class=normal>24</span>
<span class=normal>25</span>
<span class=normal>26</span>
<span class=normal>27</span></pre></div></td><td class=code><div><pre><span></span><code><span class=n>class</span><span class=w> </span><span class=n>TracingController</span><span class=w> </span><span class=p>{</span>
<span class=w> </span><span class=n>public</span><span class=o>:</span>
<span class=w>  </span><span class=c1>// 需要收集哪类 cateogry 的 trace 数据，子类实现</span>
<span class=w>  </span><span class=n>virtual</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=kt>uint8_t</span><span class=o>*</span><span class=w> </span><span class=n>GetCategoryGroupEnabled</span><span class=p>(</span><span class=k>const</span><span class=w> </span><span class=kt>char</span><span class=o>*</span><span class=w> </span><span class=n>name</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=k>static</span><span class=w> </span><span class=kt>uint8_t</span><span class=w> </span><span class=n>no</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span>
<span class=w>    </span><span class=k>return</span><span class=w> </span><span class=o>&amp;</span><span class=n>no</span><span class=p>;</span>
<span class=w>  </span><span class=p>}</span>
<span class=w>  </span><span class=c1>// 产生 trace 数据</span>
<span class=w>  </span><span class=n>virtual</span><span class=w> </span><span class=kt>uint64_t</span><span class=w> </span><span class=n>AddTraceEvent</span><span class=p>(...)</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=k>return</span><span class=w> </span><span class=mi>0</span><span class=p>;</span>
<span class=w>  </span><span class=p>}</span>
<span class=w>  </span><span class=n>virtual</span><span class=w> </span><span class=kt>uint64_t</span><span class=w> </span><span class=n>AddTraceEventWithTimestamp</span><span class=p>(...)</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=k>return</span><span class=w> </span><span class=mi>0</span><span class=p>;</span>
<span class=w>  </span><span class=p>}</span>
<span class=w>  </span><span class=n>virtual</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=n>UpdateTraceEventDuration</span><span class=p>(...)</span><span class=w> </span><span class=p>{}</span>

<span class=w>  </span><span class=n>class</span><span class=w> </span><span class=n>TraceStateObserver</span><span class=w> </span><span class=p>{</span>
<span class=w>   </span><span class=n>public</span><span class=o>:</span>
<span class=w>    </span><span class=n>virtual</span><span class=w> </span><span class=o>~</span><span class=n>TraceStateObserver</span><span class=p>()</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>default</span><span class=p>;</span>
<span class=w>    </span><span class=n>virtual</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=n>OnTraceEnabled</span><span class=p>()</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span>
<span class=w>    </span><span class=n>virtual</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=n>OnTraceDisabled</span><span class=p>()</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span>
<span class=w>  </span><span class=p>};</span>

<span class=w>  </span><span class=c1>// 管理 trace 系统的观察者</span>
<span class=w>  </span><span class=n>virtual</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=n>AddTraceStateObserver</span><span class=p>(</span><span class=n>TraceStateObserver</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=p>{}</span>
<span class=w>  </span><span class=n>virtual</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=n>RemoveTraceStateObserver</span><span class=p>(</span><span class=n>TraceStateObserver</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=p>{}</span>
<span class=p>};</span>
</code></pre></div></td></tr></table></div> TracingController 是一个基类，被下面一个 TracingController 继承，trace 使用方继承下面的 TracingController 类。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span>
<span class=normal>24</span>
<span class=normal>25</span>
<span class=normal>26</span>
<span class=normal>27</span></pre></div></td><td class=code><div><pre><span></span><code><span class=n>class</span><span class=w> </span><span class=n>V8_PLATFORM_EXPORT</span><span class=w> </span><span class=n>TracingController</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>public</span><span class=w> </span><span class=n>V8_PLATFORM_NON_EXPORTED_BASE</span><span class=p>(</span><span class=n>v8</span><span class=o>::</span><span class=n>TracingController</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w> </span><span class=n>public</span><span class=o>:</span>
<span class=w>  </span><span class=c1>// 设置保存数据的 buffer</span>
<span class=w>  </span><span class=kt>void</span><span class=w> </span><span class=n>Initialize</span><span class=p>(</span><span class=n>TraceBuffer</span><span class=o>*</span><span class=w> </span><span class=n>trace_buffer</span><span class=p>);</span>
<span class=w>  </span><span class=c1>// 判断是否需要收集 category 为 category_group 的数据</span>
<span class=w>  </span><span class=k>const</span><span class=w> </span><span class=kt>uint8_t</span><span class=o>*</span><span class=w> </span><span class=nf>GetCategoryGroupEnabled</span><span class=p>(</span><span class=k>const</span><span class=w> </span><span class=kt>char</span><span class=o>*</span><span class=w> </span><span class=n>category_group</span><span class=p>)</span><span class=w> </span><span class=n>override</span><span class=p>;</span>
<span class=w>  </span><span class=c1>// 把数据保存到 buffer 中</span>
<span class=w>  </span><span class=kt>uint64_t</span><span class=w> </span><span class=nf>AddTraceEvent</span><span class=p>(...)</span><span class=w> </span><span class=n>override</span><span class=p>;</span>
<span class=w>  </span><span class=kt>uint64_t</span><span class=w> </span><span class=nf>AddTraceEventWithTimestamp</span><span class=p>(...)</span><span class=w> </span><span class=n>override</span><span class=p>;</span>
<span class=w>  </span><span class=kt>void</span><span class=w> </span><span class=nf>UpdateTraceEventDuration</span><span class=p>(...)</span><span class=w> </span><span class=n>override</span><span class=p>;</span>
<span class=w>  </span><span class=c1>// 根据订阅的 category 设置开启标记，这时候才会收集 trace 数据</span>
<span class=w>  </span><span class=kt>void</span><span class=w> </span><span class=nf>StartTracing</span><span class=p>(</span><span class=n>TraceConfig</span><span class=o>*</span><span class=w> </span><span class=n>trace_config</span><span class=p>);</span>
<span class=w>  </span><span class=kt>void</span><span class=w> </span><span class=nf>StopTracing</span><span class=p>();</span>

<span class=w> </span><span class=n>private</span><span class=o>:</span>
<span class=w>  </span><span class=c1>// 根据订阅的 category 设置开启标记， StartTracing 中使用</span>
<span class=w>  </span><span class=kt>void</span><span class=w> </span><span class=n>UpdateCategoryGroupEnabledFlag</span><span class=p>(</span><span class=kt>size_t</span><span class=w> </span><span class=n>category_index</span><span class=p>);</span>
<span class=w>  </span><span class=kt>void</span><span class=w> </span><span class=nf>UpdateCategoryGroupEnabledFlags</span><span class=p>();</span>

<span class=w>  </span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>base</span><span class=o>::</span><span class=n>Mutex</span><span class=o>&gt;</span><span class=w> </span><span class=n>mutex_</span><span class=p>;</span>
<span class=w>  </span><span class=c1>// 订阅的 category</span>
<span class=w>  </span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>TraceConfig</span><span class=o>&gt;</span><span class=w> </span><span class=n>trace_config_</span><span class=p>;</span>
<span class=w>  </span><span class=c1>// 订阅者，StartTracing 时通知它们</span>
<span class=w>  </span><span class=n>std</span><span class=o>::</span><span class=n>unordered_set</span><span class=o>&lt;</span><span class=n>v8</span><span class=o>::</span><span class=n>TracingController</span><span class=o>::</span><span class=n>TraceStateObserver</span><span class=o>*&gt;</span><span class=w> </span><span class=n>observers_</span><span class=p>;</span>
<span class=w>  </span><span class=c1>// 保存数据的 buffer</span>
<span class=w>  </span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>TraceBuffer</span><span class=o>&gt;</span><span class=w> </span><span class=n>trace_buffer_</span><span class=p>;</span>
<span class=p>};</span>
</code></pre></div></td></tr></table></div> 以上的类关系如下。 <img alt src=https://img-blog.csdnimg.cn/c6cb91ec2b384e6499d62876dda2fa56.png> 了解了 V8 的 trace 架构后，我们接下来看 Node.js 基于这个架构做了哪些实现。</p> <h1 id=2-nodejs>2 Node.js 的实现<a class=headerlink href=#2-nodejs title="Permanent link">&para;</a></h1> <h2 id=21-internaltracebuffer>2.1 InternalTraceBuffer<a class=headerlink href=#21-internaltracebuffer title="Permanent link">&para;</a></h2> <p>InternalTraceBuffer 是 Node.js 实现用于封装 TraceBufferChunk 的。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span></pre></div></td><td class=code><div><pre><span></span><code><span class=n>class</span><span class=w> </span><span class=n>InternalTraceBuffer</span><span class=w> </span><span class=p>{</span>
<span class=w> </span><span class=n>public</span><span class=o>:</span>
<span class=w>  </span><span class=n>InternalTraceBuffer</span><span class=p>(</span><span class=kt>size_t</span><span class=w> </span><span class=n>max_chunks</span><span class=p>,</span><span class=w> </span><span class=kt>uint32_t</span><span class=w> </span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>Agent</span><span class=o>*</span><span class=w> </span><span class=n>agent</span><span class=p>);</span>
<span class=w>  </span><span class=n>TraceObject</span><span class=o>*</span><span class=w> </span><span class=nf>AddTraceEvent</span><span class=p>(</span><span class=kt>uint64_t</span><span class=o>*</span><span class=w> </span><span class=n>handle</span><span class=p>);</span>
<span class=w>  </span><span class=n>TraceObject</span><span class=o>*</span><span class=w> </span><span class=nf>GetEventByHandle</span><span class=p>(</span><span class=kt>uint64_t</span><span class=w> </span><span class=n>handle</span><span class=p>);</span>
<span class=w>  </span><span class=kt>void</span><span class=w> </span><span class=nf>Flush</span><span class=p>(</span><span class=kt>bool</span><span class=w> </span><span class=n>blocking</span><span class=p>);</span>
<span class=w>  </span><span class=kt>bool</span><span class=w> </span><span class=nf>IsFull</span><span class=p>()</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>total_chunks_</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>max_chunks_</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>chunks_</span><span class=p>[</span><span class=n>total_chunks_</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mi>1</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>IsFull</span><span class=p>();</span>
<span class=w>  </span><span class=p>}</span>

<span class=w> </span><span class=n>private</span><span class=o>:</span>
<span class=w>  </span><span class=kt>size_t</span><span class=w> </span><span class=n>max_chunks_</span><span class=p>;</span>
<span class=w>  </span><span class=n>Agent</span><span class=o>*</span><span class=w> </span><span class=n>agent_</span><span class=p>;</span>
<span class=w>  </span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>TraceBufferChunk</span><span class=o>&gt;&gt;</span><span class=w> </span><span class=n>chunks_</span><span class=p>;</span>
<span class=w>  </span><span class=kt>size_t</span><span class=w> </span><span class=n>total_chunks_</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span>
<span class=p>};</span>
</code></pre></div></td></tr></table></div> InternalTraceBuffer 内部 持有 TraceBufferChunk，用于保存数据。</p> <h2 id=22-nodetracebuffer>2.2 NodeTraceBuffer<a class=headerlink href=#22-nodetracebuffer title="Permanent link">&para;</a></h2> <p>NodeTraceBuffer 是基础 V8 的 TraceBuffer。用于管理数据的存储和消费。内部持有 InternalTraceBuffer，InternalTraceBuffer 内部的 TraceBufferChunk 用于真正的数据存储。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span></pre></div></td><td class=code><div><pre><span></span><code><span class=n>class</span><span class=w> </span><span class=n>NodeTraceBuffer</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>public</span><span class=w> </span><span class=n>TraceBuffer</span><span class=w> </span><span class=p>{</span>
<span class=w> </span><span class=n>public</span><span class=o>:</span>
<span class=w>  </span><span class=n>NodeTraceBuffer</span><span class=p>(</span><span class=kt>size_t</span><span class=w> </span><span class=n>max_chunks</span><span class=p>,</span><span class=w> </span><span class=n>Agent</span><span class=o>*</span><span class=w> </span><span class=n>agent</span><span class=p>,</span><span class=w> </span><span class=n>uv_loop_t</span><span class=o>*</span><span class=w> </span><span class=n>tracing_loop</span><span class=p>);</span>
<span class=w>  </span><span class=n>TraceObject</span><span class=o>*</span><span class=w> </span><span class=nf>AddTraceEvent</span><span class=p>(</span><span class=kt>uint64_t</span><span class=o>*</span><span class=w> </span><span class=n>handle</span><span class=p>)</span><span class=w> </span><span class=n>override</span><span class=p>;</span>
<span class=w>  </span><span class=n>TraceObject</span><span class=o>*</span><span class=w> </span><span class=nf>GetEventByHandle</span><span class=p>(</span><span class=kt>uint64_t</span><span class=w> </span><span class=n>handle</span><span class=p>)</span><span class=w> </span><span class=n>override</span><span class=p>;</span>
<span class=w>  </span><span class=kt>bool</span><span class=w> </span><span class=nf>Flush</span><span class=p>()</span><span class=w> </span><span class=n>override</span><span class=p>;</span>

<span class=w>  </span><span class=k>static</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=kt>size_t</span><span class=w> </span><span class=n>kBufferChunks</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1024</span><span class=p>;</span>

<span class=w> </span><span class=n>private</span><span class=o>:</span>
<span class=w>  </span><span class=n>uv_loop_t</span><span class=o>*</span><span class=w> </span><span class=n>tracing_loop_</span><span class=p>;</span>
<span class=w>  </span><span class=n>uv_async_t</span><span class=w> </span><span class=n>flush_signal_</span><span class=p>;</span>
<span class=w>  </span><span class=n>std</span><span class=o>::</span><span class=n>atomic</span><span class=o>&lt;</span><span class=n>InternalTraceBuffer</span><span class=o>*&gt;</span><span class=w> </span><span class=n>current_buf_</span><span class=p>;</span>
<span class=w>  </span><span class=n>InternalTraceBuffer</span><span class=w> </span><span class=n>buffer1_</span><span class=p>;</span>
<span class=w>  </span><span class=n>InternalTraceBuffer</span><span class=w> </span><span class=n>buffer2_</span><span class=p>;</span>
<span class=p>};</span>
</code></pre></div></td></tr></table></div></p> <h2 id=23-nodetracewriter>2.3 NodeTraceWriter<a class=headerlink href=#23-nodetracewriter title="Permanent link">&para;</a></h2> <p>NodeTraceWriter 用于处理数据的消费，比如写入文件。NodeTraceWriter 没有继承 V8 的 TraceWriter，而是持有一个 TraceWriter 对象。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span></pre></div></td><td class=code><div><pre><span></span><code><span class=c1>// AsyncTraceWriter 没有逻辑，可以忽略</span>
<span class=n>class</span><span class=w> </span><span class=n>NodeTraceWriter</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>public</span><span class=w> </span><span class=n>AsyncTraceWriter</span><span class=w> </span><span class=p>{</span>
<span class=w> </span><span class=n>public</span><span class=o>:</span>
<span class=w>  </span><span class=n>explicit</span><span class=w> </span><span class=n>NodeTraceWriter</span><span class=p>(</span><span class=k>const</span><span class=w> </span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span><span class=w> </span><span class=n>log_file_pattern</span><span class=p>);</span>
<span class=w>  </span><span class=c1>// 写入 trace 数据，保存在内存</span>
<span class=w>  </span><span class=kt>void</span><span class=w> </span><span class=nf>AppendTraceEvent</span><span class=p>(</span><span class=n>TraceObject</span><span class=o>*</span><span class=w> </span><span class=n>trace_event</span><span class=p>)</span><span class=w> </span><span class=n>override</span><span class=p>;</span>
<span class=w>  </span><span class=c1>// 刷数据到目的地，比如文件</span>
<span class=w>  </span><span class=kt>void</span><span class=w> </span><span class=nf>Flush</span><span class=p>(</span><span class=kt>bool</span><span class=w> </span><span class=n>blocking</span><span class=p>)</span><span class=w> </span><span class=n>override</span><span class=p>;</span>
<span class=w> </span><span class=n>private</span><span class=o>:</span>
<span class=w>  </span><span class=c1>// 数据写入该文件</span>
<span class=w>  </span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=w> </span><span class=n>log_file_pattern_</span><span class=p>;</span>
<span class=w>  </span><span class=n>std</span><span class=o>::</span><span class=n>ostringstream</span><span class=w> </span><span class=n>stream_</span><span class=p>;</span>
<span class=w>  </span><span class=c1>// 持有一个 TraceWriter 对象，具体是一个 json writer，即按 json 格式写入数据</span>
<span class=w>  </span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>TraceWriter</span><span class=o>&gt;</span><span class=w> </span><span class=n>json_trace_writer_</span><span class=p>;</span>
<span class=p>};</span>
</code></pre></div></td></tr></table></div></p> <h2 id=24-tracingcontroller>2.4 TracingController<a class=headerlink href=#24-tracingcontroller title="Permanent link">&para;</a></h2> <p>TracingController 继承 v8 的 TracingController，实现的逻辑不多。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span></pre></div></td><td class=code><div><pre><span></span><code><span class=n>class</span><span class=w> </span><span class=n>TracingController</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>public</span><span class=w> </span><span class=n>v8</span><span class=o>::</span><span class=n>platform</span><span class=o>::</span><span class=n>tracing</span><span class=o>::</span><span class=n>TracingController</span><span class=w> </span><span class=p>{</span>
<span class=w> </span><span class=n>public</span><span class=o>:</span>
<span class=w>  </span><span class=n>TracingController</span><span class=p>()</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>v8</span><span class=o>::</span><span class=n>platform</span><span class=o>::</span><span class=n>tracing</span><span class=o>::</span><span class=n>TracingController</span><span class=p>()</span><span class=w> </span><span class=p>{}</span>

<span class=w>  </span><span class=kt>int64_t</span><span class=w> </span><span class=n>CurrentTimestampMicroseconds</span><span class=p>()</span><span class=w> </span><span class=n>override</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>uv_hrtime</span><span class=p>()</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=mi>1000</span><span class=p>;</span>
<span class=w>  </span><span class=p>}</span>
<span class=w>  </span><span class=kt>void</span><span class=w> </span><span class=n>AddMetadataEvent</span><span class=p>(...)</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>TraceObject</span><span class=o>&gt;</span><span class=w> </span><span class=n>trace_event</span><span class=p>(</span><span class=n>new</span><span class=w> </span><span class=n>TraceObject</span><span class=p>);</span>
<span class=w>    </span><span class=n>trace_event</span><span class=o>-&gt;</span><span class=n>Initialize</span><span class=p>(...);</span>
<span class=w>    </span><span class=n>Agent</span><span class=o>*</span><span class=w> </span><span class=n>node_agent</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>node</span><span class=o>::</span><span class=n>tracing</span><span class=o>::</span><span class=n>TraceEventHelper</span><span class=o>::</span><span class=n>GetAgent</span><span class=p>();</span>
<span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>node_agent</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>nullptr</span><span class=p>)</span>
<span class=w>      </span><span class=n>node_agent</span><span class=o>-&gt;</span><span class=n>AddMetadataEvent</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>trace_event</span><span class=p>));</span>
<span class=w>  </span><span class=p>};</span>
<span class=p>};</span>
</code></pre></div></td></tr></table></div> TracingController 主要实现了产生 trace 数据的逻辑，每次产生一次 trace 事件时，就新建一个 TraceObject 对象表示，然后交给 agent 处理。</p> <h2 id=25-agent>2.5 Agent<a class=headerlink href=#25-agent title="Permanent link">&para;</a></h2> <p>Agent 是 Node.js 中 trace 系统的核心对象，用于管理整个 trace 系统。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span>
<span class=normal>24</span>
<span class=normal>25</span>
<span class=normal>26</span>
<span class=normal>27</span>
<span class=normal>28</span>
<span class=normal>29</span>
<span class=normal>30</span>
<span class=normal>31</span>
<span class=normal>32</span>
<span class=normal>33</span>
<span class=normal>34</span>
<span class=normal>35</span></pre></div></td><td class=code><div><pre><span></span><code><span class=n>class</span><span class=w> </span><span class=n>Agent</span><span class=w> </span><span class=p>{</span>
<span class=w> </span><span class=n>public</span><span class=o>:</span>
<span class=w>  </span><span class=n>TracingController</span><span class=o>*</span><span class=w> </span><span class=n>GetTracingController</span><span class=p>()</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=n>TracingController</span><span class=o>*</span><span class=w> </span><span class=n>controller</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>tracing_controller_</span><span class=p>.</span><span class=n>get</span><span class=p>();</span>
<span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>controller</span><span class=p>;</span>
<span class=w>  </span><span class=p>}</span>

<span class=w>  </span><span class=c1>// 增加一个 writer</span>
<span class=w>  </span><span class=n>AgentWriterHandle</span><span class=w> </span><span class=n>AddClient</span><span class=p>(</span><span class=k>const</span><span class=w> </span><span class=n>std</span><span class=o>::</span><span class=n>set</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;&amp;</span><span class=w> </span><span class=n>categories</span><span class=p>,</span>
<span class=w>                              </span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>AsyncTraceWriter</span><span class=o>&gt;</span><span class=w> </span><span class=n>writer</span><span class=p>,</span>
<span class=w>                              </span><span class=k>enum</span><span class=w> </span><span class=n>UseDefaultCategoryMode</span><span class=w> </span><span class=n>mode</span><span class=p>);</span>
<span class=w>  </span><span class=c1>// 获取订阅的 category，Node.js 本身缓存了这个数据，不需要到 V8 获取</span>
<span class=w>  </span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=w> </span><span class=nf>GetEnabledCategories</span><span class=p>()</span><span class=w> </span><span class=k>const</span><span class=p>;</span>

<span class=w>  </span><span class=c1>// 产生 trace 数据，通知所有 writer</span>
<span class=w>  </span><span class=kt>void</span><span class=w> </span><span class=nf>AppendTraceEvent</span><span class=p>(</span><span class=n>TraceObject</span><span class=o>*</span><span class=w> </span><span class=n>trace_event</span><span class=p>);</span>
<span class=w>  </span><span class=kt>void</span><span class=w> </span><span class=nf>AddMetadataEvent</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>TraceObject</span><span class=o>&gt;</span><span class=w> </span><span class=n>event</span><span class=p>);</span>
<span class=w>  </span><span class=c1>// 刷数据到目的地，比如文件</span>
<span class=w>  </span><span class=kt>void</span><span class=w> </span><span class=nf>Flush</span><span class=p>(</span><span class=kt>bool</span><span class=w> </span><span class=n>blocking</span><span class=p>);</span>
<span class=w>  </span><span class=c1>// 创建一个管理 category 的 TraceConfig 对象，并把缓存的 category 写到 v8</span>
<span class=w>  </span><span class=n>TraceConfig</span><span class=o>*</span><span class=w> </span><span class=nf>CreateTraceConfig</span><span class=p>()</span><span class=w> </span><span class=k>const</span><span class=p>;</span>

<span class=w> </span><span class=n>private</span><span class=o>:</span>
<span class=w>  </span><span class=c1>// 启动 agent，不是启动收集 trace 数据</span>
<span class=w>  </span><span class=kt>void</span><span class=w> </span><span class=n>Start</span><span class=p>();</span>
<span class=w>  </span><span class=kt>void</span><span class=w> </span><span class=nf>StopTracing</span><span class=p>();</span>
<span class=w>  </span><span class=c1>// 订阅/取消订阅 category</span>
<span class=w>  </span><span class=kt>void</span><span class=w> </span><span class=nf>Enable</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=n>std</span><span class=o>::</span><span class=n>set</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;&amp;</span><span class=w> </span><span class=n>categories</span><span class=p>);</span>
<span class=w>  </span><span class=kt>void</span><span class=w> </span><span class=nf>Disable</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=n>std</span><span class=o>::</span><span class=n>set</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;&amp;</span><span class=w> </span><span class=n>categories</span><span class=p>);</span>

<span class=w>  </span><span class=c1>// 保存 category、writer 和 controller</span>
<span class=w>  </span><span class=n>std</span><span class=o>::</span><span class=n>unordered_map</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span><span class=w> </span><span class=n>std</span><span class=o>::</span><span class=n>multiset</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;&gt;</span><span class=w> </span><span class=n>categories_</span><span class=p>;</span>
<span class=w>  </span><span class=n>std</span><span class=o>::</span><span class=n>unordered_map</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span><span class=w> </span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>AsyncTraceWriter</span><span class=o>&gt;&gt;</span><span class=w> </span><span class=n>writers_</span><span class=p>;</span>
<span class=w>  </span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>TracingController</span><span class=o>&gt;</span><span class=w> </span><span class=n>tracing_controller_</span><span class=p>;</span>
<span class=p>};</span>
</code></pre></div></td></tr></table></div></p> <h2 id=26-scopedsuspendtracing>2.6 ScopedSuspendTracing<a class=headerlink href=#26-scopedsuspendtracing title="Permanent link">&para;</a></h2> <p>ScopedSuspendTracing 利用 RAII 机制实现 category 的刷新，控制 category 的开启和关闭。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span></pre></div></td><td class=code><div><pre><span></span><code><span class=n>class</span><span class=w> </span><span class=n>Agent</span><span class=o>::</span><span class=n>ScopedSuspendTracing</span><span class=w> </span><span class=p>{</span>
<span class=w> </span><span class=n>public</span><span class=o>:</span>
<span class=w>  </span><span class=n>ScopedSuspendTracing</span><span class=p>(</span><span class=n>TracingController</span><span class=o>*</span><span class=w> </span><span class=n>controller</span><span class=p>,</span><span class=w> </span><span class=n>Agent</span><span class=o>*</span><span class=w> </span><span class=n>agent</span><span class=p>,</span>
<span class=w>                       </span><span class=kt>bool</span><span class=w> </span><span class=n>do_suspend</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>true</span><span class=p>)</span>
<span class=w>    </span><span class=o>:</span><span class=w> </span><span class=n>controller_</span><span class=p>(</span><span class=n>controller</span><span class=p>),</span><span class=w> </span><span class=n>agent_</span><span class=p>(</span><span class=n>do_suspend</span><span class=w> </span><span class=o>?</span><span class=w> </span><span class=n>agent</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>nullptr</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>do_suspend</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>      </span><span class=n>controller</span><span class=o>-&gt;</span><span class=n>StopTracing</span><span class=p>();</span>
<span class=w>    </span><span class=p>}</span>
<span class=w>  </span><span class=p>}</span>

<span class=w>  </span><span class=o>~</span><span class=n>ScopedSuspendTracing</span><span class=p>()</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>agent_</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>nullptr</span><span class=p>)</span><span class=w> </span><span class=k>return</span><span class=p>;</span>
<span class=w>    </span><span class=n>TraceConfig</span><span class=o>*</span><span class=w> </span><span class=n>config</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>agent_</span><span class=o>-&gt;</span><span class=n>CreateTraceConfig</span><span class=p>();</span>
<span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>config</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>nullptr</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>      </span><span class=n>controller_</span><span class=o>-&gt;</span><span class=n>StartTracing</span><span class=p>(</span><span class=n>config</span><span class=p>);</span>
<span class=w>    </span><span class=p>}</span>
<span class=w>  </span><span class=p>}</span>

<span class=w> </span><span class=n>private</span><span class=o>:</span>
<span class=w>  </span><span class=n>TracingController</span><span class=o>*</span><span class=w> </span><span class=n>controller_</span><span class=p>;</span>
<span class=w>  </span><span class=n>Agent</span><span class=o>*</span><span class=w> </span><span class=n>agent_</span><span class=p>;</span>
<span class=p>};</span>
</code></pre></div></td></tr></table></div> v8 中会记录当前开启了哪些 category，通过 StopTracing 可以清除所有的开启标记，然后再通过 StartTracing 和传入当前开启的 category 更新 v8 的数据。</p> <h2 id=27-nodetracestateobserver>2.7 NodeTraceStateObserver<a class=headerlink href=#27-nodetracestateobserver title="Permanent link">&para;</a></h2> <p>NodeTraceStateObserver 是 trace 的观察者，是 v8 提供的机制，在开启 trace 的时候会被执行。比如 Node.js 实现的观察者。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span></pre></div></td><td class=code><div><pre><span></span><code><span class=n>class</span><span class=w> </span><span class=n>NodeTraceStateObserver</span><span class=o>:</span><span class=w> </span><span class=n>public</span><span class=w> </span><span class=n>v8</span><span class=o>::</span><span class=n>TracingController</span><span class=o>::</span><span class=n>TraceStateObserver</span><span class=w> </span><span class=p>{</span>
<span class=w> </span><span class=n>public</span><span class=o>:</span>
<span class=w>  </span><span class=c1>//。trace 启动时被回调</span>
<span class=w>  </span><span class=kr>inline</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=n>OnTraceEnabled</span><span class=p>()</span><span class=w> </span><span class=n>override</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=c1>// 省略部分代码</span>
<span class=w>    </span><span class=n>trace_process</span><span class=o>-&gt;</span><span class=n>SetString</span><span class=p>(</span><span class=s>&quot;arch&quot;</span><span class=p>,</span><span class=w> </span><span class=n>per_process</span><span class=o>::</span><span class=n>metadata</span><span class=p>.</span><span class=n>arch</span><span class=p>.</span><span class=n>c_str</span><span class=p>());</span>
<span class=w>    </span><span class=n>trace_process</span><span class=o>-&gt;</span><span class=n>SetString</span><span class=p>(</span><span class=s>&quot;platform&quot;</span><span class=p>,</span><span class=w> </span><span class=n>per_process</span><span class=o>::</span><span class=n>metadata</span><span class=p>.</span><span class=n>platform</span><span class=p>.</span><span class=n>c_str</span><span class=p>());</span>
<span class=w>    </span><span class=n>trace_process</span><span class=o>-&gt;</span><span class=n>BeginDictionary</span><span class=p>(</span><span class=s>&quot;release&quot;</span><span class=p>);</span>
<span class=w>    </span><span class=n>trace_process</span><span class=o>-&gt;</span><span class=n>SetString</span><span class=p>(</span><span class=s>&quot;name&quot;</span><span class=p>,</span><span class=w> </span><span class=n>per_process</span><span class=o>::</span><span class=n>metadata</span><span class=p>.</span><span class=n>release</span><span class=p>.</span><span class=n>name</span><span class=p>.</span><span class=n>c_str</span><span class=p>());</span>
<span class=w>    </span><span class=c1>// 产生 trace 数据</span>
<span class=w>    </span><span class=n>TRACE_EVENT_METADATA1</span><span class=p>(</span><span class=s>&quot;__metadata&quot;</span><span class=p>,</span><span class=w> </span><span class=s>&quot;node&quot;</span><span class=p>,</span><span class=w> </span><span class=s>&quot;process&quot;</span><span class=p>,</span><span class=w> </span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>trace_process</span><span class=p>));</span>
<span class=w>  </span><span class=p>}</span>
<span class=w> </span><span class=n>private</span><span class=o>:</span>
<span class=w>  </span><span class=n>v8</span><span class=o>::</span><span class=n>TracingController</span><span class=o>*</span><span class=w> </span><span class=n>controller_</span><span class=p>;</span>
<span class=p>};</span>
</code></pre></div></td></tr></table></div> NodeTraceStateObserver 的逻辑很简单，就是在 trace 系统启动时执行 OnTraceEnabled，在 OnTraceEnabled 中会产生一个 trace 的 meta 数据。下面是架构图。 <img alt src=https://img-blog.csdnimg.cn/803a0cb426e44fa699cb4a175f8e6a9a.png></p> <h2 id=28-trace-agent>2.8 初始化 trace agent<a class=headerlink href=#28-trace-agent title="Permanent link">&para;</a></h2> <p>再看一下 Node.js 初始化的过程中关于 trace agent 的逻辑。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span>
<span class=normal>24</span>
<span class=normal>25</span>
<span class=normal>26</span>
<span class=normal>27</span>
<span class=normal>28</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>struct</span><span class=w> </span><span class=nc>V8Platform</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=kt>bool</span><span class=w> </span><span class=n>initialized_</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>false</span><span class=p>;</span>
<span class=w>    </span><span class=kr>inline</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>Initialize</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>thread_pool_size</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>        </span><span class=c1>// 创建一个 trace agent 对象</span>
<span class=w>        </span><span class=n>tracing_agent_</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>tracing</span><span class=o>::</span><span class=n>Agent</span><span class=o>&gt;</span><span class=p>();</span>
<span class=w>        </span><span class=c1>// 保存到某个地方，生产 trace 数据时使用</span>
<span class=w>        </span><span class=n>node</span><span class=o>::</span><span class=n>tracing</span><span class=o>::</span><span class=n>TraceEventHelper</span><span class=o>::</span><span class=n>SetAgent</span><span class=p>(</span><span class=n>tracing_agent_</span><span class=p>.</span><span class=n>get</span><span class=p>());</span>
<span class=w>        </span><span class=c1>// 获取 agent 中的 controller，controller 负责管理 trace 数据的生产</span>
<span class=w>        </span><span class=n>node</span><span class=o>::</span><span class=n>tracing</span><span class=o>::</span><span class=n>TracingController</span><span class=o>*</span><span class=w> </span><span class=n>controller</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>tracing_agent_</span><span class=o>-&gt;</span><span class=n>GetTracingController</span><span class=p>();</span>
<span class=w>        </span><span class=c1>// 创建一个 trace 观察者，在启动 trace 的时候被 V8 执行</span>
<span class=w>        </span><span class=n>trace_state_observer_</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>NodeTraceStateObserver</span><span class=o>&gt;</span><span class=p>(</span><span class=n>controller</span><span class=p>);</span>
<span class=w>        </span><span class=c1>// 保持到 controller 中</span>
<span class=w>        </span><span class=n>controller</span><span class=o>-&gt;</span><span class=n>AddTraceStateObserver</span><span class=p>(</span><span class=n>trace_state_observer_</span><span class=p>.</span><span class=n>get</span><span class=p>());</span>
<span class=w>        </span><span class=c1>// tracing_file_writer_ 设置为默认值</span>
<span class=w>        </span><span class=n>tracing_file_writer_</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>tracing_agent_</span><span class=o>-&gt;</span><span class=n>DefaultHandle</span><span class=p>();</span>
<span class=w>        </span><span class=c1>// 通过命令行启动</span>
<span class=w>        </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>per_process</span><span class=o>::</span><span class=n>cli_options</span><span class=o>-&gt;</span><span class=n>trace_event_categories</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span><span class=w> </span><span class=p>{</span>
<span class=w>          </span><span class=n>StartTracingAgent</span><span class=p>();</span>
<span class=w>        </span><span class=p>}</span>
<span class=w>    </span><span class=p>}</span>

<span class=w>    </span><span class=kr>inline</span><span class=w> </span><span class=n>tracing</span><span class=o>::</span><span class=n>AgentWriterHandle</span><span class=o>*</span><span class=w> </span><span class=nf>GetTracingAgentWriter</span><span class=p>()</span><span class=w> </span><span class=p>{</span>
<span class=w>      </span><span class=k>return</span><span class=w> </span><span class=o>&amp;</span><span class=n>tracing_file_writer_</span><span class=p>;</span>
<span class=w>    </span><span class=p>}</span>
<span class=w>    </span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>NodeTraceStateObserver</span><span class=o>&gt;</span><span class=w> </span><span class=n>trace_state_observer_</span><span class=p>;</span>
<span class=w>    </span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>tracing</span><span class=o>::</span><span class=n>Agent</span><span class=o>&gt;</span><span class=w> </span><span class=n>tracing_agent_</span><span class=p>;</span>
<span class=w>    </span><span class=n>tracing</span><span class=o>::</span><span class=n>AgentWriterHandle</span><span class=w> </span><span class=n>tracing_file_writer_</span><span class=p>;</span>
<span class=p>};</span>
</code></pre></div></td></tr></table></div> Initialize 主要是初始化了一些核心对象。继续看 StartTracingAgent。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span></pre></div></td><td class=code><div><pre><span></span><code><span class=kr>inline</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>StartTracingAgent</span><span class=p>()</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>tracing_file_writer_</span><span class=p>.</span><span class=n>IsDefaultHandle</span><span class=p>())</span><span class=w> </span><span class=p>{</span>
<span class=w>      </span><span class=c1>// 解析出命令后设置的需要 trace 的模块，如果设置了 --trace-events-enabled，则默认开启 v8,node,node.async_hooks</span>
<span class=w>      </span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span><span class=w> </span><span class=n>categories</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>SplitString</span><span class=p>(</span><span class=n>per_process</span><span class=o>::</span><span class=n>cli_options</span><span class=o>-&gt;</span><span class=n>trace_event_categories</span><span class=p>,</span><span class=w> </span><span class=sc>&#39;,&#39;</span><span class=p>);</span>
<span class=w>      </span><span class=c1>// 注册消费者 writer</span>
<span class=w>      </span><span class=n>tracing_file_writer_</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>tracing_agent_</span><span class=o>-&gt;</span><span class=n>AddClient</span><span class=p>(</span>
<span class=w>          </span><span class=n>std</span><span class=o>::</span><span class=n>set</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>make_move_iterator</span><span class=p>(</span><span class=n>categories</span><span class=p>.</span><span class=n>begin</span><span class=p>()),</span>
<span class=w>                                </span><span class=n>std</span><span class=o>::</span><span class=n>make_move_iterator</span><span class=p>(</span><span class=n>categories</span><span class=p>.</span><span class=n>end</span><span class=p>())),</span>
<span class=w>          </span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>tracing</span><span class=o>::</span><span class=n>AsyncTraceWriter</span><span class=o>&gt;</span><span class=p>(</span>
<span class=w>              </span><span class=n>new</span><span class=w> </span><span class=n>tracing</span><span class=o>::</span><span class=n>NodeTraceWriter</span><span class=p>(</span>
<span class=w>                  </span><span class=n>per_process</span><span class=o>::</span><span class=n>cli_options</span><span class=o>-&gt;</span><span class=n>trace_event_file_pattern</span><span class=p>)),</span>
<span class=w>          </span><span class=n>tracing</span><span class=o>::</span><span class=n>Agent</span><span class=o>::</span><span class=n>kUseDefaultCategories</span><span class=p>);</span>
<span class=w>    </span><span class=p>}</span>
<span class=p>}</span>
</code></pre></div></td></tr></table></div> 在 Node.js 初始化时，tracing_file_writer_ 为初始的默认值，所以如果还没有调用过 StartTracingAgent，则 IsDefaultHandle 为 true，反之 tracing_file_writer_ 会被 AddClient 重新赋值，第二次调用 StartTracingAgent 就直接返回了。当第一次执行 StartTracingAgent。IsDefaultHandle 为 true，接着解析出需要 trace 的模块，然后调用 agent 的 AddClient 函数注册消费者。看一下 AddClient。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span>
<span class=normal>24</span></pre></div></td><td class=code><div><pre><span></span><code><span class=n>AgentWriterHandle</span><span class=w> </span><span class=nf>Agent::AddClient</span><span class=p>(</span>
<span class=w>    </span><span class=k>const</span><span class=w> </span><span class=n>std</span><span class=o>::</span><span class=n>set</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;&amp;</span><span class=w> </span><span class=n>categories</span><span class=p>,</span>
<span class=w>    </span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>AsyncTraceWriter</span><span class=o>&gt;</span><span class=w> </span><span class=n>writer</span><span class=p>,</span>
<span class=w>    </span><span class=k>enum</span><span class=w> </span><span class=n>UseDefaultCategoryMode</span><span class=w> </span><span class=n>mode</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=c1>// 启动 trace 子线程，如果还没有启动的话</span>
<span class=w>  </span><span class=n>Start</span><span class=p>();</span>
<span class=w>  </span><span class=k>const</span><span class=w> </span><span class=n>std</span><span class=o>::</span><span class=n>set</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;*</span><span class=w> </span><span class=n>use_categories</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>categories</span><span class=p>;</span>
<span class=w>  </span><span class=kt>int</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>next_writer_id_</span><span class=o>++</span><span class=p>;</span>
<span class=w>  </span><span class=n>AsyncTraceWriter</span><span class=o>*</span><span class=w> </span><span class=n>raw</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>writer</span><span class=p>.</span><span class=n>get</span><span class=p>();</span>
<span class=w>  </span><span class=c1>// 记录 writer 和 trace 的模块</span>
<span class=w>  </span><span class=n>writers_</span><span class=p>[</span><span class=n>id</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>writer</span><span class=p>);</span>
<span class=w>  </span><span class=n>categories_</span><span class=p>[</span><span class=n>id</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>use_categories</span><span class=o>-&gt;</span><span class=n>begin</span><span class=p>(),</span><span class=w> </span><span class=n>use_categories</span><span class=o>-&gt;</span><span class=n>end</span><span class=p>()</span><span class=w> </span><span class=p>};</span>
<span class=w>  </span><span class=p>{</span>
<span class=w>    </span><span class=n>Mutex</span><span class=o>::</span><span class=n>ScopedLock</span><span class=w> </span><span class=n>lock</span><span class=p>(</span><span class=n>initialize_writer_mutex_</span><span class=p>);</span>
<span class=w>    </span><span class=c1>// 记录待初始化的 writer</span>
<span class=w>    </span><span class=n>to_be_initialized_</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>raw</span><span class=p>);</span>
<span class=w>    </span><span class=c1>// 通知 trace 子线程</span>
<span class=w>    </span><span class=n>uv_async_send</span><span class=p>(</span><span class=o>&amp;</span><span class=n>initialize_writer_async_</span><span class=p>);</span>
<span class=w>    </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=n>to_be_initialized_</span><span class=p>.</span><span class=n>count</span><span class=p>(</span><span class=n>raw</span><span class=p>)</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>0</span><span class=p>)</span>
<span class=w>      </span><span class=n>initialize_writer_condvar_</span><span class=p>.</span><span class=n>Wait</span><span class=p>(</span><span class=n>lock</span><span class=p>);</span>
<span class=w>  </span><span class=p>}</span>

<span class=w>  </span><span class=k>return</span><span class=w> </span><span class=n>AgentWriterHandle</span><span class=p>(</span><span class=n>this</span><span class=p>,</span><span class=w> </span><span class=n>id</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div></td></tr></table></div> AddClient 保存了订阅关系，另外 trace 系统部分逻辑是跑在子线程的。注册 writer 时如果还没有启动 trace 子线程则启动它。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span></pre></div></td><td class=code><div><pre><span></span><code><span class=n>Agent</span><span class=o>::</span><span class=n>Agent</span><span class=p>()</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>tracing_controller_</span><span class=p>(</span><span class=n>new</span><span class=w> </span><span class=n>TracingController</span><span class=p>())</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=n>tracing_controller_</span><span class=o>-&gt;</span><span class=n>Initialize</span><span class=p>(</span><span class=n>nullptr</span><span class=p>);</span>
<span class=w>  </span><span class=n>uv_loop_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tracing_loop_</span><span class=p>),</span><span class=w> </span><span class=mi>0</span><span class=p>;</span>
<span class=w>  </span><span class=c1>// 注册 writer 时执行的回调</span>
<span class=w>  </span><span class=n>uv_async_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tracing_loop_</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>initialize_writer_async_</span><span class=p>,</span><span class=w> </span><span class=p>[](</span><span class=n>uv_async_t</span><span class=o>*</span><span class=w> </span><span class=n>async</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=n>Agent</span><span class=o>*</span><span class=w> </span><span class=n>agent</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ContainerOf</span><span class=p>(</span><span class=o>&amp;</span><span class=n>Agent</span><span class=o>::</span><span class=n>initialize_writer_async_</span><span class=p>,</span><span class=w> </span><span class=n>async</span><span class=p>);</span>
<span class=w>    </span><span class=n>agent</span><span class=o>-&gt;</span><span class=n>InitializeWritersOnThread</span><span class=p>();</span>
<span class=w>  </span><span class=p>}),</span><span class=w> </span><span class=mi>0</span><span class=p>);</span>
<span class=w>  </span><span class=n>uv_unref</span><span class=p>(</span><span class=n>reinterpret_cast</span><span class=o>&lt;</span><span class=n>uv_handle_t</span><span class=o>*&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>initialize_writer_async_</span><span class=p>));</span>
<span class=p>}</span>

<span class=kt>void</span><span class=w> </span><span class=n>Agent</span><span class=o>::</span><span class=n>Start</span><span class=p>()</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>started_</span><span class=p>)</span>
<span class=w>    </span><span class=k>return</span><span class=p>;</span>

<span class=w>  </span><span class=n>NodeTraceBuffer</span><span class=o>*</span><span class=w> </span><span class=n>trace_buffer_</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>new</span><span class=w> </span><span class=n>NodeTraceBuffer</span><span class=p>(</span><span class=n>NodeTraceBuffer</span><span class=o>::</span><span class=n>kBufferChunks</span><span class=p>,</span><span class=w> </span><span class=n>this</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>tracing_loop_</span><span class=p>);</span>
<span class=w>  </span><span class=n>tracing_controller_</span><span class=o>-&gt;</span><span class=n>Initialize</span><span class=p>(</span><span class=n>trace_buffer_</span><span class=p>);</span>
<span class=w>  </span><span class=n>uv_thread_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>thread_</span><span class=p>,</span><span class=w> </span><span class=p>[](</span><span class=kt>void</span><span class=o>*</span><span class=w> </span><span class=n>arg</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=n>Agent</span><span class=o>*</span><span class=w> </span><span class=n>agent</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>static_cast</span><span class=o>&lt;</span><span class=n>Agent</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>arg</span><span class=p>);</span>
<span class=w>    </span><span class=n>uv_run</span><span class=p>(</span><span class=o>&amp;</span><span class=n>agent</span><span class=o>-&gt;</span><span class=n>tracing_loop_</span><span class=p>,</span><span class=w> </span><span class=n>UV_RUN_DEFAULT</span><span class=p>);</span>
<span class=w>  </span><span class=p>},</span><span class=w> </span><span class=n>this</span><span class=p>);</span>
<span class=w>  </span><span class=n>started_</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>true</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div></td></tr></table></div> Agent::Start 首先初始化了和生产者相关的逻辑，否则注册消费者 writer 就毫无意义，也就是设置保存数据的 NodeTraceBuffer 到 controller，因为 NodeTraceBuffer 是消费数据的第一个点，数据存到一定程度后再通知真正的 writer 消费。接着创建了一个线程，trace 子线程中单独跑了一个事件循环，并且通过异步方式和主线程通信，所以每次注册 writer 的时候，主线程都通过 uv_async_send(&amp;initialize_writer_async_) 通知 子线程。从而子线程执行回调 agent-&gt;InitializeWritersOnThread()。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span>
<span class=normal>7</span>
<span class=normal>8</span>
<span class=normal>9</span></pre></div></td><td class=code><div><pre><span></span><code><span class=kt>void</span><span class=w> </span><span class=nf>Agent::InitializeWritersOnThread</span><span class=p>()</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=n>Mutex</span><span class=o>::</span><span class=n>ScopedLock</span><span class=w> </span><span class=n>lock</span><span class=p>(</span><span class=n>initialize_writer_mutex_</span><span class=p>);</span>
<span class=w>  </span><span class=k>while</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>to_be_initialized_</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=n>AsyncTraceWriter</span><span class=o>*</span><span class=w> </span><span class=n>head</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>*</span><span class=n>to_be_initialized_</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span>
<span class=w>    </span><span class=n>head</span><span class=o>-&gt;</span><span class=n>InitializeOnThread</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tracing_loop_</span><span class=p>);</span>
<span class=w>    </span><span class=n>to_be_initialized_</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>head</span><span class=p>);</span>
<span class=w>  </span><span class=p>}</span>
<span class=w>  </span><span class=n>initialize_writer_condvar_</span><span class=p>.</span><span class=n>Broadcast</span><span class=p>(</span><span class=n>lock</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div></td></tr></table></div> InitializeWritersOnThread 遍历待注册的 writer 并执行它的 InitializeWritersOnThread 函数。这里以 Node.js 的 writer NodeTraceWriter 为例。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span>
<span class=normal>7</span>
<span class=normal>8</span></pre></div></td><td class=code><div><pre><span></span><code><span class=kt>void</span><span class=w> </span><span class=nf>NodeTraceWriter::InitializeOnThread</span><span class=p>(</span><span class=n>uv_loop_t</span><span class=o>*</span><span class=w> </span><span class=n>loop</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=n>tracing_loop_</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>loop</span><span class=p>;</span>
<span class=w>  </span><span class=n>flush_signal_</span><span class=p>.</span><span class=n>data</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>this</span><span class=p>;</span>
<span class=w>  </span><span class=kt>int</span><span class=w> </span><span class=n>err</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>uv_async_init</span><span class=p>(</span><span class=n>tracing_loop_</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>flush_signal_</span><span class=p>,</span><span class=w> </span><span class=p>[](</span><span class=n>uv_async_t</span><span class=o>*</span><span class=w> </span><span class=n>signal</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=n>NodeTraceWriter</span><span class=o>*</span><span class=w> </span><span class=n>trace_writer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ContainerOf</span><span class=p>(</span><span class=o>&amp;</span><span class=n>NodeTraceWriter</span><span class=o>::</span><span class=n>flush_signal_</span><span class=p>,</span><span class=w> </span><span class=n>signal</span><span class=p>);</span>
<span class=w>    </span><span class=n>trace_writer</span><span class=o>-&gt;</span><span class=n>FlushPrivate</span><span class=p>();</span>
<span class=w>  </span><span class=p>});</span>
<span class=p>}</span>
</code></pre></div></td></tr></table></div> writer 往子线程事件循环中注册了一个异步回调，这个回调会在需要写入数据到文件里被执行。</p> <h1 id=3>3 产生数据<a class=headerlink href=#3 title="Permanent link">&para;</a></h1> <p>Node.js 中 trace 数据通过两种方式产生，第一种方式是通过 Node.js C++ 层，第二种方式是在 JS 层通过 V8 提供的 trace C++ API。下面首先看一下第一种。</p> <h2 id=31-c>3.1 C++ 方式<a class=headerlink href=#31-c title="Permanent link">&para;</a></h2> <p>接下来分析生产者。以同步打开文件 API 为例。下面是 open 函数的 trace 埋点。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span></pre></div></td><td class=code><div><pre><span></span><code><span class=n>FS_SYNC_TRACE_BEGIN</span><span class=p>(</span><span class=n>open</span><span class=p>);</span>
<span class=kt>int</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>SyncCall</span><span class=p>(</span><span class=n>env</span><span class=p>,</span><span class=w> </span><span class=n>args</span><span class=p>[</span><span class=mi>4</span><span class=p>],</span><span class=w> </span><span class=o>&amp;</span><span class=n>req_wrap_sync</span><span class=p>,</span><span class=w> </span><span class=s>&quot;open&quot;</span><span class=p>,</span>
<span class=w>                      </span><span class=n>uv_fs_open</span><span class=p>,</span><span class=w> </span><span class=o>*</span><span class=n>path</span><span class=p>,</span><span class=w> </span><span class=n>flags</span><span class=p>,</span><span class=w> </span><span class=n>mode</span><span class=p>);</span>
<span class=n>FS_SYNC_TRACE_END</span><span class=p>(</span><span class=n>open</span><span class=p>);</span>
</code></pre></div></td></tr></table></div> 宏展开后 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span></pre></div></td><td class=code><div><pre><span></span><code><span class=cp>#define FS_SYNC_TRACE_BEGIN(syscall, ...)                                  \</span>
<span class=cp>  if (GET_TRACE_ENABLED)                                                   \</span>
<span class=cp>  TRACE_EVENT_BEGIN(TRACING_CATEGORY_NODE2(fs, sync), TRACE_NAME(syscall), \</span>
<span class=cp>  ##__VA_ARGS__);</span>
</code></pre></div></td></tr></table></div> 继续 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span></pre></div></td><td class=code><div><pre><span></span><code><span class=c1>// 判断是否订阅了当前模块的 trace</span>
<span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>*</span><span class=n>node</span><span class=o>::</span><span class=n>tracing</span><span class=o>::</span><span class=n>TraceEventHelper</span><span class=o>::</span><span class=n>GetCategoryGroupEnabled</span><span class=p>(</span><span class=s>&quot;node,node.fs,node.fs.sync&quot;</span><span class=p>)</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=mi>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=c1>// 通过 agent 的 controller 写入 trace 数据</span>
<span class=w>    </span><span class=n>controller</span><span class=o>-&gt;</span><span class=n>AddTraceEvent</span><span class=p>(...);</span>
<span class=p>}</span>
</code></pre></div></td></tr></table></div> 在处理 trace 数据之前首先判断是否开启了处理该类 trace 数据，看一下 GetCategoryGroupEnabled。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span>
<span class=normal>24</span>
<span class=normal>25</span>
<span class=normal>26</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>const</span><span class=w> </span><span class=kt>uint8_t</span><span class=o>*</span><span class=w> </span><span class=nf>TracingController::GetCategoryGroupEnabled</span><span class=p>(</span>
<span class=w>    </span><span class=k>const</span><span class=w> </span><span class=kt>char</span><span class=o>*</span><span class=w> </span><span class=n>category_group</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=c1>// category 个数  </span>
<span class=w>  </span><span class=kt>size_t</span><span class=w> </span><span class=n>category_index</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>base</span><span class=o>::</span><span class=n>Acquire_Load</span><span class=p>(</span><span class=o>&amp;</span><span class=n>g_category_index</span><span class=p>);</span>
<span class=w>  </span><span class=c1>// 遍历判断是否开启了当前的 category</span>
<span class=w>  </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>size_t</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>category_index</span><span class=p>;</span><span class=w> </span><span class=o>++</span><span class=n>i</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>strcmp</span><span class=p>(</span><span class=n>g_category_groups</span><span class=p>[</span><span class=n>i</span><span class=p>],</span><span class=w> </span><span class=n>category_group</span><span class=p>)</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>      </span><span class=k>return</span><span class=w> </span><span class=o>&amp;</span><span class=n>g_category_group_enabled</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
<span class=w>    </span><span class=p>}</span>
<span class=w>  </span><span class=p>}</span>
<span class=w>  </span><span class=c1>// 如果没有看开启则追加到 category 列表</span>
<span class=w>  </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>category_index</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>kMaxCategoryGroups</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=k>const</span><span class=w> </span><span class=kt>char</span><span class=o>*</span><span class=w> </span><span class=n>new_group</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>base</span><span class=o>::</span><span class=n>Strdup</span><span class=p>(</span><span class=n>category_group</span><span class=p>);</span>
<span class=w>    </span><span class=n>g_category_groups</span><span class=p>[</span><span class=n>category_index</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>new_group</span><span class=p>;</span>
<span class=w>    </span><span class=c1>// 根据 traceConfig 更新开关</span>
<span class=w>    </span><span class=n>UpdateCategoryGroupEnabledFlag</span><span class=p>(</span><span class=n>category_index</span><span class=p>);</span>
<span class=w>    </span><span class=c1>// 再次判断</span>
<span class=w>    </span><span class=n>category_group_enabled</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>g_category_group_enabled</span><span class=p>[</span><span class=n>category_index</span><span class=p>];</span>
<span class=w>    </span><span class=c1>// 更新 category 数量</span>
<span class=w>    </span><span class=n>base</span><span class=o>::</span><span class=n>Release_Store</span><span class=p>(</span><span class=o>&amp;</span><span class=n>g_category_index</span><span class=p>,</span><span class=w> </span><span class=n>category_index</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=p>);</span>
<span class=w>  </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=n>category_group_enabled</span><span class=w> </span><span class=o>=</span>
<span class=w>        </span><span class=o>&amp;</span><span class=n>g_category_group_enabled</span><span class=p>[</span><span class=n>g_category_categories_exhausted</span><span class=p>];</span>
<span class=w>  </span><span class=p>}</span>
<span class=w>  </span><span class=k>return</span><span class=w> </span><span class=n>category_group_enabled</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div></td></tr></table></div> 如果开启了收集该 category 则通过 AddTraceEvent 进行处理。AddTraceEvent 由 V8 实现。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span>
<span class=normal>7</span>
<span class=normal>8</span></pre></div></td><td class=code><div><pre><span></span><code><span class=kt>uint64_t</span><span class=w> </span><span class=nf>TracingController::AddTraceEvent</span><span class=p>(...)</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=kt>int64_t</span><span class=w> </span><span class=n>now_us</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>CurrentTimestampMicroseconds</span><span class=p>();</span>
<span class=w>  </span><span class=k>return</span><span class=w> </span><span class=n>AddTraceEventWithTimestamp</span><span class=p>(...);</span>
<span class=p>}</span>

<span class=kt>uint64_t</span><span class=w> </span><span class=nf>TracingController::AddTraceEventWithTimestamp</span><span class=p>(...)</span><span class=w> </span><span class=p>{</span>
<span class=w> </span><span class=n>TraceObject</span><span class=o>*</span><span class=w> </span><span class=n>trace_object</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>trace_buffer_</span><span class=o>-&gt;</span><span class=n>AddTraceEvent</span><span class=p>(</span><span class=o>&amp;</span><span class=n>handle</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div></td></tr></table></div> 通过层层调用，最终调用 TraceBuffer 的 AddTraceEvent，对应 Node.js 的 NodeTraceBuffer。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span>
<span class=normal>7</span>
<span class=normal>8</span>
<span class=normal>9</span></pre></div></td><td class=code><div><pre><span></span><code><span class=n>TraceObject</span><span class=o>*</span><span class=w> </span><span class=nf>NodeTraceBuffer::AddTraceEvent</span><span class=p>(</span><span class=kt>uint64_t</span><span class=o>*</span><span class=w> </span><span class=n>handle</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=c1>// buffer 是否已经满了，是则 flush</span>
<span class=w>  </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>TryLoadAvailableBuffer</span><span class=p>())</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=o>*</span><span class=n>handle</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span>
<span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>nullptr</span><span class=p>;</span>
<span class=w>  </span><span class=p>}</span>
<span class=w>  </span><span class=c1>// 否则缓存</span>
<span class=w>  </span><span class=k>return</span><span class=w> </span><span class=n>current_buf_</span><span class=p>.</span><span class=n>load</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>AddTraceEvent</span><span class=p>(</span><span class=n>handle</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div></td></tr></table></div> 我们只需要看 TryLoadAvailableBuffer。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span>
<span class=normal>7</span></pre></div></td><td class=code><div><pre><span></span><code><span class=kt>bool</span><span class=w> </span><span class=nf>NodeTraceBuffer::TryLoadAvailableBuffer</span><span class=p>()</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=n>InternalTraceBuffer</span><span class=o>*</span><span class=w> </span><span class=n>prev_buf</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>current_buf_</span><span class=p>.</span><span class=n>load</span><span class=p>();</span>
<span class=w>  </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>prev_buf</span><span class=o>-&gt;</span><span class=n>IsFull</span><span class=p>())</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=n>uv_async_send</span><span class=p>(</span><span class=o>&amp;</span><span class=n>flush_signal_</span><span class=p>);</span>
<span class=w>  </span><span class=p>}</span>
<span class=w>  </span><span class=k>return</span><span class=w> </span><span class=nb>true</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div></td></tr></table></div> 如果 buffer 满了，则通知 flush_signal_，那么 flush_signal_ 是什么呢？这是在 NodeTraceBuffer 初始化时设置的。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span>
<span class=normal>7</span>
<span class=normal>8</span>
<span class=normal>9</span></pre></div></td><td class=code><div><pre><span></span><code><span class=n>NodeTraceBuffer</span><span class=o>::</span><span class=n>NodeTraceBuffer</span><span class=p>(</span><span class=kt>size_t</span><span class=w> </span><span class=n>max_chunks</span><span class=p>,</span>
<span class=w>    </span><span class=n>Agent</span><span class=o>*</span><span class=w> </span><span class=n>agent</span><span class=p>,</span><span class=w> </span><span class=n>uv_loop_t</span><span class=o>*</span><span class=w> </span><span class=n>tracing_loop</span><span class=p>)</span>
<span class=w>    </span><span class=o>:</span><span class=w> </span><span class=n>tracing_loop_</span><span class=p>(</span><span class=n>tracing_loop</span><span class=p>),</span>
<span class=w>      </span><span class=n>buffer1_</span><span class=p>(</span><span class=n>max_chunks</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=n>agent</span><span class=p>),</span>
<span class=w>      </span><span class=n>buffer2_</span><span class=p>(</span><span class=n>max_chunks</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>,</span><span class=w> </span><span class=n>agent</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=n>flush_signal_</span><span class=p>.</span><span class=n>data</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>this</span><span class=p>;</span>
<span class=w>  </span><span class=c1>// 回调 NonBlockingFlushSignalCb</span>
<span class=w>  </span><span class=kt>int</span><span class=w> </span><span class=n>err</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>uv_async_init</span><span class=p>(</span><span class=n>tracing_loop_</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>flush_signal_</span><span class=p>,</span><span class=n>NonBlockingFlushSignalCb</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div></td></tr></table></div> 可以看到 NodeTraceBuffer 在 trace 子线程中设置了一个回调，当主线程写入的 trace 数据满了则通知子线程处理。具体逻辑在 NonBlockingFlushSignalCb。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span>
<span class=normal>7</span>
<span class=normal>8</span>
<span class=normal>9</span></pre></div></td><td class=code><div><pre><span></span><code><span class=kt>void</span><span class=w> </span><span class=nf>NodeTraceBuffer::NonBlockingFlushSignalCb</span><span class=p>(</span><span class=n>uv_async_t</span><span class=o>*</span><span class=w> </span><span class=n>signal</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=n>NodeTraceBuffer</span><span class=o>*</span><span class=w> </span><span class=n>buffer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>static_cast</span><span class=o>&lt;</span><span class=n>NodeTraceBuffer</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>signal</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>);</span>
<span class=w>  </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>buffer1_</span><span class=p>.</span><span class=n>IsFull</span><span class=p>()</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=o>!</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>buffer1_</span><span class=p>.</span><span class=n>IsFlushing</span><span class=p>())</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>buffer1_</span><span class=p>.</span><span class=n>Flush</span><span class=p>(</span><span class=nb>false</span><span class=p>);</span>
<span class=w>  </span><span class=p>}</span>
<span class=w>  </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>buffer2_</span><span class=p>.</span><span class=n>IsFull</span><span class=p>()</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=o>!</span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>buffer2_</span><span class=p>.</span><span class=n>IsFlushing</span><span class=p>())</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=n>buffer</span><span class=o>-&gt;</span><span class=n>buffer2_</span><span class=p>.</span><span class=n>Flush</span><span class=p>(</span><span class=nb>false</span><span class=p>);</span>
<span class=w>  </span><span class=p>}</span>
<span class=p>}</span>
</code></pre></div></td></tr></table></div> NodeTraceBuffer 内部维护了几个内部 buffer 用于存储数据（InternalTraceBuffer 对象）。当 内部 buffer 满了则调用 Flush。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span></pre></div></td><td class=code><div><pre><span></span><code><span class=kt>void</span><span class=w> </span><span class=nf>InternalTraceBuffer::Flush</span><span class=p>(</span><span class=kt>bool</span><span class=w> </span><span class=n>blocking</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=p>{</span>
<span class=w>    </span><span class=n>Mutex</span><span class=o>::</span><span class=n>ScopedLock</span><span class=w> </span><span class=n>scoped_lock</span><span class=p>(</span><span class=n>mutex_</span><span class=p>);</span>
<span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>total_chunks_</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=mi>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>      </span><span class=n>flushing_</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>true</span><span class=p>;</span>
<span class=w>      </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>size_t</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>total_chunks_</span><span class=p>;</span><span class=w> </span><span class=o>++</span><span class=n>i</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>        </span><span class=k>auto</span><span class=o>&amp;</span><span class=w> </span><span class=n>chunk</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>chunks_</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
<span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>size_t</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=n>j</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>chunk</span><span class=o>-&gt;</span><span class=n>size</span><span class=p>();</span><span class=w> </span><span class=o>++</span><span class=n>j</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>          </span><span class=n>TraceObject</span><span class=o>*</span><span class=w> </span><span class=n>trace_event</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>chunk</span><span class=o>-&gt;</span><span class=n>GetEventAt</span><span class=p>(</span><span class=n>j</span><span class=p>);</span>
<span class=w>          </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>trace_event</span><span class=o>-&gt;</span><span class=n>name</span><span class=p>())</span><span class=w> </span><span class=p>{</span>
<span class=w>            </span><span class=c1>// 交给 agent 处理</span>
<span class=w>            </span><span class=n>agent_</span><span class=o>-&gt;</span><span class=n>AppendTraceEvent</span><span class=p>(</span><span class=n>trace_event</span><span class=p>);</span>
<span class=w>          </span><span class=p>}</span>
<span class=w>        </span><span class=p>}</span>
<span class=w>      </span><span class=p>}</span>
<span class=w>      </span><span class=n>total_chunks_</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span>
<span class=w>      </span><span class=n>flushing_</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>false</span><span class=p>;</span>
<span class=w>    </span><span class=p>}</span>
<span class=w>  </span><span class=p>}</span>
<span class=w>  </span><span class=n>agent_</span><span class=o>-&gt;</span><span class=n>Flush</span><span class=p>(</span><span class=n>blocking</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div></td></tr></table></div> Flush 最终会通知 agent 进行数据的处理并调用 agent 的 Flush。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span>
<span class=normal>7</span>
<span class=normal>8</span>
<span class=normal>9</span></pre></div></td><td class=code><div><pre><span></span><code><span class=kt>void</span><span class=w> </span><span class=nf>Agent::AppendTraceEvent</span><span class=p>(</span><span class=n>TraceObject</span><span class=o>*</span><span class=w> </span><span class=n>trace_event</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=k>const</span><span class=w> </span><span class=k>auto</span><span class=o>&amp;</span><span class=w> </span><span class=n>id_writer</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>writers_</span><span class=p>)</span>
<span class=w>    </span><span class=n>id_writer</span><span class=p>.</span><span class=n>second</span><span class=o>-&gt;</span><span class=n>AppendTraceEvent</span><span class=p>(</span><span class=n>trace_event</span><span class=p>);</span>
<span class=p>}</span>

<span class=kt>void</span><span class=w> </span><span class=nf>Agent::Flush</span><span class=p>(</span><span class=kt>bool</span><span class=w> </span><span class=n>blocking</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=k>const</span><span class=w> </span><span class=k>auto</span><span class=o>&amp;</span><span class=w> </span><span class=n>id_writer</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>writers_</span><span class=p>)</span>
<span class=w>    </span><span class=n>id_writer</span><span class=p>.</span><span class=n>second</span><span class=o>-&gt;</span><span class=n>Flush</span><span class=p>(</span><span class=n>blocking</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div></td></tr></table></div> agent 也只是简单调用 writer 进行数据的消费。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span></pre></div></td><td class=code><div><pre><span></span><code><span class=kt>void</span><span class=w> </span><span class=nf>NodeTraceWriter::AppendTraceEvent</span><span class=p>(</span><span class=n>TraceObject</span><span class=o>*</span><span class=w> </span><span class=n>trace_event</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=n>Mutex</span><span class=o>::</span><span class=n>ScopedLock</span><span class=w> </span><span class=n>scoped_lock</span><span class=p>(</span><span class=n>stream_mutex_</span><span class=p>);</span>
<span class=w>  </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>total_traces_</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=c1>// 打开 trace 文件</span>
<span class=w>    </span><span class=n>OpenNewFileForStreaming</span><span class=p>();</span>
<span class=w>    </span><span class=n>json_trace_writer_</span><span class=p>.</span><span class=n>reset</span><span class=p>(</span><span class=n>TraceWriter</span><span class=o>::</span><span class=n>CreateJSONTraceWriter</span><span class=p>(</span><span class=n>stream_</span><span class=p>));</span>
<span class=w>  </span><span class=p>}</span>
<span class=w>  </span><span class=o>++</span><span class=n>total_traces_</span><span class=p>;</span>
<span class=w>  </span><span class=c1>// 缓存数据</span>
<span class=w>  </span><span class=n>json_trace_writer_</span><span class=o>-&gt;</span><span class=n>AppendTraceEvent</span><span class=p>(</span><span class=n>trace_event</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div></td></tr></table></div> AppendTraceEvent 只是把数据放到内存里。等待 Flush 时写到文件。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span></pre></div></td><td class=code><div><pre><span></span><code><span class=kt>void</span><span class=w> </span><span class=nf>NodeTraceWriter::Flush</span><span class=p>(</span><span class=kt>bool</span><span class=w> </span><span class=n>blocking</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=kt>int</span><span class=w> </span><span class=n>err</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>uv_async_send</span><span class=p>(</span><span class=o>&amp;</span><span class=n>flush_signal_</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div></td></tr></table></div> 最终通过 uv_async_send 通知 writer，因为 writer 是在子线程里执行的。这个在介绍 Node.js 初始化部分介绍过。具体处理函数是 trace_writer-&gt;FlushPrivate()，这个函数就是把数据写到 trace 文件，就不再具体分析。</p> <h2 id=31-js>3.1 JS 方式<a class=headerlink href=#31-js title="Permanent link">&para;</a></h2> <p>JS 方式是通过 v8 提供的 trace 函数。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span></pre></div></td><td class=code><div><pre><span></span><code><span class=c1>// binding.trace(phase, category, name, id, data)</span>
<span class=w>  </span><span class=n>SimpleInstallFunction</span><span class=p>(</span><span class=n>isolate</span><span class=p>(),</span><span class=w> </span><span class=n>extras_binding</span><span class=p>,</span><span class=w> </span><span class=s>&quot;trace&quot;</span><span class=p>,</span><span class=w> </span><span class=n>Builtin</span><span class=o>::</span><span class=n>kTrace</span><span class=p>,</span><span class=w> </span><span class=mi>5</span><span class=p>,</span><span class=w> </span><span class=nb>true</span><span class=p>);</span>
</code></pre></div></td></tr></table></div> 上面的代码来自 V8，V8 注册了 trace 函数，对应的实现如下。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span></pre></div></td><td class=code><div><pre><span></span><code><span class=c1>// Builtin::kTrace(phase, category, name, id, data)</span>
<span class=n>BUILTIN</span><span class=p>(</span><span class=n>Trace</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=n>HandleScope</span><span class=w> </span><span class=nf>handle_scope</span><span class=p>(</span><span class=n>isolate</span><span class=p>);</span>
<span class=w>  </span><span class=n>Handle</span><span class=o>&lt;</span><span class=n>Object</span><span class=o>&gt;</span><span class=w> </span><span class=n>phase_arg</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>args</span><span class=p>.</span><span class=n>atOrUndefined</span><span class=p>(</span><span class=n>isolate</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>);</span>
<span class=w>  </span><span class=n>Handle</span><span class=o>&lt;</span><span class=n>Object</span><span class=o>&gt;</span><span class=w> </span><span class=n>category</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>args</span><span class=p>.</span><span class=n>atOrUndefined</span><span class=p>(</span><span class=n>isolate</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>);</span>
<span class=w>  </span><span class=n>Handle</span><span class=o>&lt;</span><span class=n>Object</span><span class=o>&gt;</span><span class=w> </span><span class=n>name_arg</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>args</span><span class=p>.</span><span class=n>atOrUndefined</span><span class=p>(</span><span class=n>isolate</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>);</span>
<span class=w>  </span><span class=n>Handle</span><span class=o>&lt;</span><span class=n>Object</span><span class=o>&gt;</span><span class=w> </span><span class=n>id_arg</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>args</span><span class=p>.</span><span class=n>atOrUndefined</span><span class=p>(</span><span class=n>isolate</span><span class=p>,</span><span class=w> </span><span class=mi>4</span><span class=p>);</span>
<span class=w>  </span><span class=n>Handle</span><span class=o>&lt;</span><span class=n>Object</span><span class=o>&gt;</span><span class=w> </span><span class=n>data_arg</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>args</span><span class=p>.</span><span class=n>atOrUndefined</span><span class=p>(</span><span class=n>isolate</span><span class=p>,</span><span class=w> </span><span class=mi>5</span><span class=p>);</span>
<span class=w>  </span><span class=c1>// 判断是否开启了该 category </span>
<span class=w>  </span><span class=k>const</span><span class=w> </span><span class=kt>uint8_t</span><span class=o>*</span><span class=w> </span><span class=n>category_group_enabled</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>GetCategoryGroupEnabled</span><span class=p>(</span><span class=n>isolate</span><span class=p>,</span><span class=w> </span><span class=n>Handle</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;::</span><span class=n>cast</span><span class=p>(</span><span class=n>category</span><span class=p>));</span>
<span class=w>  </span><span class=c1>// 没开启则不处理</span>
<span class=w>  </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!*</span><span class=n>category_group_enabled</span><span class=p>)</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=n>ReadOnlyRoots</span><span class=p>(</span><span class=n>isolate</span><span class=p>).</span><span class=n>false_value</span><span class=p>();</span>
<span class=w>  </span><span class=c1>// 忽略细节处理</span>
<span class=w>  </span><span class=c1>// 开启则处理</span>
<span class=w>  </span><span class=n>TRACE_EVENT_API_ADD_TRACE_EVENT</span><span class=p>(</span>
<span class=w>      </span><span class=n>phase</span><span class=p>,</span><span class=w> </span><span class=n>category_group_enabled</span><span class=p>,</span><span class=w> </span><span class=o>*</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>tracing</span><span class=o>::</span><span class=n>kGlobalScope</span><span class=p>,</span><span class=w> </span><span class=n>id</span><span class=p>,</span>
<span class=w>      </span><span class=n>tracing</span><span class=o>::</span><span class=n>kNoId</span><span class=p>,</span><span class=w> </span><span class=n>num_args</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>arg_name</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>arg_type</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>arg_value</span><span class=p>,</span><span class=w> </span><span class=n>flags</span><span class=p>);</span>

<span class=w>  </span><span class=k>return</span><span class=w> </span><span class=n>ReadOnlyRoots</span><span class=p>(</span><span class=n>isolate</span><span class=p>).</span><span class=n>true_value</span><span class=p>();</span>
<span class=p>}</span>
</code></pre></div></td></tr></table></div> trace 的实现很简单，产生 trace 数据时需要指定的 category，所以第一步首先判断是否开启了该 category 的数据收集，如果没有开启则不进行数据处理，所以 trace 系统在这时候就没有性能损失的，如果开启了则进行处理，下面看一下具体的处理逻辑。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span></pre></div></td><td class=code><div><pre><span></span><code><span class=cp>#define TRACE_EVENT_API_ADD_TRACE_EVENT v8::internal::tracing::AddTraceEventImpl</span>

<span class=k>static</span><span class=w> </span><span class=n>V8_INLINE</span><span class=w> </span><span class=kt>uint64_t</span><span class=w> </span><span class=n>AddTraceEventImpl</span><span class=p>(...)</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=n>v8</span><span class=o>::</span><span class=n>TracingController</span><span class=o>*</span><span class=w> </span><span class=n>controller</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>v8</span><span class=o>::</span><span class=n>internal</span><span class=o>::</span><span class=n>tracing</span><span class=o>::</span><span class=n>TraceEventHelper</span><span class=o>::</span><span class=n>GetTracingController</span><span class=p>();</span>
<span class=w>  </span><span class=k>return</span><span class=w> </span><span class=n>controller</span><span class=o>-&gt;</span><span class=n>AddTraceEvent</span><span class=p>(...);</span>
<span class=p>}</span>
</code></pre></div></td></tr></table></div> AddTraceEvent 刚才已经分析过，就不再分析。</p> <p>两种产生数据的方式最终殊途同归，但是以上两种方式都是内置在 Node.js 内核的，用户侧无法使用，最近给 Node.js 社区提交了一个 pr（<a href=https://github.com/nodejs/node/pull/42462>https://github.com/nodejs/node/pull/42462</a>），把第二种方式通过 trace_events 模块导出来给用户使用。</p> <h1 id=4>4 收集数据<a class=headerlink href=#4 title="Permanent link">&para;</a></h1> <p>接下来介绍获取数据的逻辑。因为产生和消费 trace 数据会造成额外的开销，所以默认是不开启的，当我们需要收集这些数据的时候，首先需要主动订阅。一共有三种方式。</p> <h2 id=41>4.1 命令行方式<a class=headerlink href=#41 title="Permanent link">&para;</a></h2> <p>第一种是在启动 Node.js 时 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span></pre></div></td><td class=code><div><pre><span></span><code><span class=n>node</span><span class=w> </span><span class=o>--</span><span class=n>trace</span><span class=o>-</span><span class=n>event</span><span class=o>-</span><span class=n>categories</span><span class=w> </span><span class=n>v8</span><span class=w> </span><span class=o>--</span><span class=n>trace</span><span class=o>-</span><span class=n>event</span><span class=o>-</span><span class=n>file</span><span class=o>-</span><span class=n>pattern</span><span class=w> </span><span class=err>&#39;</span><span class=n>$</span><span class=p>{</span><span class=n>pid</span><span class=p>}</span><span class=o>-</span><span class=n>$</span><span class=p>{</span><span class=n>rotation</span><span class=p>}.</span><span class=n>log</span><span class=err>&#39;</span><span class=w> </span><span class=n>server</span><span class=p>.</span><span class=n>js</span>
</code></pre></div></td></tr></table></div> 通过 trace-event-categories 可以指定订阅的 category（trace 数据按 category 分类）。通过 trace-event-file-pattern 可以指定文件的格式。这样启动 Node.js 进程后，Node.js 就会把相应 category 的数据写入到某个文件中。这种方式存在比较在的限制，因为需要在启动时指定。</p> <h2 id=42-trace_events>4.2 通过 trace_events 模块<a class=headerlink href=#42-trace_events title="Permanent link">&para;</a></h2> <p>第二种方式就是动态开启。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>const</span><span class=w> </span><span class=n>trace_events</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>require</span><span class=p>(</span><span class=err>&#39;</span><span class=n>trace_events</span><span class=err>&#39;</span><span class=p>);</span>
<span class=k>const</span><span class=w> </span><span class=n>categories</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=err>&#39;</span><span class=n>node</span><span class=p>.</span><span class=n>perf</span><span class=err>&#39;</span><span class=p>,</span><span class=w> </span><span class=err>&#39;</span><span class=n>node</span><span class=p>.</span><span class=n>async_hooks</span><span class=err>&#39;</span><span class=p>];</span>
<span class=k>const</span><span class=w> </span><span class=n>tracing</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>trace_events</span><span class=p>.</span><span class=n>createTracing</span><span class=p>({</span><span class=w> </span><span class=n>categories</span><span class=w> </span><span class=p>});</span>
<span class=n>tracing</span><span class=p>.</span><span class=n>enable</span><span class=p>();</span>
<span class=c1>// do something</span>
<span class=n>tracing</span><span class=p>.</span><span class=n>disable</span><span class=p>();</span>
</code></pre></div></td></tr></table></div> 通过 createTracing 可以创建一个 trace 对象。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span></pre></div></td><td class=code><div><pre><span></span><code><span class=n>function</span><span class=w> </span><span class=nf>createTracing</span><span class=p>(</span><span class=n>options</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=k>return</span><span class=w> </span><span class=n>new</span><span class=w> </span><span class=n>Tracing</span><span class=p>(</span><span class=n>options</span><span class=p>.</span><span class=n>categories</span><span class=p>);</span>
<span class=p>}</span>

<span class=n>class</span><span class=w> </span><span class=n>Tracing</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=n>constructor</span><span class=p>(</span><span class=n>categories</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=n>this</span><span class=p>[</span><span class=n>kHandle</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>new</span><span class=w> </span><span class=n>CategorySet</span><span class=p>(</span><span class=n>categories</span><span class=p>);</span>
<span class=w>    </span><span class=n>this</span><span class=p>[</span><span class=n>kCategories</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>categories</span><span class=p>;</span>
<span class=w>    </span><span class=n>this</span><span class=p>[</span><span class=n>kEnabled</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>false</span><span class=p>;</span>
<span class=w>  </span><span class=p>}</span>

<span class=w>  </span><span class=n>enable</span><span class=p>()</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>this</span><span class=p>[</span><span class=n>kEnabled</span><span class=p>])</span><span class=w> </span><span class=p>{</span>
<span class=w>      </span><span class=n>this</span><span class=p>[</span><span class=n>kEnabled</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>true</span><span class=p>;</span>
<span class=w>      </span><span class=n>this</span><span class=p>[</span><span class=n>kHandle</span><span class=p>].</span><span class=n>enable</span><span class=p>();</span>
<span class=w>    </span><span class=p>}</span>
<span class=w>  </span><span class=p>}</span>
<span class=p>}</span>
</code></pre></div></td></tr></table></div> 新建了一个 CategorySet 对象然后调用其 enable 函数。可以看到，js 层只是对底层 CategorySet 的简单封装。接着看 C++ 层。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span></pre></div></td><td class=code><div><pre><span></span><code><span class=n>class</span><span class=w> </span><span class=n>NodeCategorySet</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>public</span><span class=w> </span><span class=n>BaseObject</span><span class=w> </span><span class=p>{</span>
<span class=w> </span><span class=n>public</span><span class=o>:</span>

<span class=w>  </span><span class=k>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=n>New</span><span class=p>(</span><span class=k>const</span><span class=w> </span><span class=n>FunctionCallbackInfo</span><span class=o>&lt;</span><span class=n>Value</span><span class=o>&gt;&amp;</span><span class=w> </span><span class=n>args</span><span class=p>);</span>
<span class=w>  </span><span class=k>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>Enable</span><span class=p>(</span><span class=k>const</span><span class=w> </span><span class=n>FunctionCallbackInfo</span><span class=o>&lt;</span><span class=n>Value</span><span class=o>&gt;&amp;</span><span class=w> </span><span class=n>args</span><span class=p>);</span>
<span class=w>  </span><span class=k>static</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>Disable</span><span class=p>(</span><span class=k>const</span><span class=w> </span><span class=n>FunctionCallbackInfo</span><span class=o>&lt;</span><span class=n>Value</span><span class=o>&gt;&amp;</span><span class=w> </span><span class=n>args</span><span class=p>);</span>
<span class=w> </span><span class=n>private</span><span class=o>:</span>

<span class=w>  </span><span class=kt>bool</span><span class=w> </span><span class=n>enabled_</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>false</span><span class=p>;</span>
<span class=w>  </span><span class=k>const</span><span class=w> </span><span class=n>std</span><span class=o>::</span><span class=n>set</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span><span class=w> </span><span class=n>categories_</span><span class=p>;</span><span class=w> </span><span class=c1>// 对象关联的 trace 模块</span>
<span class=p>};</span>
</code></pre></div></td></tr></table></div> 接着看 enable 函数的逻辑。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span></pre></div></td><td class=code><div><pre><span></span><code><span class=kt>void</span><span class=w> </span><span class=nf>NodeCategorySet::Enable</span><span class=p>(</span><span class=k>const</span><span class=w> </span><span class=n>FunctionCallbackInfo</span><span class=o>&lt;</span><span class=n>Value</span><span class=o>&gt;&amp;</span><span class=w> </span><span class=n>args</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=n>NodeCategorySet</span><span class=o>*</span><span class=w> </span><span class=n>category_set</span><span class=p>;</span>
<span class=w>  </span><span class=n>ASSIGN_OR_RETURN_UNWRAP</span><span class=p>(</span><span class=o>&amp;</span><span class=n>category_set</span><span class=p>,</span><span class=w> </span><span class=n>args</span><span class=p>.</span><span class=n>Holder</span><span class=p>());</span>
<span class=w>  </span><span class=k>const</span><span class=w> </span><span class=k>auto</span><span class=o>&amp;</span><span class=w> </span><span class=n>categories</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>category_set</span><span class=o>-&gt;</span><span class=n>GetCategories</span><span class=p>();</span>
<span class=w>  </span><span class=c1>// 非空并且没有启动则启动</span>
<span class=w>  </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>category_set</span><span class=o>-&gt;</span><span class=n>enabled_</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=o>!</span><span class=n>categories</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=c1>// 启动 trace agent，如果已经启动则直接返回</span>
<span class=w>    </span><span class=n>StartTracingAgent</span><span class=p>();</span>
<span class=w>    </span><span class=c1>// 通过 writer 注册需要 trace 的模块</span>
<span class=w>    </span><span class=n>GetTracingAgentWriter</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>Enable</span><span class=p>(</span><span class=n>categories</span><span class=p>);</span>
<span class=w>    </span><span class=n>category_set</span><span class=o>-&gt;</span><span class=n>enabled_</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>true</span><span class=p>;</span>
<span class=w>  </span><span class=p>}</span>
<span class=p>}</span>
</code></pre></div></td></tr></table></div> 接着看 GetTracingAgentWriter()-&gt;Enable(categories)。GetTracingAgentWriter 返回到是一个 AgentWriterHandle 对象。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span>
<span class=normal>7</span>
<span class=normal>8</span>
<span class=normal>9</span></pre></div></td><td class=code><div><pre><span></span><code><span class=kt>void</span><span class=w> </span><span class=nf>AgentWriterHandle::Enable</span><span class=p>(</span><span class=k>const</span><span class=w> </span><span class=n>std</span><span class=o>::</span><span class=n>set</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;&amp;</span><span class=w> </span><span class=n>categories</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>agent_</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>nullptr</span><span class=p>)</span><span class=w> </span><span class=n>agent_</span><span class=o>-&gt;</span><span class=n>Enable</span><span class=p>(</span><span class=n>id_</span><span class=p>,</span><span class=w> </span><span class=n>categories</span><span class=p>);</span>
<span class=p>}</span>

<span class=kt>void</span><span class=w> </span><span class=nf>Agent::Enable</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=n>std</span><span class=o>::</span><span class=n>set</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;&amp;</span><span class=w> </span><span class=n>categories</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=n>ScopedSuspendTracing</span><span class=w> </span><span class=n>suspend</span><span class=p>(</span><span class=n>tracing_controller_</span><span class=p>.</span><span class=n>get</span><span class=p>(),</span><span class=w> </span><span class=n>this</span><span class=p>,</span>
<span class=w>                               </span><span class=n>id</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>kDefaultHandleId</span><span class=p>);</span>
<span class=w>  </span><span class=n>categories_</span><span class=p>[</span><span class=n>id</span><span class=p>].</span><span class=n>insert</span><span class=p>(</span><span class=n>categories</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span><span class=w> </span><span class=n>categories</span><span class=p>.</span><span class=n>end</span><span class=p>());</span>
<span class=p>}</span>
</code></pre></div></td></tr></table></div> 这样就完成了 trace 系统的初始化和订阅了需要 trace 的模块。不过这里还有一个关键的逻辑就是通知 v8，因为开启了哪些 category 是由 v8 管理的，当新增 category 的时候，需要通知 v8。下面看 ScopedSuspendTracing，前面分析过 ScopedSuspendTracing 利用 RAII 在初始化时调用 controller-&gt;StopTracing()，析构时调 controller_-&gt;StartTracing(config)。我们看一下这两个函数。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span>
<span class=normal>24</span></pre></div></td><td class=code><div><pre><span></span><code><span class=kt>void</span><span class=w> </span><span class=nf>TracingController::StopTracing</span><span class=p>()</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=kt>bool</span><span class=w> </span><span class=n>expected</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>true</span><span class=p>;</span>
<span class=w>  </span><span class=c1>// 判断是否已经开启了 trace，是则关闭（recording_ 为 false），否则直接 return</span>
<span class=w>  </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>recording_</span><span class=p>.</span><span class=n>compare_exchange_strong</span><span class=p>(</span><span class=n>expected</span><span class=p>,</span><span class=w> </span><span class=nb>false</span><span class=p>))</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=k>return</span><span class=p>;</span>
<span class=w>  </span><span class=p>}</span>
<span class=w>  </span><span class=c1>// 修改所有 category 为关闭哦状态</span>
<span class=w>  </span><span class=n>UpdateCategoryGroupEnabledFlags</span><span class=p>();</span>
<span class=w>  </span><span class=n>std</span><span class=o>::</span><span class=n>unordered_set</span><span class=o>&lt;</span><span class=n>v8</span><span class=o>::</span><span class=n>TracingController</span><span class=o>::</span><span class=n>TraceStateObserver</span><span class=o>*&gt;</span><span class=w> </span><span class=n>observers_copy</span><span class=p>;</span>
<span class=w>  </span><span class=p>{</span>
<span class=w>    </span><span class=n>base</span><span class=o>::</span><span class=n>MutexGuard</span><span class=w> </span><span class=n>lock</span><span class=p>(</span><span class=n>mutex_</span><span class=p>.</span><span class=n>get</span><span class=p>());</span>
<span class=w>    </span><span class=n>observers_copy</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>observers_</span><span class=p>;</span>
<span class=w>  </span><span class=p>}</span>
<span class=w>  </span><span class=c1>// 通知 trace 观察者</span>
<span class=w>  </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=k>auto</span><span class=w> </span><span class=n>o</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>observers_copy</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=n>o</span><span class=o>-&gt;</span><span class=n>OnTraceDisabled</span><span class=p>();</span>
<span class=w>  </span><span class=p>}</span>
<span class=w>  </span><span class=c1>// 通知 writer 刷数据到目的地</span>
<span class=w>  </span><span class=p>{</span>
<span class=w>    </span><span class=n>base</span><span class=o>::</span><span class=n>MutexGuard</span><span class=w> </span><span class=n>lock</span><span class=p>(</span><span class=n>mutex_</span><span class=p>.</span><span class=n>get</span><span class=p>());</span>
<span class=w>    </span><span class=n>DCHECK</span><span class=p>(</span><span class=n>trace_buffer_</span><span class=p>);</span>
<span class=w>    </span><span class=n>trace_buffer_</span><span class=o>-&gt;</span><span class=n>Flush</span><span class=p>();</span>
<span class=w>  </span><span class=p>}</span>
<span class=p>}</span>
</code></pre></div></td></tr></table></div> 逻辑比较明了，主要看 UpdateCategoryGroupEnabledFlags。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span>
<span class=normal>24</span></pre></div></td><td class=code><div><pre><span></span><code><span class=kt>void</span><span class=w> </span><span class=nf>TracingController::UpdateCategoryGroupEnabledFlags</span><span class=p>()</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=c1>// g_category_index 记录了目前 category 数量</span>
<span class=w>  </span><span class=kt>size_t</span><span class=w> </span><span class=n>category_index</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>base</span><span class=o>::</span><span class=n>Acquire_Load</span><span class=p>(</span><span class=o>&amp;</span><span class=n>g_category_index</span><span class=p>);</span>
<span class=w>  </span><span class=c1>// 清除所有 category 的 开启标记</span>
<span class=w>  </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>size_t</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>category_index</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=n>UpdateCategoryGroupEnabledFlag</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
<span class=p>}</span>

<span class=kt>void</span><span class=w> </span><span class=nf>TracingController::UpdateCategoryGroupEnabledFlag</span><span class=p>(</span><span class=kt>size_t</span><span class=w> </span><span class=n>category_index</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=kt>unsigned</span><span class=w> </span><span class=kt>char</span><span class=w> </span><span class=n>enabled_flag</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span>
<span class=w>  </span><span class=c1>// g_category_groups 记录了所有 category 的名称</span>
<span class=w>  </span><span class=k>const</span><span class=w> </span><span class=kt>char</span><span class=o>*</span><span class=w> </span><span class=n>category_group</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>g_category_groups</span><span class=p>[</span><span class=n>category_index</span><span class=p>];</span>
<span class=w>  </span><span class=cm>/*</span>
<span class=cm>   判断是否正在 trace 并且订阅了 category_group 对应的 category，</span>
<span class=cm>   是则设置开启标记，开启了才能收集对应 category 的 trace 数据</span>
<span class=cm>  */</span>
<span class=w>  </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>recording_</span><span class=p>.</span><span class=n>load</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_acquire</span><span class=p>)</span><span class=w> </span><span class=o>&amp;&amp;</span>
<span class=w>      </span><span class=n>trace_config_</span><span class=o>-&gt;</span><span class=n>IsCategoryGroupEnabled</span><span class=p>(</span><span class=n>category_group</span><span class=p>))</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=n>enabled_flag</span><span class=w> </span><span class=o>|=</span><span class=w> </span><span class=n>ENABLED_FOR_RECORDING</span><span class=p>;</span>
<span class=w>  </span><span class=p>}</span>
<span class=w>  </span><span class=c1>// 设置 category 的开启标记</span>
<span class=w>  </span><span class=n>base</span><span class=o>::</span><span class=n>Relaxed_Store</span><span class=p>(</span><span class=n>reinterpret_cast</span><span class=o>&lt;</span><span class=n>base</span><span class=o>::</span><span class=n>Atomic8</span><span class=o>*&gt;</span><span class=p>(</span>
<span class=w>                          </span><span class=n>g_category_group_enabled</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>category_index</span><span class=p>),</span>
<span class=w>                      </span><span class=n>enabled_flag</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div></td></tr></table></div> UpdateCategoryGroupEnabledFlag 在开启和停止 trace 的时候都会被调用，但是对应的逻辑不一样，当停止的时候，recording_ 是 false，所以 enabled_flag 是 0，即清除所有 category 的开启标记。在开启 trace 时，recording_ 是 true，然后根据当前订阅的 category 设置对应的开关。接着看开启 trace 逻辑。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span></pre></div></td><td class=code><div><pre><span></span><code><span class=kt>void</span><span class=w> </span><span class=nf>TracingController::StartTracing</span><span class=p>(</span><span class=n>TraceConfig</span><span class=o>*</span><span class=w> </span><span class=n>trace_config</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=c1>// 记录当前 trace 的 category</span>
<span class=w>  </span><span class=n>trace_config_</span><span class=p>.</span><span class=n>reset</span><span class=p>(</span><span class=n>trace_config</span><span class=p>);</span>
<span class=w>  </span><span class=n>std</span><span class=o>::</span><span class=n>unordered_set</span><span class=o>&lt;</span><span class=n>v8</span><span class=o>::</span><span class=n>TracingController</span><span class=o>::</span><span class=n>TraceStateObserver</span><span class=o>*&gt;</span><span class=w> </span><span class=n>observers_copy</span><span class=p>;</span>
<span class=w>  </span><span class=p>{</span>
<span class=w>    </span><span class=n>base</span><span class=o>::</span><span class=n>MutexGuard</span><span class=w> </span><span class=n>lock</span><span class=p>(</span><span class=n>mutex_</span><span class=p>.</span><span class=n>get</span><span class=p>());</span>
<span class=w>    </span><span class=c1>// 设置开启 trace 标记</span>
<span class=w>    </span><span class=n>recording_</span><span class=p>.</span><span class=n>store</span><span class=p>(</span><span class=nb>true</span><span class=p>,</span><span class=w> </span><span class=n>std</span><span class=o>::</span><span class=n>memory_order_release</span><span class=p>);</span>
<span class=w>    </span><span class=c1>// 设置打开收集 category 数据的开关</span>
<span class=w>    </span><span class=n>UpdateCategoryGroupEnabledFlags</span><span class=p>();</span>
<span class=w>    </span><span class=n>observers_copy</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>observers_</span><span class=p>;</span>
<span class=w>  </span><span class=p>}</span>
<span class=w>  </span><span class=c1>// 通知 trace 观察者</span>
<span class=w>  </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=k>auto</span><span class=w> </span><span class=n>o</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>observers_copy</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=n>o</span><span class=o>-&gt;</span><span class=n>OnTraceEnabled</span><span class=p>();</span>
<span class=w>  </span><span class=p>}</span>
<span class=p>}</span>
</code></pre></div></td></tr></table></div> StartTracing 和 StopTracing 逻辑比较相似。订阅成功后，后续产生 trace 数据就会写入到文件。</p> <h2 id=43-inspector>4.3 通过 inspector 模块<a class=headerlink href=#43-inspector title="Permanent link">&para;</a></h2> <p>第三种方式不仅可以动态开启，还能直接拿到 trace 数据，这种方式具体是通过 Inspector 协议。首先看一下如何使用这种方式。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span>
<span class=normal>21</span>
<span class=normal>22</span>
<span class=normal>23</span>
<span class=normal>24</span>
<span class=normal>25</span>
<span class=normal>26</span>
<span class=normal>27</span>
<span class=normal>28</span>
<span class=normal>29</span>
<span class=normal>30</span>
<span class=normal>31</span></pre></div></td><td class=code><div><pre><span></span><code><span class=k>const</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>Session</span><span class=w> </span><span class=p>}</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>require</span><span class=p>(</span><span class=err>&#39;</span><span class=n>inspector</span><span class=err>&#39;</span><span class=p>);</span>
<span class=k>const</span><span class=w> </span><span class=n>session</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>new</span><span class=w> </span><span class=n>Session</span><span class=p>();</span>
<span class=n>session</span><span class=p>.</span><span class=n>connect</span><span class=p>();</span>
<span class=n>function</span><span class=w> </span><span class=nf>post</span><span class=p>(</span><span class=n>message</span><span class=p>,</span><span class=w> </span><span class=n>data</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=k>return</span><span class=w> </span><span class=n>new</span><span class=w> </span><span class=n>Promise</span><span class=p>((</span><span class=n>resolve</span><span class=p>,</span><span class=w> </span><span class=n>reject</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=n>session</span><span class=p>.</span><span class=n>post</span><span class=p>(</span><span class=n>message</span><span class=p>,</span><span class=w> </span><span class=n>data</span><span class=p>,</span><span class=w> </span><span class=p>(</span><span class=n>err</span><span class=p>,</span><span class=w> </span><span class=n>result</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span>
<span class=w>      </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>err</span><span class=p>)</span>
<span class=w>        </span><span class=n>reject</span><span class=p>(</span><span class=n>new</span><span class=w> </span><span class=n>Error</span><span class=p>(</span><span class=n>JSON</span><span class=p>.</span><span class=n>stringify</span><span class=p>(</span><span class=n>err</span><span class=p>)));</span>
<span class=w>      </span><span class=k>else</span>
<span class=w>        </span><span class=n>resolve</span><span class=p>(</span><span class=n>result</span><span class=p>);</span>
<span class=w>    </span><span class=p>});</span>
<span class=w>  </span><span class=p>});</span>
<span class=p>}</span>

<span class=n>async</span><span class=w> </span><span class=n>function</span><span class=w> </span><span class=n>test</span><span class=p>()</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=n>session</span><span class=p>.</span><span class=n>on</span><span class=p>(</span><span class=err>&#39;</span><span class=n>NodeTracing</span><span class=p>.</span><span class=n>dataCollected</span><span class=err>&#39;</span><span class=p>,</span><span class=w> </span><span class=p>(</span><span class=n>data</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span>
<span class=w>      </span><span class=n>console</span><span class=p>.</span><span class=n>log</span><span class=p>(</span><span class=n>data</span><span class=p>.</span><span class=n>params</span><span class=p>.</span><span class=n>value</span><span class=p>);</span>
<span class=w>    </span><span class=p>});</span>

<span class=w>    </span><span class=n>session</span><span class=p>.</span><span class=n>on</span><span class=p>(</span><span class=err>&#39;</span><span class=n>NodeTracing</span><span class=p>.</span><span class=n>tracingComplete</span><span class=err>&#39;</span><span class=p>,</span><span class=w> </span><span class=p>()</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span>
<span class=w>        </span><span class=n>console</span><span class=p>.</span><span class=n>log</span><span class=p>(</span><span class=err>&#39;</span><span class=n>done</span><span class=err>&#39;</span><span class=p>);</span>
<span class=w>    </span><span class=p>});</span>
<span class=w>    </span><span class=k>const</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>categories</span><span class=w> </span><span class=p>}</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>await</span><span class=w> </span><span class=n>post</span><span class=p>(</span><span class=err>&#39;</span><span class=n>NodeTracing</span><span class=p>.</span><span class=n>getCategories</span><span class=err>&#39;</span><span class=p>);</span>
<span class=w>    </span><span class=k>const</span><span class=w> </span><span class=n>traceConfig</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>includedCategories</span><span class=o>:</span><span class=w> </span><span class=n>categories</span><span class=w> </span><span class=p>};</span>
<span class=w>    </span><span class=n>await</span><span class=w> </span><span class=n>post</span><span class=p>(</span><span class=err>&#39;</span><span class=n>NodeTracing</span><span class=p>.</span><span class=n>start</span><span class=err>&#39;</span><span class=p>,</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>traceConfig</span><span class=w> </span><span class=p>});</span>
<span class=w>    </span><span class=n>setTimeout</span><span class=p>(()</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span>
<span class=w>        </span><span class=n>post</span><span class=p>(</span><span class=err>&#39;</span><span class=n>NodeTracing</span><span class=p>.</span><span class=n>stop</span><span class=err>&#39;</span><span class=p>);</span>
<span class=w>    </span><span class=p>},</span><span class=w> </span><span class=mi>1000</span><span class=p>);</span>
<span class=p>}</span>

<span class=n>test</span><span class=p>();</span>
</code></pre></div></td></tr></table></div> 使用方式比较固定，也比较简单，trace event 是基于类型的，比如同步文件 IO，DNS 解析。所以第一步首先设置需要收集的模块类型，也可以通过 NodeTracing.getCategories 命令获取当前支持的模块类型。接着通过 NodeTracing.start 开启数据收集，收集一段时间后，通过 NodeTracing.stop 停止数据的收集，在这个过程中，收集的数据会通过 NodeTracing.dataCollected 事件源源不断地流向用户侧，我们可以保存这些数据后续进行分析，收集完毕后会触发 NodeTracing.tracingComplete 事件，从而完成整个过程。下面我们来看一下这些命令的实现。首先看一下整体的架构。 <img alt src=https://img-blog.csdnimg.cn/557b66ab4a164e8f904b586c13da7339.png> 之前介绍过 Node.js Inspector 的架构，本文就不再具体展开介绍。简单来说，当我们通过 js 层的 session 发送命令时，代码流程从图的左边到右边，收集到数据时，代码流程从右往左回调 js 层。首先来看一下 NodeTracing.start。Node.js 的 Inspector 框架采用两级路由的机制，首先通过 NodeTracing 找到一级路由，在 inspetor 里叫 Domain，然后再通过 start 找到二级路由。 来看一下每个路由对应的函数。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span></pre></div></td><td class=code><div><pre><span></span><code><span class=n>m_dispatchMap</span><span class=p>[</span><span class=s>&quot;NodeTracing.getCategories&quot;</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>DispatcherImpl</span><span class=o>::</span><span class=n>getCategories</span><span class=p>;</span>
<span class=n>m_dispatchMap</span><span class=p>[</span><span class=s>&quot;NodeTracing.start&quot;</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>DispatcherImpl</span><span class=o>::</span><span class=n>start</span><span class=p>;</span>
<span class=n>m_dispatchMap</span><span class=p>[</span><span class=s>&quot;NodeTracing.stop&quot;</span><span class=p>]</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>DispatcherImpl</span><span class=o>::</span><span class=n>stop</span><span class=p>;</span>
</code></pre></div></td></tr></table></div> 我们只关注 start 和 stop 的逻辑。</p> <p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span></pre></div></td><td class=code><div><pre><span></span><code><span class=kt>void</span><span class=w> </span><span class=nf>DispatcherImpl::start</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>callId</span><span class=p>,</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=n>String</span><span class=o>&amp;</span><span class=w> </span><span class=n>method</span><span class=p>,</span><span class=w> </span><span class=k>const</span><span class=w> </span><span class=n>ProtocolMessage</span><span class=o>&amp;</span><span class=w> </span><span class=n>message</span><span class=p>,</span><span class=w> </span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>DictionaryValue</span><span class=o>&gt;</span><span class=w> </span><span class=n>requestMessageObject</span><span class=p>,</span><span class=w> </span><span class=n>ErrorSupport</span><span class=o>*</span><span class=w> </span><span class=n>errors</span><span class=p>)</span>
<span class=p>{</span>
<span class=w>    </span><span class=n>protocol</span><span class=o>::</span><span class=n>DictionaryValue</span><span class=o>*</span><span class=w> </span><span class=n>object</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>DictionaryValue</span><span class=o>::</span><span class=n>cast</span><span class=p>(</span><span class=n>requestMessageObject</span><span class=o>-&gt;</span><span class=n>get</span><span class=p>(</span><span class=s>&quot;params&quot;</span><span class=p>));</span>
<span class=w>    </span><span class=n>protocol</span><span class=o>::</span><span class=n>Value</span><span class=o>*</span><span class=w> </span><span class=n>traceConfigValue</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>object</span><span class=w> </span><span class=o>?</span><span class=w> </span><span class=n>object</span><span class=o>-&gt;</span><span class=n>get</span><span class=p>(</span><span class=s>&quot;traceConfig&quot;</span><span class=p>)</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>nullptr</span><span class=p>;</span>
<span class=w>    </span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>protocol</span><span class=o>::</span><span class=n>NodeTracing</span><span class=o>::</span><span class=n>TraceConfig</span><span class=o>&gt;</span><span class=w> </span><span class=n>in_traceConfig</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>ValueConversions</span><span class=o>&lt;</span><span class=n>protocol</span><span class=o>::</span><span class=n>NodeTracing</span><span class=o>::</span><span class=n>TraceConfig</span><span class=o>&gt;::</span><span class=n>fromValue</span><span class=p>(</span><span class=n>traceConfigValue</span><span class=p>,</span><span class=w> </span><span class=n>errors</span><span class=p>);</span>

<span class=w>    </span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>DispatcherBase</span><span class=o>::</span><span class=n>WeakPtr</span><span class=o>&gt;</span><span class=w> </span><span class=n>weak</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>weakPtr</span><span class=p>();</span>
<span class=w>    </span><span class=n>DispatchResponse</span><span class=w> </span><span class=n>response</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>m_backend</span><span class=o>-&gt;</span><span class=n>start</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>in_traceConfig</span><span class=p>));</span>
<span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>weak</span><span class=o>-&gt;</span><span class=n>get</span><span class=p>())</span>
<span class=w>        </span><span class=n>weak</span><span class=o>-&gt;</span><span class=n>get</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>sendResponse</span><span class=p>(</span><span class=n>callId</span><span class=p>,</span><span class=w> </span><span class=n>response</span><span class=p>);</span>
<span class=w>    </span><span class=k>return</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div></td></tr></table></div> start 里调用了 m_backend-&gt;start，根据架构图可知道 m_backend 的值是 TracingAgent 对象。</p> <p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span></pre></div></td><td class=code><div><pre><span></span><code><span class=n>DispatchResponse</span><span class=w> </span><span class=nf>TracingAgent::start</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>protocol</span><span class=o>::</span><span class=n>NodeTracing</span><span class=o>::</span><span class=n>TraceConfig</span><span class=o>&gt;</span><span class=w> </span><span class=n>traceConfig</span><span class=p>)</span><span class=w> </span><span class=p>{</span>

<span class=w>  </span><span class=n>std</span><span class=o>::</span><span class=n>set</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;</span><span class=w> </span><span class=n>categories_set</span><span class=p>;</span>
<span class=w>  </span><span class=n>protocol</span><span class=o>::</span><span class=n>Array</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&gt;*</span><span class=w> </span><span class=n>categories</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>traceConfig</span><span class=o>-&gt;</span><span class=n>getIncludedCategories</span><span class=p>();</span>
<span class=w>  </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=kt>size_t</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>categories</span><span class=o>-&gt;</span><span class=n>length</span><span class=p>();</span><span class=w> </span><span class=n>i</span><span class=o>++</span><span class=p>)</span>
<span class=w>    </span><span class=n>categories_set</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>categories</span><span class=o>-&gt;</span><span class=n>get</span><span class=p>(</span><span class=n>i</span><span class=p>));</span>

<span class=w>  </span><span class=n>tracing</span><span class=o>::</span><span class=n>AgentWriterHandle</span><span class=o>*</span><span class=w> </span><span class=n>writer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>GetTracingAgentWriter</span><span class=p>();</span>
<span class=w>  </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>writer</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>nullptr</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=n>trace_writer_</span><span class=w> </span><span class=o>=</span>
<span class=w>        </span><span class=n>writer</span><span class=o>-&gt;</span><span class=n>agent</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>AddClient</span><span class=p>(</span><span class=n>categories_set</span><span class=p>,</span>
<span class=w>                                   </span><span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>InspectorTraceWriter</span><span class=o>&gt;</span><span class=p>(</span>
<span class=w>                                       </span><span class=n>frontend_object_id_</span><span class=p>,</span><span class=w> </span><span class=n>main_thread_</span><span class=p>),</span>
<span class=w>                                   </span><span class=n>tracing</span><span class=o>::</span><span class=n>Agent</span><span class=o>::</span><span class=n>kIgnoreDefaultCategories</span><span class=p>);</span>
<span class=w>  </span><span class=p>}</span>
<span class=w>  </span><span class=k>return</span><span class=w> </span><span class=n>DispatchResponse</span><span class=o>::</span><span class=n>OK</span><span class=p>();</span>
<span class=p>}</span>
</code></pre></div></td></tr></table></div> 最终通过 AddClient 往 tracing 系统注册了一个消费者，inspector 模块实现了自己的 writer InspectorTraceWriter。当tracing 系统产生数据时，就会通过 InspectorTraceWriter 进行消费，看一下这个 InspectorTraceWriter 对象的核心逻辑。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span>
<span class=normal>17</span>
<span class=normal>18</span>
<span class=normal>19</span>
<span class=normal>20</span></pre></div></td><td class=code><div><pre><span></span><code><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>AppendTraceEvent</span><span class=p>(</span>
<span class=w>      </span><span class=n>v8</span><span class=o>::</span><span class=n>platform</span><span class=o>::</span><span class=n>tracing</span><span class=o>::</span><span class=n>TraceObject</span><span class=o>*</span><span class=w> </span><span class=n>trace_event</span><span class=p>)</span><span class=w> </span><span class=n>override</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>json_writer_</span><span class=p>)</span>
<span class=w>      </span><span class=n>json_writer_</span><span class=p>.</span><span class=n>reset</span><span class=p>(</span><span class=n>TraceWriter</span><span class=o>::</span><span class=n>CreateJSONTraceWriter</span><span class=p>(</span><span class=n>stream_</span><span class=p>,</span><span class=w> </span><span class=s>&quot;value&quot;</span><span class=p>));</span>
<span class=w>    </span><span class=n>json_writer_</span><span class=o>-&gt;</span><span class=n>AppendTraceEvent</span><span class=p>(</span><span class=n>trace_event</span><span class=p>);</span>
<span class=w>  </span><span class=p>}</span>

<span class=w>  </span><span class=kt>void</span><span class=w> </span><span class=nf>Flush</span><span class=p>(</span><span class=kt>bool</span><span class=p>)</span><span class=w> </span><span class=n>override</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>json_writer_</span><span class=p>)</span>
<span class=w>      </span><span class=k>return</span><span class=p>;</span>
<span class=w>    </span><span class=n>json_writer_</span><span class=p>.</span><span class=n>reset</span><span class=p>();</span>
<span class=w>    </span><span class=n>std</span><span class=o>::</span><span class=n>ostringstream</span><span class=w> </span><span class=n>result</span><span class=p>(</span>
<span class=w>        </span><span class=s>&quot;{</span><span class=se>\&quot;</span><span class=s>method</span><span class=se>\&quot;</span><span class=s>:</span><span class=se>\&quot;</span><span class=s>NodeTracing.dataCollected</span><span class=se>\&quot;</span><span class=s>,</span><span class=se>\&quot;</span><span class=s>params</span><span class=se>\&quot;</span><span class=s>:&quot;</span><span class=p>,</span>
<span class=w>        </span><span class=n>std</span><span class=o>::</span><span class=n>ostringstream</span><span class=o>::</span><span class=n>ate</span><span class=p>);</span>
<span class=w>    </span><span class=n>result</span><span class=w> </span><span class=o>&lt;&lt;</span><span class=w> </span><span class=n>stream_</span><span class=p>.</span><span class=n>str</span><span class=p>();</span>
<span class=w>    </span><span class=n>result</span><span class=w> </span><span class=o>&lt;&lt;</span><span class=w> </span><span class=s>&quot;}&quot;</span><span class=p>;</span>
<span class=w>    </span><span class=n>main_thread_</span><span class=o>-&gt;</span><span class=n>Post</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>SendMessageRequest</span><span class=o>&gt;</span><span class=p>(</span><span class=n>frontend_object_id_</span><span class=p>,</span>
<span class=w>                                                            </span><span class=n>result</span><span class=p>.</span><span class=n>str</span><span class=p>()));</span>
<span class=w>    </span><span class=n>stream_</span><span class=p>.</span><span class=n>str</span><span class=p>(</span><span class=s>&quot;&quot;</span><span class=p>);</span>
<span class=w>  </span><span class=p>}</span>
</code></pre></div></td></tr></table></div> tracing 系统调用 AppendTraceEvent 进行数据的消费，不过这些数据会先缓存到内存，然后再调用 Flush 通知真正的消费者，在 Flush 函数里我们可以看到，通过发送一个 SendMessageRequest 触发了 NodeTracing.dataCollected 事件。接着看一下 SendMessageRequest 的逻辑。</p> <p><div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span></pre></div></td><td class=code><div><pre><span></span><code><span class=kt>void</span><span class=w> </span><span class=nf>Call</span><span class=p>(</span><span class=n>MainThreadInterface</span><span class=o>*</span><span class=w> </span><span class=kr>thread</span><span class=p>)</span><span class=w> </span><span class=n>override</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=n>DeletableFrontendWrapper</span><span class=o>*</span><span class=w> </span><span class=n>frontend_wrapper</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>static_cast</span><span class=o>&lt;</span><span class=n>DeletableFrontendWrapper</span><span class=o>*&gt;</span><span class=p>(</span><span class=kr>thread</span><span class=o>-&gt;</span><span class=n>GetObjectIfExists</span><span class=p>(</span><span class=n>object_id_</span><span class=p>));</span>
<span class=w>  </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>frontend_wrapper</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>nullptr</span><span class=p>)</span><span class=w> </span><span class=k>return</span><span class=p>;</span>
<span class=w>  </span><span class=k>auto</span><span class=w> </span><span class=n>frontend</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>frontend_wrapper</span><span class=o>-&gt;</span><span class=n>get</span><span class=p>();</span>
<span class=w>  </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>frontend</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>nullptr</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=n>frontend</span><span class=o>-&gt;</span><span class=n>sendRawJSONNotification</span><span class=p>(</span><span class=n>message_</span><span class=p>);</span>
<span class=w>  </span><span class=p>}</span>
<span class=p>}</span>

<span class=kt>void</span><span class=w> </span><span class=nf>Frontend::sendRawJSONNotification</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>notification</span><span class=p>)</span>
<span class=p>{</span>
<span class=w>    </span><span class=n>m_frontendChannel</span><span class=o>-&gt;</span><span class=n>sendProtocolNotification</span><span class=p>(</span><span class=n>InternalRawNotification</span><span class=o>::</span><span class=n>fromJSON</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>notification</span><span class=p>)));</span>
<span class=p>}</span>
</code></pre></div></td></tr></table></div> Call 又调用了 m_frontendChannel-&gt;sendRawJSONNotification，根据架构图，m_frontendChannel 的值是 ChannelImpl。最后通过 ChannelImpl 通知用户侧。 接着看 stop 的逻辑。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span></pre></div></td><td class=code><div><pre><span></span><code><span class=n>DispatchResponse</span><span class=w> </span><span class=nf>TracingAgent::stop</span><span class=p>()</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=n>trace_writer_</span><span class=p>.</span><span class=n>reset</span><span class=p>();</span>
<span class=w>  </span><span class=n>frontend_</span><span class=o>-&gt;</span><span class=n>tracingComplete</span><span class=p>();</span>
<span class=w>  </span><span class=k>return</span><span class=w> </span><span class=n>DispatchResponse</span><span class=o>::</span><span class=n>OK</span><span class=p>();</span>
<span class=p>}</span>
</code></pre></div></td></tr></table></div> 首先看一下 trace_writer_.reset()。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span>
<span class=normal>14</span>
<span class=normal>15</span>
<span class=normal>16</span></pre></div></td><td class=code><div><pre><span></span><code><span class=kt>void</span><span class=w> </span><span class=nf>AgentWriterHandle::reset</span><span class=p>()</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>agent_</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>nullptr</span><span class=p>)</span>
<span class=w>    </span><span class=n>agent_</span><span class=o>-&gt;</span><span class=n>Disconnect</span><span class=p>(</span><span class=n>id_</span><span class=p>);</span>
<span class=w>  </span><span class=n>agent_</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>nullptr</span><span class=p>;</span>
<span class=p>}</span>

<span class=kt>void</span><span class=w> </span><span class=nf>Agent::Disconnect</span><span class=p>(</span><span class=kt>int</span><span class=w> </span><span class=n>client</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>  </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>client</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>kDefaultHandleId</span><span class=p>)</span><span class=w> </span><span class=k>return</span><span class=p>;</span>
<span class=w>  </span><span class=p>{</span>
<span class=w>    </span><span class=n>Mutex</span><span class=o>::</span><span class=n>ScopedLock</span><span class=w> </span><span class=n>lock</span><span class=p>(</span><span class=n>initialize_writer_mutex_</span><span class=p>);</span>
<span class=w>    </span><span class=n>to_be_initialized_</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>writers_</span><span class=p>[</span><span class=n>client</span><span class=p>].</span><span class=n>get</span><span class=p>());</span>
<span class=w>  </span><span class=p>}</span>
<span class=w>  </span><span class=n>ScopedSuspendTracing</span><span class=w> </span><span class=n>suspend</span><span class=p>(</span><span class=n>tracing_controller_</span><span class=p>.</span><span class=n>get</span><span class=p>(),</span><span class=w> </span><span class=n>this</span><span class=p>);</span>
<span class=w>  </span><span class=n>writers_</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>client</span><span class=p>);</span>
<span class=w>  </span><span class=n>categories_</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>client</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div></td></tr></table></div> 接着看 ScopedSuspendTracing。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal> 1</span>
<span class=normal> 2</span>
<span class=normal> 3</span>
<span class=normal> 4</span>
<span class=normal> 5</span>
<span class=normal> 6</span>
<span class=normal> 7</span>
<span class=normal> 8</span>
<span class=normal> 9</span>
<span class=normal>10</span>
<span class=normal>11</span>
<span class=normal>12</span>
<span class=normal>13</span></pre></div></td><td class=code><div><pre><span></span><code><span class=n>ScopedSuspendTracing</span><span class=p>(</span><span class=n>TracingController</span><span class=o>*</span><span class=w> </span><span class=n>controller</span><span class=p>,</span><span class=w> </span><span class=n>Agent</span><span class=o>*</span><span class=w> </span><span class=n>agent</span><span class=p>,</span>
<span class=w>                       </span><span class=kt>bool</span><span class=w> </span><span class=n>do_suspend</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>true</span><span class=p>)</span>
<span class=w>    </span><span class=o>:</span><span class=w> </span><span class=n>controller_</span><span class=p>(</span><span class=n>controller</span><span class=p>),</span><span class=w> </span><span class=n>agent_</span><span class=p>(</span><span class=n>do_suspend</span><span class=w> </span><span class=o>?</span><span class=w> </span><span class=n>agent</span><span class=w> </span><span class=o>:</span><span class=w> </span><span class=n>nullptr</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>do_suspend</span><span class=p>)</span><span class=w> </span><span class=p>{</span>
<span class=w>      </span><span class=n>CHECK</span><span class=p>(</span><span class=n>agent_</span><span class=o>-&gt;</span><span class=n>started_</span><span class=p>);</span>
<span class=w>      </span><span class=n>controller</span><span class=o>-&gt;</span><span class=n>StopTracing</span><span class=p>();</span>
<span class=w>    </span><span class=p>}</span>
<span class=p>}</span>

<span class=kt>void</span><span class=w> </span><span class=n>TracingController</span><span class=o>::</span><span class=n>StopTracing</span><span class=p>()</span><span class=w> </span><span class=p>{</span>
<span class=w> </span><span class=n>base</span><span class=o>::</span><span class=n>MutexGuard</span><span class=w> </span><span class=nf>lock</span><span class=p>(</span><span class=n>mutex_</span><span class=p>.</span><span class=n>get</span><span class=p>());</span>
<span class=w> </span><span class=n>trace_buffer_</span><span class=o>-&gt;</span><span class=n>Flush</span><span class=p>();</span>
<span class=p>}</span>
</code></pre></div></td></tr></table></div> 把所有数据 Flush 到用户侧后触发 tracingComplete 事件。 <div class=highlight><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span><span class=normal>1</span>
<span class=normal>2</span>
<span class=normal>3</span>
<span class=normal>4</span>
<span class=normal>5</span>
<span class=normal>6</span></pre></div></td><td class=code><div><pre><span></span><code><span class=kt>void</span><span class=w> </span><span class=nf>Frontend::tracingComplete</span><span class=p>()</span>
<span class=p>{</span>
<span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=o>!</span><span class=n>m_frontendChannel</span><span class=p>)</span>
<span class=w>        </span><span class=k>return</span><span class=p>;</span>
<span class=w>    </span><span class=n>m_frontendChannel</span><span class=o>-&gt;</span><span class=n>sendProtocolNotification</span><span class=p>(</span><span class=n>InternalResponse</span><span class=o>::</span><span class=n>createNotification</span><span class=p>(</span><span class=s>&quot;NodeTracing.tracingComplete&quot;</span><span class=p>));</span>
<span class=p>}</span>
</code></pre></div></td></tr></table></div></p> </article> </div> <script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script> </div> <button type=button class="md-top md-icon" data-md-component=top hidden> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg> 回到页面顶部 </button> </main> <footer class=md-footer> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-copyright> <div class=md-copyright__highlight> Copyright &copy; 2021 theanarkh </div> Made with <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs </a> </div> <div class=md-social> <a href=https://github.com/theanarkh target=_blank rel=noopener title=github.com class=md-social__link> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 496 512"><!-- Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg> </a> <a href=https://www.zhihu.com/people/theanarkh target=_blank rel=noopener title=www.zhihu.com class=md-social__link> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 640 512"><!-- Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M170.54 148.13v217.54l23.43.01 7.71 26.37 42.01-26.37h49.53V148.13zm97.75 193.93h-27.94l-27.9 17.51-5.08-17.47-11.9-.04V171.75h72.82zm-118.46-94.39H97.5c1.74-27.1 2.2-51.59 2.2-73.46h51.16s1.97-22.56-8.58-22.31h-88.5c3.49-13.12 7.87-26.66 13.12-40.67 0 0-24.07 0-32.27 21.57-3.39 8.9-13.21 43.14-30.7 78.12 5.89-.64 25.37-1.18 36.84-22.21 2.11-5.89 2.51-6.66 5.14-14.53h28.87c0 10.5-1.2 66.88-1.68 73.44H20.83c-11.74 0-15.56 23.62-15.56 23.62h65.58C66.45 321.1 42.83 363.12 0 396.34c20.49 5.85 40.91-.93 51-9.9 0 0 22.98-20.9 35.59-69.25l53.96 64.94s7.91-26.89-1.24-39.99c-7.58-8.92-28.06-33.06-36.79-41.81L87.9 311.95c4.36-13.98 6.99-27.55 7.87-40.67h61.65s-.09-23.62-7.59-23.62zm412.02-1.6c20.83-25.64 44.98-58.57 44.98-58.57s-18.65-14.8-27.38-4.06c-6 8.15-36.83 48.2-36.83 48.2zm-150.09-59.09c-9.01-8.25-25.91 2.13-25.91 2.13s39.52 55.04 41.12 57.45l19.46-13.73s-25.67-37.61-34.66-45.86h-.01zM640 258.35c-19.78 0-130.91.93-131.06.93v-101c4.81 0 12.42-.4 22.85-1.2 40.88-2.41 70.13-4 87.77-4.81 0 0 12.22-27.19-.59-33.44-3.07-1.18-23.17 4.58-23.17 4.58s-165.22 16.49-232.36 18.05c1.6 8.82 7.62 17.08 15.78 19.55 13.31 3.48 22.69 1.7 49.15.89 24.83-1.6 43.68-2.43 56.51-2.43v99.81H351.41s2.82 22.31 25.51 22.85h107.94v70.92c0 13.97-11.19 21.99-24.48 21.12-14.08.11-26.08-1.15-41.69-1.81 1.99 3.97 6.33 14.39 19.31 21.84 9.88 4.81 16.17 6.57 26.02 6.57 29.56 0 45.67-17.28 44.89-45.31v-73.32h122.36c9.68 0 8.7-23.78 8.7-23.78z"/></svg> </a> </div> </div> </div> </footer> </div> <div class=md-dialog data-md-component=dialog> <div class="md-dialog__inner md-typeset"></div> </div> <script id=__config type=application/json>{"base": "..", "features": ["content.code.annotate", "navigation.indexes", "navigation.instant", "navigation.tabs", "navigation.tabs.sticky", "navigation.sections", "navigation.top", "navigation.tracking", "search.highlight", "search.share", "search.suggest"], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script> <script src=../assets/javascripts/bundle.83f73b43.min.js></script> <script src=../extra/image.js defer></script> </body> </html>